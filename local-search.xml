<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust之包管理</title>
    <link href="/2020/08/02/Rust%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2020/08/02/Rust%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust包管理"><a href="#Rust包管理" class="headerlink" title="Rust包管理"></a>Rust包管理</h1><p>title: Rust包管理<br>date: 2020-06-04 21:47:57<br>toc: true<br>tags: rust<br>categories: rust<br>description: Rust包管理机制,module,crate.</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p><strong>模块 Module</strong> 用于将函数或结构体按照功能分组。我们通常把相似的函数或者实现相同功能的或者共同实现一个功能的函数和结构体划分到一个模块中。</p><p>Rust中模块的概念类似其他语言中模块或者包的概念,以我们常用的Java为例,Rust模块等价于Java中的一个Package.</p><h2 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h2><p>在Java中我们可以将Package组织为为Module,在Rust中同样如此:我们可以将Rust中的模块进一步组织为crate.</p><blockquote><p>crate中文翻译为箱|板条,个人感觉crate不够直观,甚至不如直接沿用其他语言的概念.</p></blockquote><p>crate是Rust语言的基本编译单元.在Rust中,一个可执行的二进制文件或者一个库就是一个crate.其中可执行二进制文件和库的唯一区别就是二进制文件中含有<code>main()</code>入口.</p><h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h2><p>Rust采用cargo作为crate管理程序,简单来说cargo就是包管理器.比如Dart中使用pub来管理包.此外,Rust使用crates.io作为管理所有第三方包的中央存储服务器,这类似Dart中的pub.dev,android中的jcenter.</p><table><thead><tr><th>rust</th><th>dart</th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/lionoggo/blog-images/master/img/image-20200802201756474.png" srcset="/img/loading.gif" alt=""></td><td><img src="https://raw.githubusercontent.com/lionoggo/blog-images/master/img/image-20200802201818781.png" srcset="/img/loading.gif" alt="image-20200802201818781"></td></tr></tbody></table><p>我们可以使用<code>cargo install</code>来从crates.io中安装需要的crate.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述提到的几个术语,在其他语言中都有对应的概念,下表简单对比下:</p><table><thead><tr><th>Rust术语</th><th>说明</th></tr></thead><tbody><tr><td>crate</td><td>Rust中编译的基本单元,等价于其他语言中的library中的概念,比如dart中的library</td></tr><tr><td>module</td><td>模块,等价于其他语言中package的概念,比如Java/dart中的package</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h1><h2 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h2><p>Rust中使用mod关键字来定义一个模块,根据访问权限,模块分为公开模块和私有模块,模块定义格式如下:</p><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> module_name &#123;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function_name</span></span>() &#123;    <span class="hljs-comment">// code body</span>  &#125;   ...&#125;</code></pre><p>这里的module_name用于表示模块名,必须是一个合法的标志符,格式和函数名定义一样,如下所示:</p><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> desktop &#123;    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">doctor</span></span>() &#123;       <span class="hljs-comment">// code body</span>    &#125;&#125; <span class="hljs-comment">/* desktop */</span></code></pre><h2 id="公开模块-amp-私有模块"><a href="#公开模块-amp-私有模块" class="headerlink" title="公开模块&amp;私有模块"></a>公开模块&amp;私有模块</h2><p>Rust中模块和模块中函数默认都是私有权限,外部无法访问.如果需要公开模块或者函数给外部使用,需要使用pub关键字,格式如下:</p><pre><code class="hljs rust"><span class="hljs-comment">// 公开模块</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> module_name &#123;  <span class="hljs-comment">// 公开函数</span>  <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function_name</span></span>() &#123;      &#125;    <span class="hljs-comment">// 私有函数</span>  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function_name</span></span>()&#123;      &#125;&#125;</code></pre><blockquote><p>需要注意,私有模块中的函数必须都是私有的,公开模块中的函数可以是私有的,也可以是公有的.</p></blockquote><h2 id="嵌套module"><a href="#嵌套module" class="headerlink" title="嵌套module"></a>嵌套module</h2><p>Rust支持在一个模块中嵌套另一个模块,格式如下:</p><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> first_module &#123;  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> second_module &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> third_module &#123;      <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">say_hello</span></span>()&#123;          <span class="hljs-comment">// code body</span>      &#125;    &#125;  &#125;&#125;</code></pre><p>上述代码中,first_module嵌套了second_module,而second_module又嵌套third_module.在third_module中定义了<code>say_hello()</code>.</p><p>嵌套模块调用非常简单,只需要用<code>::</code>逐级限定模块名即可,比如<code>first_module::second_module::third_module::say_hello()</code></p><h2 id="范例-模块定义与使用"><a href="#范例-模块定义与使用" class="headerlink" title="范例: 模块定义与使用"></a>范例: 模块定义与使用</h2><p>这里我们定义一个desktop模块,并提供一个用于进行检测的doctor方法:</p><pre><code class="hljs rust"><span class="hljs-comment">// 定义</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> desktop &#123;    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">doctor</span></span>() &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Checking..."</span>);    &#125;&#125; <span class="hljs-comment">/* desktop */</span><span class="hljs-comment">// 调用</span><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;    <span class="hljs-comment">// 全限定路径</span>    desktop::doctor();&#125;</code></pre><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>和C++类似,Rust使用use关键字来引入需要用到的外部模块中的函数和结构体,通过使用use关键字,我们可以预先引入外部模块的函数和构造体而无需再使用全限定模块.</p><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> desktop &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">doctor</span></span>() &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Checking..."</span>);    &#125;&#125;<span class="hljs-keyword">use</span> desktop::doctor;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;    <span class="hljs-comment">// 无需全路径限定</span>    doctor();&#125;</code></pre><h1 id="crate-1"><a href="#crate-1" class="headerlink" title="crate"></a>crate</h1><p>现在结合module来演示crate的使用.这里我们准备创建一个名为ugo的crate,其中有commander和desktop两个module.</p><pre><code class="hljs shell">ugo- commander- module</code></pre><h2 id="创建crate"><a href="#创建crate" class="headerlink" title="创建crate"></a>创建crate</h2><p>我们使用cargo来管理我们的rust工程,同样这里也用它来管理crate.首先我们来创建一个名为ugo的工作目录,接下来使用<code>cargo new module-name --lib</code>来创建名为module-name的模块:</p><pre><code class="hljs shell">cargo new commander --libcargo new module --lib</code></pre><p>现在我们得到了如下结构的目录:</p><pre><code class="hljs shell">ugo├── commander│   ├── Cargo.toml│   └── src│       ├── doctor.rs│       └── lib.rs└── desktop    ├── Cargo.toml    └── src        └── lib.rs</code></pre><h3 id="Cargo-toml"><a href="#Cargo-toml" class="headerlink" title="Cargo.toml"></a>Cargo.toml</h3><p>cargo通过使用Cargo.toml来保存/设置库的一些基本数据,比如版本号,库名称,作者以及三方依赖等.其中toml是一种语义化的配置文件格式:</p><pre><code class="hljs toml"><span class="hljs-section">[package]</span><span class="hljs-attr">name</span> = <span class="hljs-string">"desktop"</span>  <span class="hljs-comment"># 库名</span><span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span> <span class="hljs-comment"># 版本号</span><span class="hljs-attr">authors</span> = [<span class="hljs-string">"author &lt;author@gmail.com&gt;"</span>] <span class="hljs-comment"># 作者</span><span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><span class="hljs-section">[dependencies]</span><span class="hljs-comment"># 依赖</span></code></pre><h2 id="lib-rs"><a href="#lib-rs" class="headerlink" title="lib.rs"></a>lib.rs</h2><p>每个crate中的lib.rs用于指定库公开了哪些可用的模块.使用cargo创建的crate中的lib.rs中默认会有一些代码,这里我们先直接删除.</p><p>首先我们commander中添加一个doctor.rs,用于输出当前的环境信息:</p><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">shell_vesion</span></span>() &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Shell vesion"</span>);&#125;</code></pre><p>接下来,我们在lib.rs中将doctor模块导出:</p><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> doctor;</code></pre><p>此时,commander结构如下:</p><pre><code class="hljs shell">commander├── Cargo.toml└── src    ├── doctor.rs    └── lib.rs</code></pre><p>同样的,我们为desktop也提供类似的实现,</p><pre><code class="hljs rust"><span class="hljs-comment">// src/doctor.rs</span><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">desktop_version</span></span>() &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Desktop platform"</span>);&#125;<span class="hljs-comment">// src/lib.rs</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> doctor;</code></pre><p>现在我们可以通过cargo build来执行构建操作,同时它也可以用来检查我们crate是否有错误.进入commander/deskop下分别执行下,构建无误的情况下回输出下述信息:</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo build</span>   Compiling desktop v0.1.0 (/Users/lionoggo/Workspace/Rust/module_test/ugo/desktop)    Finished dev [unoptimized + debuginfo] target(s) in 0.12s</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们来创建一个测试程序,在ugo目录下执行<code>cargo new main --bin</code>即可.ugo-main将使用我们上述的两个crate,并分别调用其函数,先来看下当前工程目录:</p><pre><code class="hljs shell">ugo├── commander│   ├── Cargo.lock│   ├── Cargo.toml│   └── src│       ├── doctor.rs│       └── lib.rs├── desktop│   ├── Cargo.lock│   ├── Cargo.toml│   └── src│       ├── doctor.rs│       └── lib.rs└── main    ├── Cargo.toml    └── src        └── main.rs</code></pre><p>解析来,打开main中额Cargo.toml,将commander/desktop两个crate配置为本地依赖:</p><pre><code class="hljs toml"><span class="hljs-section">[package]</span><span class="hljs-attr">name</span> = <span class="hljs-string">"ugo-main"</span><span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span><span class="hljs-attr">authors</span> = [<span class="hljs-string">"author &lt;author@gmail.com&gt;"</span>]<span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><span class="hljs-section">[dependencies]</span><span class="hljs-comment"># 本地依赖</span><span class="hljs-attr">commander</span> = &#123; path = <span class="hljs-string">"../commander"</span> &#125;<span class="hljs-attr">desktop</span> = &#123; path = <span class="hljs-string">"../desktop"</span> &#125;</code></pre><p><img src="https://raw.githubusercontent.com/lionoggo/blog-images/master/img/image-20200802221705368.png" srcset="/img/loading.gif" alt=""></p><h3 id="使用crate"><a href="#使用crate" class="headerlink" title="使用crate"></a>使用crate</h3><p>现在我们要在ugo-main中来使用上述两个crate.要想使用crate中的module,首先需要使用extern关键字引入外部库:</p><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> desktop;<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> commander;</code></pre><p>接下来分别调用两个crate中的函数:</p><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> desktop;<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> commander;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;    commander::doctor::shell_version();    desktop::doctor::desktop_version();&#125;</code></pre><p>在上述代码中,我们使用全限定路径来调用函数,如果crate中的函数比较多,这样用起来五一很麻烦,此时可以使用use导入module:</p><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> desktop;<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> commander;<span class="hljs-keyword">use</span> desktop::doctor::desktop_version;<span class="hljs-keyword">use</span> commander::doctor::shell_version;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;    shell_version();    desktop_version();&#125;</code></pre><p>执行<code>cargo run</code>,不出意外,结果如下:</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run</span>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s     Running `target/debug/ugo-main`Shell vesionDesktop platform</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim高级使用技巧</title>
    <link href="/2020/05/04/Vim%E9%AB%98%E9%98%B6%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/05/04/Vim%E9%AB%98%E9%98%B6%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim重复命令"><a href="#Vim重复命令" class="headerlink" title="Vim重复命令"></a>Vim重复命令</h1><h2 id="命令"><a href="#命令" class="headerlink" title=".命令"></a>.命令</h2><p>.命令用于”重复上次的修改”,可以通过<code>:h .</code>来查看其更多用法,实际上.命令是一个微型的宏:从进入插入模式的那一刻起(例如输入i),直到返回普通模式为止(输入<Esc>),Vim会记录每一个按键的操作.做出这样的一个修改后再通.命令的话,它将会执行所有这些按键的操作.</p><p>可重复的操作</p><table><thead><tr><th>目的</th><th>操作</th><th>重复</th><th>回退</th></tr></thead><tbody><tr><td>做出一个修改</td><td><code>{edit}</code></td><td>.</td><td>u</td></tr><tr><td>在行内查找下一个指定字符</td><td><code>f{char}/t{char}</code></td><td>;</td><td>.</td></tr><tr><td>在行内查找上一个指定字符</td><td><code>F{char}/T{char}</code></td><td>;</td><td>.</td></tr><tr><td>在文档中查找下一处匹配项</td><td><code>/pattern&lt;CR&gt;</code></td><td>n</td><td>N</td></tr><tr><td>在文档中查找上一处匹配项</td><td><code>?pattern&lt;CR&gt;</code></td><td>n</td><td>N</td></tr><tr><td>执行替换</td><td><code>:s/target/replacement</code></td><td>&amp;</td><td>u</td></tr><tr><td>执行一系列修改</td><td><code>qx{changes}q</code></td><td>@x</td><td>u</td></tr></tbody></table><p>dd: 删除一行;</p><p>u:撤销上次操作;</p><p><code>&gt;G</code>:增加从当前行到文档末尾处的缩进层级;</p><p>a: 在当前光标之后添加内容;</p><p>A: 在当前行的结尾添加内容;</p><p>s:先删除光标下的字符,然后进入插入模式.比如我们要将<code>+argument</code>修改为<code>+ argument</code>,那么就可以执行<code>s + &lt;Esc&gt;</code>.</p><p>f:查找下一处指定字符出现的位置,比如<code>f+</code>会查找加号出现的位置;而<code>;</code>会重复上次<code>f</code>命令所查找的字符;’,’命令会反方向炒作`f``所查找的字符.</p><p>*:查找当前光标下的单词:光标会跳到下一个匹配项,所有出现这个词的地方都会被高亮(如果没有高亮,执行<code>:set hls</code>)</p><p>cw: 删除从光标位置到单词结尾见的字符,并进入插入模式.</p><h1 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h1><h2 id="反向删除"><a href="#反向删除" class="headerlink" title="反向删除"></a>反向删除</h2><p>正向删除</p><p>db命令会删除从光标起始位置到单词开头的内容,但会留下起始的字符,比如nigh单词中,如果光标处于h位置,name通过db操作后,最后会留下h.</p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>在按下<code>:</code>键时,Vim会切换到命令行模式.在此模式下执行的命令成为ex命令,可以用ex命令读写文件(:edit和:write),创建新的标签页(:tabnew),分割窗口(:split)等,更多使用查阅<code>:h ex-cmd-index</code>.</p><p>大多数ex命令可以指定操作范围.,常见的ex命令如下所示:</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:[range]delete [x]</code></td><td>删除指定范围内的行[到寄存器x中]</td></tr><tr><td><code>:[range]yank [x]</code></td><td>复制指定范围内的行[到寄存器x中]</td></tr><tr><td><code>:[line]put [x]</code></td><td>在照顾度不够刚归一粘贴寄存器x中的内容</td></tr><tr><td><code>:[range]copy {address}</code></td><td>把指定范围内的行拷贝到 {address} 指定的行之下</td></tr><tr><td><code>:[range]move {address}</code></td><td>把指定范围内的行移动到 {address} 指定的行之下</td></tr><tr><td><code>:[rage]join</code></td><td>连接指定范围的行</td></tr><tr><td><code>:[range] normal {commands}</code></td><td>对指定范围内的每一行执行普通模式命令 {commands}</td></tr><tr><td><code>:[range]substitute/{pattern}/{string}/[flags]</code></td><td>把指定范围内出现{pattern}的地方替换为{string}</td></tr><tr><td><code>[range]global/{pattern}/[cmd]</code></td><td>对指定范围内匹配{pattern}的所有行执行ex命令{cmd}</td></tr></tbody></table><h2 id="选中行-范围"><a href="#选中行-范围" class="headerlink" title="选中行/范围"></a>选中行/范围</h2><h3 id="跳转到指定行"><a href="#跳转到指定行" class="headerlink" title="跳转到指定行"></a>跳转到指定行</h3><p>如果输入一条只包含数字的ex命令,那么vim会把它解析城一个地址,跳转到该数字指定的行上.</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 跳转到低三行,并显示该行内容</span>:3p</code></pre><p>上述命令实际是哪个是吧<code>:3</code>和<code>:p</code>两条命令合起来.</p><h3 id="使用地址指定范围"><a href="#使用地址指定范围" class="headerlink" title="使用地址指定范围"></a>使用地址指定范围</h3><p><code>:{start},{end}</code>: {start}和{end}分别表示起始地址.需要注意,除了使用行号作为地址外,也能使用查找模式或是位置标记作为地址.</p><p>符合<code>.</code>表示当前行地址,比如<code>.,$p</code>表示从当前位置到文件末尾的所有行.符号%在命令模式下又特殊含义,表示当前文件的所有行.<code>:%p</code>和<code>:1,$p</code>是等价的,都是显式所有行.</p><h3 id="用高亮选区指定范围"><a href="#用高亮选区指定范围" class="headerlink" title="用高亮选区指定范围"></a>用高亮选区指定范围</h3><p>当使用选择模式选中范围后,再按<code>:</code>,命令行上会预先填充一个范围<code>:&#39;&lt;,&#39;&gt;</code>,在这里<code>&#39;&lt;</code>表示高亮选区首行的位置标记,<code>&#39;&gt;</code>则表示高亮选区的最后一行.</p><h3 id="用模式指定范围"><a href="#用模式指定范围" class="headerlink" title="用模式指定范围"></a>用模式指定范围</h3><p>在该模式下也接受以模式作为一条ex命令的地址,比如<code>:/&lt;html&gt;/,/&lt;\html&gt;/p</code>.</p><h3 id="使用偏移地址"><a href="#使用偏移地址" class="headerlink" title="使用偏移地址"></a>使用偏移地址</h3><p><code>:{address}+n</code>,n被省略表示偏移量为1.{address}可以是行号,位置标记或者查找模式.比如想对当前行开始的特定几行执行ex命令:</p><pre><code class="hljs shell">:2:.,.+2p</code></pre><p>最终相当于执行了<code>:2,5p</code>.</p><p>常用符号</p><table><thead><tr><th>符号</th><th>地址</th></tr></thead><tbody><tr><td>1</td><td>文件的第一行</td></tr><tr><td>$</td><td>文件的最后一行</td></tr><tr><td>0</td><td>虚拟化,位于文件第一行上方</td></tr><tr><td>.</td><td>光标所在行</td></tr><tr><td>‘m</td><td>包含位置比较m的行</td></tr><tr><td>‘&lt;</td><td>高亮选区的起始行</td></tr><tr><td>‘&gt;</td><td>高亮选区的结束行</td></tr><tr><td>%</td><td>整个文件(:,$的简写形式)</td></tr></tbody></table><h2 id="复制-移动指定行"><a href="#复制-移动指定行" class="headerlink" title="复制/移动指定行"></a>复制/移动指定行</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><code>:copy</code>命令可以让我们吧一行或者多行从文档的一部分复制到另一部分,格式为<code>:[range]copy {address}</code>.可以简写为<code>:co</code>,该命令也等价于<code>:t</code>(理解为复制到,即copy To更好记).</p><pre><code class="hljs shell">:6copy. # 复制第6行到当前行下:6t.:t6# 把当前行复制到第6行下方:t.# 类似yyp,为当前行创建副本:t$# 把当前行复制文本结尾:'&lt;,'&gt;t0# 把高亮选中的行复制到文件开头</code></pre><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p><code>:move</code>命令可以让我们把一行或多行移动到文档的另一位置,格式为<code>:[range]move {address}</code>,可以简写为<code>:m</code>.</p><h2 id="在指定范围内执行普通模式命令"><a href="#在指定范围内执行普通模式命令" class="headerlink" title="在指定范围内执行普通模式命令"></a>在指定范围内执行普通模式命令</h2><p><code>:normal</code>命令可以在一些列连续行上执行一套普通模式命令.比如批量在句子后添加分好或者注释多行:</p><pre><code class="hljs shell">: %normal A;# 在文件的每行结尾添加分好: %normal i//# 在文件的每行开头添加//以注释</code></pre><h2 id="重复上次的ex命令"><a href="#重复上次的ex命令" class="headerlink" title="重复上次的ex命令"></a>重复上次的ex命令</h2><p><code>.</code>命令用于重复上次的修改,但是不会重复由Vim命令行中做出的修改.作为替代,可以用<code>@:</code>来重复上次的ex命令,具体可见<code>:h @:</code></p><h2 id="自动补全ex命令"><a href="#自动补全ex命令" class="headerlink" title="自动补全ex命令"></a>自动补全ex命令</h2><p>在命令行业可以使用<code>Tab</code>键进行补全.此外<code>C-d</code>命令会上Vim显示可用的补全列表:</p><pre><code class="hljs shell">:colorschemeblue        default     desert      evening     industry    koehler     morning     pablo       peaksea     ron         slate       tortedarkblue    delek       elflord     gruvbox     ir_black    mayansmoke  murphy      peachpuff   pyte        shine       solarized   zellner:colorscheme</code></pre><p>可以通过<code>wildmode</code>来自定义自动补全行为,具体参考<code>:h &#39;wildmode&#39;</code>.通常我们会是哟好难过zsh提供的自动补全模式:</p><pre><code class="hljs shell">set wildmenuset wildmode=full</code></pre><h2 id="把当前单词插入命令行"><a href="#把当前单词插入命令行" class="headerlink" title="把当前单词插入命令行"></a>把当前单词插入命令行</h2><p>在Vim命令行下,<code>&lt;C-r&gt;&lt;C-w&gt;</code>会复制光标下的单词并把它插入命令行中.如果想插入光标下的自传,可以使用<code>&lt;C-r&gt;&lt;C-a&gt;</code>,具体可查阅<code>:h c_CTRL-R_CTRL-W</code>.</p><p>有个非常好用的,在vimrc中可以通过该功能快速查看不认识的设置项:将光标移到其中的一项设置上,然后输入<code>:h &lt;C-r&gt;&lt;C-w&gt;</code>,就可以查阅该设置的文档了.</p><h2 id="回溯ex历史"><a href="#回溯ex历史" class="headerlink" title="回溯ex历史"></a>回溯ex历史</h2><p>Vim会记录命令行模式下的历史命令.在输入<code>:</code>的前提下,使用方向上下键可回溯.默认Vim会记录20条,但是可以将下属配置添加到vimrc中:</p><pre><code class="hljs shell">set history=500</code></pre><p>在回溯历史中最常用的是命令行窗口,它是一个常规的Vim缓冲区,它的每行内容都对应着命令历史中的一个条目,可以使用<code>k</code>,<code>j</code>上下移动,可以使用查找功能.在按下<code>&lt;CR&gt;</code>键时,会把当前命令行中的内容当初ex命令执行.</p><p>此外在该模式下,允许使用Vim完整的,区分模式的编辑能力来修改历史命令,比如合并等.普通模式下按<code>q:</code>调出命令行窗口.</p><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td><code>q/</code></td><td>打开查找命令历史的窗口</td></tr><tr><td><code>q:</code></td><td>打开ex命令历史的命令行窗口</td></tr><tr><td><code>&lt;Ctrl-f&gt;</code></td><td>从命令行模式切换到命令行窗口</td></tr></tbody></table><p><img src="https://i.imgur.com/pMReD6l.png" srcset="/img/loading.gif" alt="image-20200504153757969"></p><h2 id="运行shell命令"><a href="#运行shell命令" class="headerlink" title="运行shell命令"></a>运行shell命令</h2><p>在Vim的命令行模式下,给命令加<code>!</code>前缀就可以调用外部程序,具体可见<code>:h !</code>.</p><pre><code class="hljs shell">:!ls[No write since last change]Vim使用技巧.assetsVim使用技巧.mdshell编程笔记_convert.md技术-Android技术-Flutter技术-前端</code></pre><p>需要注意<code>:ls</code>和<code>:!ls</code>不同:前者是vim的内置命令,后者调用的是shell的ls命令.</p><p>在Vim的命令行中,符号%代表当前文件名.在有些情况下,我们可能正在开发一个shell脚本,并且在开发阶段可能会想要去执行它,此时不需要先退出vim,再在shell中执行,而是可以在Vim命令行中直接运行它:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> %在这里就表示当前正在开发的shell脚本</span>:!bash %</code></pre><h3 id="Vim退出到后台"><a href="#Vim退出到后台" class="headerlink" title="Vim退出到后台"></a>Vim退出到后台</h3><p>在有些情况下,我们可能正在bash shell中运行Vim,然后需要一些shell命令,此时可以先按照Ctrl-z挂起Vim所属的进程,在需要的时候在通过fg命令唤起.另外可以使用jobs查看后台作业:</p>]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Flutter技术内幕:Platform Channel设计与实现(一)</title>
    <link href="/2019/02/09/%E6%B7%B1%E5%85%A5Flutter%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95_Platform%20Channel%E5%8E%9F%E7%90%86/"/>
    <url>/2019/02/09/%E6%B7%B1%E5%85%A5Flutter%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95_Platform%20Channel%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Flutter作为一个灵活的UI框架,引入Platform Channel机制来支持不同平台的API调用,无论是Android上的由Java或Kotlin开发的API,还是IOS上用Objective-C或Swift开发API.需要注意的是Platform Channel不依赖代码生成,而是建立在消息传递方式上.实际上,它的工作模式和原理非常类似基于二进制协议开发的网络服务,在下文中,我们会对此有更深的理解与体会.</p><h1 id="Platform-Channel简介"><a href="#Platform-Channel简介" class="headerlink" title="Platform Channel简介"></a>Platform Channel简介</h1><p>在Flutter中,提供了三种Platform Channel用来支持和平台之间数据的传递:</p><ul><li>BasicMessageChannel: 支持字符串和半结构化的数据传递</li><li>MethodChannel: 支持方法调用,既可以从Flutter发平台发起方法调用,也可以从平台代码向Flutter发起调用</li><li>EventChannel: 支持数据流通信</li></ul><p>这三种Platform Channel分别用不同的作用,但在设计上大同小异,他们都有以下三个成员变量:</p><ul><li>name:表示Channel名字,每个Channel使用唯一的name作为其唯一标志</li><li>messager:信使,是消息的发送和接受工具</li><li>codec: 表示消息的编解码器,目前有MethodCodec和MessageCodec两种类型</li></ul><h2 id="Platform-Channel基本结构"><a href="#Platform-Channel基本结构" class="headerlink" title="Platform Channel基本结构"></a>Platform Channel基本结构</h2><p>为了对这三种Platform Channel有个比较感性的认识,通过以下简化过的代码来熟悉它们的结构.比较熟悉的同学可以直接跳过此章节.</p><h3 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicMessageChannel</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BinaryMessenger messenger;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageCodec&lt;T&gt; codec;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessageHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MessageHandler&lt;T&gt; handler)</span> </span>&#123;        messenger.setMessageHandler(name,            handler == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> IncomingMessageHandler(handler));    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageHandler</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(T message, Reply&lt;T&gt; reply)</span></span>;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncomingMessageHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessageHandler</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MessageHandler&lt;T&gt; handler;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IncomingMessageHandler</span><span class="hljs-params">(MessageHandler&lt;T&gt; handler)</span> </span>&#123;            <span class="hljs-keyword">this</span>.handler = handler;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(ByteBuffer message, <span class="hljs-keyword">final</span> BinaryReply callback)</span> </span>&#123;            ......            handler.onMessage();            ......        &#125;    &#125;         &#125;</code></pre><h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BinaryMessenger messenger;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodCodec codec;        ......        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMethodCallHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> @Nullable MethodCallHandler handler)</span> </span>&#123;        messenger.setMessageHandler(name,            handler == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> IncomingMethodCallHandler(handler));    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Result</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">success</span><span class="hljs-params">(@Nullable Object result)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String errorCode, @Nullable String errorMessage, @Nullable Object errorDetails)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notImplemented</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodCallHandler</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(MethodCall call, Result result)</span></span>;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncomingMethodCallHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessageHandler</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodCallHandler handler;        IncomingMethodCallHandler(MethodCallHandler handler) &#123;            <span class="hljs-keyword">this</span>.handler = handler;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(ByteBuffer message, <span class="hljs-keyword">final</span> BinaryReply reply)</span> </span>&#123;            ......            handler.onMethodCall();            ......        &#125;    &#125;     &#125;</code></pre><h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventChannel</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BinaryMessenger messenger;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodCodec codec;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStreamHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> StreamHandler handler)</span> </span>&#123;        messenger.setMessageHandler(name, handler == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> IncomingStreamRequestHandler(handler));    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StreamHandler</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onListen</span><span class="hljs-params">(Object arguments, EventSink events)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCancel</span><span class="hljs-params">(Object arguments)</span></span>;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventSink</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">success</span><span class="hljs-params">(Object event)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String errorCode, String errorMessage, Object errorDetails)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endOfStream</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncomingStreamRequestHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessageHandler</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StreamHandler handler;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;EventSink&gt; activeSink = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-keyword">null</span>);        IncomingStreamRequestHandler(StreamHandler handler) &#123;            <span class="hljs-keyword">this</span>.handler = handler;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(ByteBuffer message, <span class="hljs-keyword">final</span> BinaryReply reply)</span> </span>&#123;            ......            handler.onCancel();            ......            handler.onListen();               ......        &#125;    &#125;&#125;</code></pre><h2 id="name-Channel名称"><a href="#name-Channel名称" class="headerlink" title="name(Channel名称)"></a>name(Channel名称)</h2><p>name是用于区分不同Platform Channel的唯一标志.在一个Flutter应用中,通常会存在多个Platform Channel,不同Channel之间通过name那么来区分.比如在使用MethodChannel平台发起方法调用时,需要为MethodChannel指定对应的name.</p><h2 id="messager-信使"><a href="#messager-信使" class="headerlink" title="messager(信使)"></a>messager(信使)</h2><p>messager也称为信使,通俗来说信使就是现代的快递员,它负责把数据从Flutter搬运到JAndroid/IOS平台,或者从Android/IOS搬运到Flutter).对于Flutter中的三种Channel,尽管各自用途不同,但messager都是BinaryMessager.</p><p>当我们创建一个Channel时,并为其设置消息处理器时,最终会为该Channel绑定一个BinaryMessagerHandler.并以Channel的name为key,保存在Map结构中.当接受到发送消息后,会根据消息中携带的channel名称取出对应BinaryMessagerHandler,并交由其处理.在Android平台中,BinaryMessenger是一个接口,其实现类是FlutterNativeView.在后续<a href="#BinaryMessenger">MethodChannel</a>调用原理中,会进一步分析.</p><h2 id="Codec-编解码器"><a href="#Codec-编解码器" class="headerlink" title="Codec(编解码器)"></a>Codec(编解码器)</h2><p>在Platform Channel中,messager携带的数据需要在Dart层,Native层以及Android/IOS平台中传输,需要考虑一种与平台无关的数据协议,且又能支持图片/文件等资源,因此官方最终采用了二进制字节流作为数据传输协议:发送方需要把数据编码成二进制数据,接受方再把数据解码成原始数据.而负责编解码操作的就是Codec.</p><p>在Flutter中有两种Codec:</p><ul><li>MethodCodec: 用于对MethodCall编解码</li><li>MessageCodec: 用于对Message进行编解码</li></ul><h3 id="MessageCodec"><a href="#MessageCodec" class="headerlink" title="MessageCodec"></a>MessageCodec</h3><p>MessageCodec用于二进制数据与基础数据之间的编解码,其中BasicMessageChannel中采用的就是该Codec.以Android平台为例,MessageCodec定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageCodec</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 将指定的类型message编码为二进制数据ByteBuffer</span>    <span class="hljs-function">ByteBuffer <span class="hljs-title">encodeMessage</span><span class="hljs-params">(T message)</span></span>;    <span class="hljs-comment">// 将二进制数据ByteBuffer解码成指定类型</span>    <span class="hljs-function">T <span class="hljs-title">decodeMessage</span><span class="hljs-params">(ByteBuffer message)</span></span>;&#125;</code></pre><p>MessageCodec被设计为一个泛型接口,用于实现二进制数据ByteBuffer和不同类型数据之间的转换.(在IOS中,可参考FlutterMessageCodec协议,其原理基本一致).</p><p>在Flutter中,目前MessageCodec有多种实现:</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g00gywsky2j32dx0u0wxl.jpg" srcset="/img/loading.gif" alt="image-20190209205941331"></p><h4 id="BinaryCodec"><a href="#BinaryCodec" class="headerlink" title="BinaryCodec"></a>BinaryCodec</h4><p>用于二进制数据和二进制数据之间的编解码,在实现上什么也没有做,只是原封不动的将二进制数据返回而已.</p><h4 id="StringCodec"><a href="#StringCodec" class="headerlink" title="StringCodec"></a>StringCodec</h4><p>用于字符串与二进制数据之间的编解码,对于字符串采用UTF-8编码格式.</p><h4 id="JSONMessageCodec"><a href="#JSONMessageCodec" class="headerlink" title="JSONMessageCodec"></a>JSONMessageCodec</h4><p>用于数据类型与二进制数据之间的编解码,支持基础数据类型(boolean,char,double,float,int,long,short,String)以及List,Map.在Android端使用<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8/-/blob/shell/platform/android/io/flutter/plugin/common/JSONUtil.java?utm_source=share#L25" target="_blank" rel="noopener">JSONUtil</a>和StringCodec作为序列化和反序列化工具.</p><h4 id="StandardMessageCodec"><a href="#StandardMessageCodec" class="headerlink" title="StandardMessageCodec"></a>StandardMessageCodec</h4><p>用于数据类型和二进制数据之间的编解码,它也是BasicMessageChannel中默认使用的编解码器,支持基础数据类型(boolean,char,double,float,int,long,short,String),List,Map以及二进制数据,更多参见:<a href="#深入编解码器原理">深入编解码器原理</a></p><h3 id="MethodCodec"><a href="#MethodCodec" class="headerlink" title="MethodCodec"></a>MethodCodec</h3><p>MethodCodec用于二进制数据与方法调用(MethodCall)和返回结果之间的编解码.MethodChannel和EventChannel所使用的编解码器均为MethodCodec.以Android平台为例,MethodCodec定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodCodec</span> </span>&#123;    <span class="hljs-comment">// 将methodCall编码为二进制ByteBuffer</span>    <span class="hljs-function">ByteBuffer <span class="hljs-title">encodeMethodCall</span><span class="hljs-params">(MethodCall methodCall)</span></span>;    <span class="hljs-comment">// 将二进制methodCall解码为MethodCall</span>    <span class="hljs-function">MethodCall <span class="hljs-title">decodeMethodCall</span><span class="hljs-params">(ByteBuffer methodCall)</span></span>;    <span class="hljs-comment">// 将正常响应结果result编码为二进制ByteBuffer</span>    <span class="hljs-function">ByteBuffer <span class="hljs-title">encodeSuccessEnvelope</span><span class="hljs-params">(Object result)</span></span>;    <span class="hljs-comment">// 将错误响应提示编码为二进制ByteBuffer</span>    <span class="hljs-function">ByteBuffer <span class="hljs-title">encodeErrorEnvelope</span><span class="hljs-params">(String errorCode, String errorMessage, Object errorDetails)</span></span>;    <span class="hljs-comment">// 将二进制数据ByteBuffer解码成Object</span>    <span class="hljs-function">Object <span class="hljs-title">decodeEnvelope</span><span class="hljs-params">(ByteBuffer envelope)</span></span>;&#125;</code></pre><p>一个MethodCall对象代表一次从Flutter端发起的方法调用,对于方法调用而言,涉及方法名,方法参数以及方法返回结果,因此和MessageCodec相比,MethodCodec中多了两个处理调用结果的方法:</p><ul><li>方法调用成功,使用<code>encodeSuccessEnvelope()</code>编码result</li><li>方法调用失败,使用<code>encodeErrorEnvelope()</code>编码errorCode,errorMessage,errorDetail</li></ul><blockquote><p><code>decodeEnvelope()</code>方法则用于解码平台代码调用Dart中方法的结果.比如Android平台通过MethodChannel调用Flutter中的方法,且获取其返回结果</p></blockquote><p>在Flutter中,目前MethodCodec有两种实现:</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g00bceb3z0j316c0nan01.jpg" srcset="/img/loading.gif" alt="image-20190209174504635"></p><h4 id="JSONMethodCodec"><a href="#JSONMethodCodec" class="headerlink" title="JSONMethodCodec"></a>JSONMethodCodec</h4><p>JSONMethodCodec编解码器依赖于JSONMessageCodec.在将MethodCall对象进行编码时,会首先将该对象转成JSON对象:{“method”:method,”args”:args},比如当前想要调用某个Channel的<code>setVolum(5)</code>,其对应的MethodCall被被转成<code>{&quot;method&quot;:&quot;setVolum&quot;,&quot;args&quot;:{&quot;volum&quot;:5}}</code>,接下来使用JSONMessageCodec将其编码为二进制数据.</p><h4 id="StandardMethodCodec"><a href="#StandardMethodCodec" class="headerlink" title="StandardMethodCodec"></a>StandardMethodCodec</h4><p>StandardMethodCodec的编解码器依赖于StandardMessageCodec,它也是MethodCodec的默认实现.当其编码在将MethodCall对象进行编码时,会将MethoCall对象的method和args依次使用StandardMessageCodec进行编码,然后写成二进制数据.</p><h3 id="深入编解码器原理"><a href="#深入编解码器原理" class="headerlink" title="深入编解码器原理"></a>深入编解码器原理</h3><p>在学习编写Platform Channel过程中,Flutter官方介绍了如何借助MethodChannel编写获取Android/IOS平台上的<a href="https://flutterchina.club/platform-channels/" target="_blank" rel="noopener">电量插件</a>.在Android平台中电量返回值是java.lang.Integer类型,而IOS平台中电量返回值是NSNumber类型,而在Dart中,该返回值类型是dart语言中的int类型.下面以Android平台为例,通过分析StandardMethodCodec实现来了解其原理.</p><p>上面我们已经说过StandardMethodCodec中使用标准的二进制消息编码器StandardMessageCodec,首先来看一下StandardMethodCodec的定义:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardMethodCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodCodec</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> StandardMethodCodec INSTANCE = <span class="hljs-keyword">new</span> StandardMethodCodec(StandardMessageCodec.INSTANCE);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StandardMessageCodec messageCodec;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StandardMethodCodec</span><span class="hljs-params">(StandardMessageCodec messageCodec)</span> </span>&#123;      <span class="hljs-keyword">this</span>.messageCodec = messageCodec;    &#125;        .......    &#125;</code></pre><p>现在重点分析StandardMessageCodec:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardMessageCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageCodec</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> StandardMessageCodec INSTANCE = <span class="hljs-keyword">new</span> StandardMessageCodec();        <span class="hljs-comment">// 字节序判断,LITTLE_ENDIAN为true表示是小端模式,否则为大端模式.在对字节流写入和读取时,</span>    <span class="hljs-comment">// 需要根据字节序来决定读取和写入的顺序</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> LITTLE_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset UTF8 = Charset.forName(<span class="hljs-string">"UTF8"</span>);    <span class="hljs-comment">// 下面14个常量值用来标志不同类型的数据,比如0表示NULL,3表示int类型.在向字节流写入指定类型</span>    <span class="hljs-comment">// 的数据时,需要首先写入类型标志,然后紧跟着写入具体的值;在从字节流读取数据时,首先读取类型标</span>    <span class="hljs-comment">// 志,然后读取具体的数值.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> NULL = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> TRUE = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FALSE = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> INT = <span class="hljs-number">3</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> LONG = <span class="hljs-number">4</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> BIGINT = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> DOUBLE = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> STRING = <span class="hljs-number">7</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> BYTE_ARRAY = <span class="hljs-number">8</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> INT_ARRAY = <span class="hljs-number">9</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> LONG_ARRAY = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> DOUBLE_ARRAY = <span class="hljs-number">11</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> LIST = <span class="hljs-number">12</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAP = <span class="hljs-number">13</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">encodeMessage</span><span class="hljs-params">(Object message)</span> </span>&#123;        <span class="hljs-keyword">if</span> (message == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">final</span> ExposedByteArrayOutputStream stream = <span class="hljs-keyword">new</span> ExposedByteArrayOutputStream();        <span class="hljs-comment">// 将message写入二进制字节流中</span>        writeValue(stream, message);        <span class="hljs-keyword">final</span> ByteBuffer buffer = ByteBuffer.allocateDirect(stream.size());        buffer.put(stream.buffer(), <span class="hljs-number">0</span>, stream.size());        <span class="hljs-keyword">return</span> buffer;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decodeMessage</span><span class="hljs-params">(ByteBuffer message)</span> </span>&#123;        <span class="hljs-keyword">if</span> (message == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        message.order(ByteOrder.nativeOrder());        <span class="hljs-comment">// 从二进制字节流message中读取数据</span>        <span class="hljs-keyword">final</span> Object value = readValue(message);        <span class="hljs-keyword">if</span> (message.hasRemaining()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Message corrupted"</span>);        &#125;        <span class="hljs-keyword">return</span> value;    &#125;        <span class="hljs-comment">// 根据数据类型,先向stream中写入类型标志值,及上述提到的14个常量值,然后将具体的</span>    <span class="hljs-comment">// value值转成byte继续写入到stream</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeValue</span><span class="hljs-params">(ByteArrayOutputStream stream, Object value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;            stream.write(NULL);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value == Boolean.TRUE) &#123;            stream.write(TRUE);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value == Boolean.FALSE) &#123;            stream.write(FALSE);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Number) &#123;            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Integer || value <span class="hljs-keyword">instanceof</span> Short || value <span class="hljs-keyword">instanceof</span> Byte) &#123;         <span class="hljs-comment">// 1.写入类型标志值</span>                stream.write(INT);                <span class="hljs-comment">// value转为byte,继续写入到stream中</span>                writeInt(stream, ((Number) value).intValue());            &#125;            .......        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;            stream.write(STRING);            writeBytes(stream, ((String) value).getBytes(UTF8));        &#125;        .......    &#125;        <span class="hljs-comment">// 根据字节序决定写入顺序</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeInt</span><span class="hljs-params">(ByteArrayOutputStream stream, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (LITTLE_ENDIAN) &#123;            stream.write(value);            stream.write(value &gt;&gt;&gt; <span class="hljs-number">8</span>);            stream.write(value &gt;&gt;&gt; <span class="hljs-number">16</span>);            stream.write(value &gt;&gt;&gt; <span class="hljs-number">24</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            stream.write(value &gt;&gt;&gt; <span class="hljs-number">24</span>);            stream.write(value &gt;&gt;&gt; <span class="hljs-number">16</span>);            stream.write(value &gt;&gt;&gt; <span class="hljs-number">8</span>);            stream.write(value);        &#125;    &#125;        <span class="hljs-comment">// writeValue()方法反向过程,原理一致</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">readValue</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;        .......    &#125;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExposedByteArrayOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteArrayOutputStream</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer() &#123;            <span class="hljs-keyword">return</span> buf;        &#125;    &#125;&#125;</code></pre><p>在StandardMessageCodec中最重要的两个方法是<code>writeValue()</code>和<code>readValue()</code>.前者用于将value值写入到字节输出流ByteArrayOutputStream中,后者从字节缓冲数组中读取.在Android返回电量的过程中,假设电量值为100,该值转换成二进制数据流程为:首先向字节流stream中写入表示int类型的标志值3,再将100转为4个byte,继续写入到字节流stream中.当Dart中接受到该二进制数据后,先读取第一个byte值,根据此值得知后面需要读取一个int类型的数据,随后读取后面4个byte,并将其转为dart类型中int类型.</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g00epfqv0vj31zk0pyae9.jpg" srcset="/img/loading.gif" alt="image-20190209194123776"></p><h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>Flutter中定义了一套Handler用于处理经过Codec解码后消息.在使用Platform Channel时,需要为其设置对应的Handler,实际上就是为其注册一个对应BinaryMessageHandler,二进制数据会被BinaryMessageHanler进行处理,首先使用Codec进行解码操作,然后再分发给具体Handler进行处理.与三种Platform Channel相对应,Flutter中也定义了三种Handler:</p><ul><li>MessageHandler: 用于处理字符串或者半结构化消息,定义在BasicMessageChannel中.</li><li>MethodCallHandler: 用于处理方法调用,定义在MethodChannel中.</li><li>StreamHandler: 用于事件流通信,定义在EventChannel中.</li></ul><h2 id="MessageHandler"><a href="#MessageHandler" class="headerlink" title="MessageHandler"></a>MessageHandler</h2><p>用于处理字符串或者半结构化的消息,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicMessageChannel</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    ......            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageHandler</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(T message, Reply&lt;T&gt; reply)</span></span>;    &#125;        ......&#125;</code></pre><p><code>onMessage()</code>用于处理来自Flutter中的消息,该接受两个参数:T类型的消息以及用于异步返回T类型的result</p><h2 id="MethodCallHandler"><a href="#MethodCallHandler" class="headerlink" title="MethodCallHandler"></a>MethodCallHandler</h2><p> MethodCallHandler用于处理方法的调用,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    ......            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodCallHandler</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(MethodCall call, Result result)</span></span>;    &#125;        ......&#125;</code></pre><p><code>onMessage()</code>用于处理来自Flutter中消息,该方法接受两个参数:用于方法调用MethodCall对象以及用于方法返回Result类型的对象.</p><h2 id="StreamHandler"><a href="#StreamHandler" class="headerlink" title="StreamHandler"></a>StreamHandler</h2><p> StreamHandler用于事件流的通信,通常是用于平台主动向Flutter发送事件通知,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventChannel</span> </span>&#123;    ......            <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StreamHandler</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onListen</span><span class="hljs-params">(Object arguments, EventSink events)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCancel</span><span class="hljs-params">(Object arguments)</span></span>;    &#125;        ......&#125;</code></pre><p>在StreamHandler存在两个方法:<code>onListen()</code>和<code>onCancel()</code>.当Flutter端开始监听平台事件时,会向平台发起一次MethodCall,其中方法名为listen,也就是最终会调用StreamHandler中的<code>onListen()</code>方法.该方法中接受两个参数,其中EventSink类型的参数可用于向Flutter发送事件(实际上还是通过BinaryMessager).当Flutter开始停止监听平台事件时,会再向平台发起一次MethodCall,其中方法名为cancel,最终会调用StreamHandler的<code>onCancel()</code>方法,在该方法中通常需要销毁一些无用的资源.关于StreamHandler原理,会另开一文.</p><h1 id="MethodChannel调用原理"><a href="#MethodChannel调用原理" class="headerlink" title="MethodChannel调用原理"></a>MethodChannel调用原理</h1><p>MethodChannel用于实现Flutter和Android/IOS平台间的方法调用.下文将以从Flutter调用Android平台代码为主线进行分析,主要涉及方法调用及方法调用结果返回两个过程.</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><h3 id="Dart-gt-Native"><a href="#Dart-gt-Native" class="headerlink" title="Dart -&gt; Native"></a>Dart -&gt; Native</h3><p>MethodChannel定义如下:</p><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;  <span class="hljs-comment">// 构造方法,通常我们只需要指定该channel的name,  </span>  <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-keyword">this</span>.name, [<span class="hljs-keyword">this</span>.codec = <span class="hljs-keyword">const</span> StandardMethodCodec()]);  <span class="hljs-comment">// name作为通道的唯一标志付,用于区分不同的通道调用</span>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;  <span class="hljs-comment">// 用于方法调用过程的编码 </span>  <span class="hljs-keyword">final</span> MethodCodec codec;    <span class="hljs-comment">// 用于发起异步平台方法调用,需要指定方法名,以及可选方法参数  </span>  Future&lt;<span class="hljs-built_in">dynamic</span>&gt; invokeMethod(<span class="hljs-built_in">String</span> method, [<span class="hljs-built_in">dynamic</span> arguments]) <span class="hljs-keyword">async</span> &#123;    <span class="hljs-keyword">assert</span>(method != <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 将一次方法调用中需要的方法名和方法参数封装为MethodCall对象,然后使用MethodCodec对该</span>    <span class="hljs-comment">//  对象进行进行编码操作,最后通过BinaryMessages中的send方法发起调用 </span>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">dynamic</span> result = <span class="hljs-keyword">await</span> BinaryMessages.send(      name,      codec.encodeMethodCall(MethodCall(method, arguments)),    );    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">throw</span> MissingPluginException(<span class="hljs-string">'No implementation found for method <span class="hljs-subst">$method</span> on channel <span class="hljs-subst">$name</span>'</span>);    <span class="hljs-keyword">return</span> codec.decodeEnvelope(result);  &#125;&#125;</code></pre><p>在使用MethodChannel时,需要我们根据Channel名称来创建MethodChannel对象.Channel名称作为MethodChannel的唯一标识符,用于区分不同的MethodChannel对象.创建MethodChannel对象的一般方式如下:</p><pre><code class="hljs dart"><span class="hljs-keyword">final</span> MethodChannel _channel = <span class="hljs-keyword">new</span> MethodChannel(<span class="hljs-string">'flutter.io/player'</span>)</code></pre><p>拿到MethodChannel对象后,通过调用其<code>invokeMethod()</code>方法用于向平台发起一次调用.在<code>invokeMethod()</code>方法中会将一次方法调中的方法名method和方法参数arguments封装为MethodCall对象,然后使用MethodCodec对其进行二进制编码,最后通过BinaryMessages的send()发起平台方法调用请求.</p><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryMessages</span> </span>&#123;   ......    <span class="hljs-keyword">static</span> Future&lt;ByteData&gt; send(<span class="hljs-built_in">String</span> channel, ByteData message) &#123;    <span class="hljs-keyword">final</span> _MessageHandler handler = _mockHandlers[channel];    <span class="hljs-comment">// 在没有设置Mock Handler的情况下,继续调用_sendPlatformMessage()   </span>    <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">return</span> handler(message);    <span class="hljs-keyword">return</span> _sendPlatformMessage(channel, message);  &#125;     <span class="hljs-keyword">static</span> Future&lt;ByteData&gt; _sendPlatformMessage(<span class="hljs-built_in">String</span> channel, ByteData message) &#123;    <span class="hljs-keyword">final</span> Completer&lt;ByteData&gt; completer = Completer&lt;ByteData&gt;();       ui.<span class="hljs-built_in">window</span>.sendPlatformMessage(channel, message, (ByteData reply) &#123;      <span class="hljs-keyword">try</span> &#123;        completer.complete(reply);      &#125; <span class="hljs-keyword">catch</span> (exception, stack) &#123;        FlutterError.reportError(FlutterErrorDetails(          exception: exception,          stack: stack,          <span class="hljs-keyword">library</span>: <span class="hljs-string">'services library'</span>,          context: <span class="hljs-string">'during a platform message response callback'</span>,        ));      &#125;    &#125;);    <span class="hljs-keyword">return</span> completer.future;  &#125;    ......  &#125;</code></pre><p>BinaryMessages类中提供了用于发送和接受平台插件的二进制消息.</p><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span></span>&#123;    ......    <span class="hljs-keyword">void</span> sendPlatformMessage(<span class="hljs-built_in">String</span> name,                           ByteData data,                           PlatformMessageResponseCallback callback) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> error =        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);    <span class="hljs-keyword">if</span> (error != <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(error);  &#125;  <span class="hljs-comment">// 和Java类似,Dart中同样提供了Native方法用于调用底层C++/C代码的能力  </span>  <span class="hljs-built_in">String</span> _sendPlatformMessage(<span class="hljs-built_in">String</span> name,                              PlatformMessageResponseCallback callback,                              ByteData data) native <span class="hljs-string">'Window_sendPlatformMessage'</span>;   ....... &#125;</code></pre><p> 上述过程最终会调用到ui.Window的<code>_sendPlatformMessage()</code>方法,该方法是一个native方法,这与Java中JNI技术非常类似.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g000dx3s0fj31rl0u078i.jpg" srcset="/img/loading.gif" alt="image-20190209112548889"></p><p>在调用该Native方法中,我们向native层发送了三个参数：</p><ul><li>name: String类型,代表Channel名称</li><li>data: ByteData类型,代表之前封装的二进制数据</li><li>callback: Function类型,用于结果回调</li></ul><p><code>_sendPlatformMessage()</code>具体实现在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8/-/blob/lib/ui/window/window.cc?utm_source=share#L336:14" target="_blank" rel="noopener">Window.cc</a>中:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Window::RegisterNatives</span><span class="hljs-params">(tonic::DartLibraryNatives* natives)</span> </span>&#123;  natives-&gt;Register(&#123;      &#123;<span class="hljs-string">"Window_defaultRouteName"</span>, DefaultRouteName, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_scheduleFrame"</span>, ScheduleFrame, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_sendPlatformMessage"</span>, _SendPlatformMessage, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_respondToPlatformMessage"</span>, _RespondToPlatformMessage, <span class="hljs-number">3</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_render"</span>, Render, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_updateSemantics"</span>, UpdateSemantics, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_setIsolateDebugName"</span>, SetIsolateDebugName, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>&#125;,      &#123;<span class="hljs-string">"Window_reportUnhandledException"</span>, ReportUnhandledException, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>&#125;,  &#125;);&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _SendPlatformMessage(Dart_NativeArguments args) &#123;  <span class="hljs-comment">// 最终调用SendPlatformMessage函数  </span>  tonic::DartCallStatic(&amp;SendPlatformMessage, args);&#125;</code></pre><p><a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/lib/ui/window/window.cc?utm_source=share#L84:13" target="_blank" rel="noopener">SendPlatformMessage()</a>函数定义如下:</p><pre><code class="hljs c++"><span class="hljs-function">Dart_Handle <span class="hljs-title">SendPlatformMessage</span><span class="hljs-params">(Dart_Handle window,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name,</span></span><span class="hljs-function"><span class="hljs-params">                                Dart_Handle callback,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">const</span> tonic::DartByteData&amp; data)</span> </span>&#123;  UIDartState* dart_state = UIDartState::Current();  <span class="hljs-comment">// 1.只能在main iolate调用平台方法</span>  <span class="hljs-keyword">if</span> (!dart_state-&gt;window()) &#123;    <span class="hljs-comment">// Must release the TypedData buffer before allocating other Dart objects.</span>    data.Release();    <span class="hljs-keyword">return</span> tonic::ToDart(        <span class="hljs-string">"Platform messages can only be sent from the main isolate"</span>);  &#125;  <span class="hljs-comment">// 此处response的作用?</span>  fml::RefPtr&lt;PlatformMessageResponse&gt; response;  <span class="hljs-keyword">if</span> (!Dart_IsNull(callback)) &#123;    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(        tonic::DartPersistentValue(dart_state, callback),        dart_state-&gt;GetTaskRunners().GetUITaskRunner());  &#125;  <span class="hljs-comment">// 2.核心方法调用 </span>  <span class="hljs-keyword">if</span> (Dart_IsNull(data.dart_handle())) &#123;    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*&gt;(data.data());    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(        fml::MakeRefCounted&lt;PlatformMessage&gt;(            name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint8_t</span>&gt;(<span class="hljs-built_in">buffer</span>, <span class="hljs-built_in">buffer</span> + data.length_in_bytes()),            response));  &#125;  <span class="hljs-keyword">return</span> Dart_Null();&#125;</code></pre><p>在上方代码中首先判断是否在main isolate中进行平台方法调用,如果不是返回错误信息;接下来就是执行关键的方法:<code>dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage()</code>.其中<code>HandlePlatformMessage()</code>是<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/lib/ui/window/window.h?utm_source=share#L39:7" target="_blank" rel="noopener">WindowClient</a>中虚方法:</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClient</span> &#123;</span> <span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">DefaultRouteName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ScheduleFrame</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span><span class="hljs-params">(Scene* scene)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateSemantics</span><span class="hljs-params">(SemanticsUpdate* update)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandlePlatformMessage</span><span class="hljs-params">(fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> FontCollection&amp; <span class="hljs-title">GetFontCollection</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateIsolateDescription</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> isolate_name,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">int64_t</span> isolate_port)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-keyword">protected</span>:  <span class="hljs-keyword">virtual</span> ~WindowClient();&#125;;</code></pre><p>而<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/runtime/runtime_controller.cc?utm_source=share#L272:6" target="_blank" rel="noopener">RuntimeController</a>是WindowClient中的唯一继承类,其头文件<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/runtime/runtime_controller.h?utm_source=share#L137:33" target="_blank" rel="noopener">runtime_controller.h</a>,为了方便起见,我们只看其部分定义:</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeController</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> WindowClient &#123;    ......            <span class="hljs-keyword">private</span>:      RuntimeDelegate&amp; client_;          .......      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HandlePlatformMessage</span><span class="hljs-params">(fml::RefPtr&lt;PlatformMessage&gt; message)</span> <span class="hljs-keyword">override</span></span>;      ......&#125;</code></pre><p>知道其定义之后,现在就可以看起具体在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/runtime/runtime_controller.cc?utm_source=share#L272:25" target="_blank" rel="noopener">runtime_controller.cc</a>的实现了:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RuntimeController::HandlePlatformMessage</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    fml::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;  client_.HandlePlatformMessage(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message));&#125;</code></pre><p>在运行过程中,不同的平台有运行机制不同,需要不同的处理策略,因此RuntimeController中相关的方法实现都被委托到了不同的平台实现类RuntimeDelegate中,即上述代码中<code>client_</code>.</p><p>RuntimeDelegate的实现为Engine,其头文件<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/common/engine.h?utm_source=share" target="_blank" rel="noopener">Engine.h</a>定义如下:</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> <span class="hljs-title">final</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">blink</span>::RuntimeDelegate &#123;    ........&#125;</code></pre><p>对应真实的实现在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/common/engine.cc?utm_source=share#L414:14" target="_blank" rel="noopener">Engine.cc</a>中,直接来看其<code>HandlePlatformMessage()</code>的实现</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Engine::HandlePlatformMessage</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    fml::RefPtr&lt;<span class="hljs-built_in">blink</span>::PlatformMessage&gt; message)</span> </span>&#123;  <span class="hljs-comment">// kAssetChannel值为flutter/assets  </span>  <span class="hljs-keyword">if</span> (message-&gt;channel() == kAssetChannel) &#123;    HandleAssetPlatformMessage(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message));  &#125; <span class="hljs-keyword">else</span> &#123;    delegate_.OnEngineHandlePlatformMessage(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message));  &#125;&#125;</code></pre><p>在上述代码过程中,Engine在处理message时,如果该message值等于kAssetChannel,即flutter/assets,表示当前操作想要获取资源,因此会调用<code>HandleAssetPlatformMessage()</code>来走获取资源的逻辑;否则调用<code>delegate_.OnEngineHandlePlatformMessage()</code>方法.这里delegate的具体实现为<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/common/shell.cc?utm_source=share#L723" target="_blank" rel="noopener">Shell</a>:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shell::OnEngineHandlePlatformMessage</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    fml::RefPtr&lt;<span class="hljs-built_in">blink</span>::PlatformMessage&gt; message)</span> </span>&#123;  FML_DCHECK(is_setup_);  FML_DCHECK(task_runners_.GetUITaskRunner()-&gt;RunsTasksOnCurrentThread());  <span class="hljs-comment">// kSkiaChannel值为flutter/skia  </span>  <span class="hljs-keyword">if</span> (message-&gt;channel() == kSkiaChannel) &#123;    HandleEngineSkiaMessage(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message));    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// 其他情况下,向PlatformTaskRunner中添加Task</span>  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(      [view = platform_view_-&gt;GetWeakPtr(), message = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message)]() &#123;        <span class="hljs-keyword">if</span> (view) &#123;          view-&gt;HandlePlatformMessage(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(message));        &#125;      &#125;);&#125;</code></pre><p><code>OnEngineHandlePlatformMessage</code>在接收到消息后,首先判断要调用Channel是否是flutter/skia,如果是则调用<code>HandleEngineSkiaMessage()</code>进行处理后返回,否则向PlatformTaskRunner添加一个Task,在该Task中会调用PlatformView的<code>HandlePlatformMessage()</code>方法.根据运行平台不同PlatformView有不同的实现,对于Android平台而言,其具体实现是PlatformViewAndroid;对于IOS平台而言,其实现是PlatformViewIOS.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzyuucjellj31020jogmp.jpg" srcset="/img/loading.gif" alt="image-20190208112830510"></p><blockquote><p> Task中的代码执行在Platform Task Runner中,而之前的代码运行在UI Task Runner中</p></blockquote><p>以PlatformViewAndroid为例,来了解<code>HandlePlatformMessage()</code><a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8/-/blob/shell/platform/android/platform_view_android.cc?utm_source=share#L142:27" target="_blank" rel="noopener">方法的实现</a>:</p><pre><code class="hljs c++"><span class="hljs-comment">// |shell::PlatformView|</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PlatformViewAndroid::HandlePlatformMessage</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    fml::RefPtr&lt;<span class="hljs-built_in">blink</span>::PlatformMessage&gt; message)</span> </span>&#123;  JNIEnv* env = fml::jni::AttachCurrentThread();  fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.<span class="hljs-built_in">get</span>(env);  <span class="hljs-keyword">if</span> (view.is_null())    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// response_id在Flutter调用平台代码时,会传到平台代码中,后续平台代码需要回传数据时</span>  <span class="hljs-comment">// 需要用到它</span>  <span class="hljs-keyword">int</span> response_id = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果message中有response(response类型为PlatformMessageResponseDart),则需要对</span>  <span class="hljs-comment">// response_id进行自增  </span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> response = message-&gt;response()) &#123;    response_id = next_response_id_++;    <span class="hljs-comment">// pending_responses是一个Map结构  </span>    pending_responses_[response_id] = response;  &#125;  <span class="hljs-keyword">auto</span> java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());  <span class="hljs-keyword">if</span> (message-&gt;hasData()) &#123;     fml::<span class="hljs-function">jni::ScopedJavaLocalRef&lt;jbyteArray&gt; <span class="hljs-title">message_array</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        env, env-&gt;NewByteArray(message-&gt;data().<span class="hljs-built_in">size</span>()))</span></span>;    env-&gt;SetByteArrayRegion(        message_array.obj(), <span class="hljs-number">0</span>, message-&gt;data().<span class="hljs-built_in">size</span>(),        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> jbyte*&gt;(message-&gt;data().data()));    message = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// This call can re-enter in InvokePlatformMessageXxxResponseCallback.</span>    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),                                     message_array.obj(), response_id);  &#125; <span class="hljs-keyword">else</span> &#123;      message = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// This call can re-enter in InvokePlatformMessageXxxResponseCallback.</span>    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),                                     <span class="hljs-literal">nullptr</span>, response_id);  &#125;&#125;</code></pre><p>在上述代码中,当该方法接受PlatformMessage类型的消息时,如果消息中有response,则对response_id自增,并以response_ide为key,response为value存放在变量<code>pending_responses_</code>中(pending_responsed是一个Map结构).</p><blockquote><p>正常情况下,每次从Flutter调用Channel代码,都会生成对应的response_id和response.同时该response_id会被传到平台代码中,当平台代码需要为此次调用返回数据时,需要同时回传该response_id.</p></blockquote><p>接着将消息中的channel和data数据转成Java可识别的数据,并连同response_id一同作为<code>FlutterViewHandlePlatformMessage()</code>方法的参数,最终通过JNI调用的方式传递到Java层.</p><p>简单的分析下该过程,首先来看<code>FlutterViewHandlePlatformMessage()</code>在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/platform_view_android_jni.cc?utm_source=share#L70:6" target="_blank" rel="noopener">platform_android_jni.cc</a>中的实现:</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> jmethodID g_handle_platform_message_method = <span class="hljs-literal">nullptr</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FlutterViewHandlePlatformMessage</span><span class="hljs-params">(JNIEnv* env,</span></span><span class="hljs-function"><span class="hljs-params">                                      jobject obj,</span></span><span class="hljs-function"><span class="hljs-params">                                      jstring channel,</span></span><span class="hljs-function"><span class="hljs-params">                                      jobject message,</span></span><span class="hljs-function"><span class="hljs-params">                                      jint responseId)</span> </span>&#123;  env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,                      responseId);  FML_CHECK(CheckException(env));&#125;</code></pre><p>在上述方法中,最终将调用g_handle_platform_message_method中指向Java层的方法.其中g_handle_platform_message_method在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/platform_view_android_jni.cc?utm_source=share#L541:6" target="_blank" rel="noopener">RegisterApi</a>中被初始化:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PlatformViewAndroid::Register</span><span class="hljs-params">(JNIEnv* env)</span> </span>&#123;  ......    g_flutter_jni_class = <span class="hljs-keyword">new</span> fml::jni::ScopedJavaGlobalRef&lt;jclass&gt;(      env, env-&gt;FindClass(<span class="hljs-string">"io/flutter/embedding/engine/FlutterJNI"</span>));      ......        <span class="hljs-keyword">return</span> RegisterApi(env);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RegisterApi</span><span class="hljs-params">(JNIEnv* env)</span> </span>&#123;  ......    g_handle_platform_message_method =      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="hljs-string">"handlePlatformMessage"</span>,                       <span class="hljs-string">"(Ljava/lang/String;[BI)V"</span>);  ......  &#125;</code></pre><p>不难看出g_flutter_jni_class指向FlutterJNI.java类,g_handle_platform_message_method指向FlutterJN.javaI中的<code>handlePlatformMessage()</code>方法.</p><p>现在我们知道从Flutter发一次Channel调用,需要经过<code>Dart -&gt; Native -&gt; JNI -&gt; Java</code>几个层次,并把三个参数channel,message,responseId传给Java层.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g000p630c4j31xj0u0wn3.jpg" srcset="/img/loading.gif" alt="image-20190209113644507"></p><h3 id="Native-gt-Java"><a href="#Native-gt-Java" class="headerlink" title="Native -&gt; Java"></a>Native -&gt; Java</h3><p>通过上述分析,我们知道<code>FlutterViewHandlePlatformMessage()</code>实际上是通过JNI的方式最终调用了FlutterJNI.java中的<code>handlePlatformMessage()</code>方法,该方法接受三个来自Native层的参数:</p><ul><li>channel: String类型,表示Channel名称.</li><li>message: 字节数组,表示方法调用中的数据,如方法名和参数.</li><li>replyId: int类型,在将此次调用的响应数据从Java层写回到Native层时用到</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterJNI</span> </span>&#123;  <span class="hljs-keyword">private</span> PlatformMessageHandler platformMessageHandler;          <span class="hljs-meta">@UiThread</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPlatformMessageHandler</span><span class="hljs-params">(@Nullable PlatformMessageHandler platformMessageHandler)</span> </span>&#123;    <span class="hljs-keyword">this</span>.platformMessageHandler = platformMessageHandler;  &#125;          <span class="hljs-comment">// Called by native.</span>  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlePlatformMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String channel, <span class="hljs-keyword">byte</span>[] message, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> replyId)</span> </span>&#123;    <span class="hljs-keyword">if</span> (platformMessageHandler != <span class="hljs-keyword">null</span>) &#123;      platformMessageHandler.handleMessageFromDart(channel, message, replyId);    &#125;  &#125;&#125;</code></pre><p>FlutterJNI类定义了Java层和Flutter C/C++引擎之间的相关接口.此类目前处于实验性质,随着后续的发展可能会被不断的重构和优化,不保证一直存在,不建议开发者调用该类.</p><p>为了建立Android应用和Flutter C/C++引擎的连接,需要创建FlutterJNI实例,然后将其attach到Native,常见的使用方法如下:</p><pre><code class="hljs java"><span class="hljs-comment">// 1.创建FlutterJNI实例</span>FlutterJNI flutterJNI = <span class="hljs-keyword">new</span> FlutterJNI();<span class="hljs-comment">// 2.建立和Native层的连接</span>flutterJNI.attachToNative();......    <span class="hljs-comment">// 3.断开和Native层的连接,并释放资源</span>flutterJNI.detachFromNativeAndReleaseResources();</code></pre><p>重新回到FlutterJNI中<code>handlePlatformMessage()</code>,在该方法中首先判断platformMessageHandler是否为null,不为null,则调用其<code>handleMessageFromDart()</code>方法.其中platformMessageHandler需要通过FlutterJNI中的<code>setPlatformMessageHandler()</code>方法来设置.那该方法被调用的时机是在什么时候呢?直接来看FlutterNativeView的<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/io/flutter/view/FlutterNativeView.java?utm_source=share#L39:12" target="_blank" rel="noopener">构造函数</a>:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterNativeView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessenger</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BinaryMessageHandler&gt; mMessageHandlers;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mNextReplyId = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, BinaryReply&gt; mPendingReplies = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FlutterPluginRegistry mPluginRegistry;    <span class="hljs-keyword">private</span> FlutterView mFlutterView;    <span class="hljs-keyword">private</span> FlutterJNI mFlutterJNI;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context mContext;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> applicationIsRunning;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlutterNativeView</span><span class="hljs-params">(Context context, <span class="hljs-keyword">boolean</span> isBackgroundView)</span> </span>&#123;        mContext = context;        mPluginRegistry = <span class="hljs-keyword">new</span> FlutterPluginRegistry(<span class="hljs-keyword">this</span>, context);        <span class="hljs-comment">// 创建FlutterJNI实例</span>        mFlutterJNI = <span class="hljs-keyword">new</span> FlutterJNI();        mFlutterJNI.setRenderSurface(<span class="hljs-keyword">new</span> RenderSurfaceImpl());        <span class="hljs-comment">// 将PlatformMessageHandlerImpl实例赋值给FlutterJNI中的platformMessageHandler属性</span>        mFlutterJNI.setPlatformMessageHandler(<span class="hljs-keyword">new</span> PlatformMessageHandlerImpl());        mFlutterJNI.addEngineLifecycleListener(<span class="hljs-keyword">new</span> EngineLifecycleListenerImpl());        attach(<span class="hljs-keyword">this</span>, isBackgroundView);        assertAttached();        mMessageHandlers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    &#125;        .......&#125;</code></pre><p>在FlutterNativeView的构造函数中,首先创建FlutterJNI实例mFlutterJNI,然后调用<code>setPlatformMessageHandler()</code>并把PlatformMessageHandlerImpl实例作为参数传入.因此在FlutterJNI的<code>handlePlatformMessage()</code>方法中,最终调用PlatformMessageHandlerImpl实例的<code>handleMessageFromDart()</code>来处理来自Flutter中的消息:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterNativeView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessenger</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BinaryMessageHandler&gt; mMessageHandlers;        ......                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlatformMessageHandlerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PlatformMessageHandler</span> </span>&#123;        <span class="hljs-comment">// Called by native to send us a platform message.</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessageFromDart</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String channel, <span class="hljs-keyword">byte</span>[] message, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> replyId)</span> </span>&#123;<span class="hljs-comment">// 1.根据channel名称获取对应的BinaryMessageHandler对象.每个Channel对应一个</span>            <span class="hljs-comment">// Handler对象</span>            BinaryMessageHandler handler = mMessageHandlers.get(channel);            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 2.将字节数组对象封装为ByteBuffer对象</span>                    <span class="hljs-keyword">final</span> ByteBuffer buffer = (message == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : ByteBuffer.wrap(message));                    <span class="hljs-comment">// 3.调用handler对象的onMessage()方法来分发消息</span>                    handler.onMessage(buffer, <span class="hljs-keyword">new</span> BinaryReply() &#123;                        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean done = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reply</span><span class="hljs-params">(ByteBuffer reply)</span> </span>&#123;                            <span class="hljs-comment">// 4.根据reply的情况,调用FlutterJNI中invokePlatformMessageXXX()方法将响应数据发送给Flutter层</span>                            <span class="hljs-keyword">if</span> (reply == <span class="hljs-keyword">null</span>) &#123;                                mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);                            &#125; <span class="hljs-keyword">else</span> &#123;                                mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());                            &#125;                        &#125;                    &#125;);                &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;                    mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);                &#125;                <span class="hljs-keyword">return</span>;            &#125;            mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);        &#125;&#125;</code></pre><p>在FlutterNativeView中存在Map类型的成员变量<span id="BinaryMessenger">mMessageHandler</span>:以Channel名称作为key,以BinaryMessageHandler类型为value.在<code>handleMessageFromDart()</code>方法中,首先根据Channel名称从mMessageHandlers取出对应的二进制消息处理器BinaryMessageHandler,然后将字节数组message封装为ByteBuffer对象,然后调用BinaryMessageHandler实例的<code>onMessage()</code>方法处理ByteBuffer,并进行响应.</p><p>BinaryReply是一个接口,主要用来将ByteBuffer类型的响应数据reply从Java层写回到Flutter层.根据reply是否为null,调用FlutterJNI实例不同的方法:reply为null时,调用<code>invokePlatformMessageEmptyResponseCallback()</code>;否则调用<code>invokePlatformMessageResponseCallback()</code>.关于具体的实现流程,稍后再述.</p><p>现在来看下BinaryMessageHandler是如何添加到mMessageHandler中:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterNativeView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessenger</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BinaryMessageHandler&gt; mMessageHandlers;        ......            <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessageHandler</span><span class="hljs-params">(String channel, BinaryMessageHandler handler)</span> </span>&#123;        <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;            mMessageHandlers.remove(channel);        &#125; <span class="hljs-keyword">else</span> &#123;            mMessageHandlers.put(channel, handler);        &#125;    &#125;    .......&#125;</code></pre><p><code>setMessageHandler()</code>方法接受两个参数:channel作为Channel的名称,用来区分不同的Channel;handler是该Channel对应的二进制消息处理器.在该方法中,会根据handler是否为null来决定对mMessageHandlers是进行添加还是删除操作.那该方法什么时候回被调用呢?要想弄明白这个问题,需要了解编写平台Channel的过程.以官方获取Android平台电量的平台Channel为例:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlutterActivity</span> </span>&#123;    <span class="hljs-comment">// 1.定义Channel的名称,该名称作为Channel的唯一标识符</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CHANNEL = <span class="hljs-string">"samples.flutter.io/battery"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<span class="hljs-comment">// 2.创建MethodChannel对象channel</span>        MethodChannel channel = <span class="hljs-keyword">new</span> MethodChannel(getFlutterView(), CHANNEL);        <span class="hljs-comment">// 3.调用MethodChannel实例的setMethodCallHandler()方法为当前channel设置Handler</span>        channel.setMethodCallHandler(                <span class="hljs-keyword">new</span> MethodCallHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(MethodCall call, Result result)</span> </span>&#123;                        <span class="hljs-comment">// TODO</span>                    &#125;                &#125;);    &#125;&#125;</code></pre><p>在上述代码中,演示了编写平台代码的基本过程:首先创建MethodChanel实例,然后设置MethodCallHandler.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    <span class="hljs-comment">// 二进制信使</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BinaryMessenger messenger;    <span class="hljs-comment">// Channel名称</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">// 方法编码</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodCodec codec;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodChannel</span><span class="hljs-params">(BinaryMessenger messenger, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>(messenger, name, StandardMethodCodec.INSTANCE);    &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodChannel</span><span class="hljs-params">(BinaryMessenger messenger, String name, MethodCodec codec)</span> </span>&#123;        <span class="hljs-keyword">assert</span> messenger != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">assert</span> name != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">assert</span> codec != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.messenger = messenger;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.codec = codec;    &#125;            ......            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMethodCallHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> @Nullable MethodCallHandler handler)</span> </span>&#123;        messenger.setMessageHandler(name,            handler == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> IncomingMethodCallHandler(handler));    &#125;    ......&#125;</code></pre><p>在创建MethodChannel过程中需要指定三个参数:</p><ul><li>name: Channel名称,用作唯一标识符.</li><li>codec: 用于方法编码的MethodCodec,.默认情况下,codec被指定为StandartMethodCodec.INSTANCE.</li><li>messager: 用于消息发送的BinaryMessager,</li></ul><p>创建完MethodChannel后,接下来需要调用<code>setMethodCallHandler()</code>设置用于处理方法调用MethodCallHandler.在该方法参数handler不为null的情况下,会将该handler包装为IncomingMethodCallHandler实例,然后调用BinaryMessager实例的<code>setMessageHanlder()</code>方法将I该ncomingMethodCallHandler实例保存在FlutterNativeView中的mMessageHandlers中.</p><p>简单来说就是在编写平台Channel时,需要创建对应的MethodChannel实例,并调用其<code>setMethodCallHandler()</code>将MethodCallHandler实例保存起来.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncomingMethodCallHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryMessageHandler</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodCallHandler handler;        IncomingMethodCallHandler(MethodCallHandler handler) &#123;            <span class="hljs-keyword">this</span>.handler = handler;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(ByteBuffer message, <span class="hljs-keyword">final</span> BinaryReply reply)</span> </span>&#123;            <span class="hljs-comment">// 1.使用codec对来自Flutter方法调用数据进行解码,并将其封装为MethodCall对象.</span>            <span class="hljs-comment">// MethodCall中包含两部分数据:method表示要调用的方法;arguments表示方法所需参数</span>            <span class="hljs-keyword">final</span> MethodCall call = codec.decodeMethodCall(message);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 2.调用自定义MethodCallHandler中的onMethodCall方法继续处理方法调用</span>                handler.onMethodCall(call, <span class="hljs-keyword">new</span> Result() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">success</span><span class="hljs-params">(Object result)</span> </span>&#123;                        <span class="hljs-comment">// 调用成功时,需要回传数据给Flutter层时,使用codec对回传数据result</span>                        <span class="hljs-comment">// 进行编码</span>                        reply.reply(codec.encodeSuccessEnvelope(result));                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String errorCode, String errorMessage, Object errorDetails)</span> </span>&#123;                        <span class="hljs-comment">// 调用失败时,需要回传错误数据给Flutter层时,使用codec对errorCode,</span>                        <span class="hljs-comment">// errorMessage,errorDetails进行编码</span>                        reply.reply(codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notImplemented</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-comment">// 方法没有实现时,调用该方法后,flutter将会受到相应的错误消息</span>                        reply.reply(<span class="hljs-keyword">null</span>);                    &#125;                &#125;);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;                Log.e(TAG + name, <span class="hljs-string">"Failed to handle method call"</span>, e);                reply.reply(codec.encodeErrorEnvelope(<span class="hljs-string">"error"</span>, e.getMessage(), <span class="hljs-keyword">null</span>));            &#125;        &#125;    &#125;&#125;</code></pre><p>在上述代码中,首先使用codec对来自Flutter层的二进制数据进行解码,并将其封装为MethodCall对象,然后调用MethodCallHandler的<code>onMethodCall()</code>方法.</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g001crq3m8j31p90u0gr6.jpg" srcset="/img/loading.gif" alt="image-20190209115925942"></p><p>.MethodCall中包含两部分数据:method部分表示要调用的方法;arguments表示被调用方法所需要的参数.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    .......    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodCallHandler</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(MethodCall call, Result result)</span></span>;    &#125;    .......&#125;</code></pre><p>接下来便是调用自定义MethodCallHandler中的<code>onMethodCall()</code>方法,该方法接受两个参数:</p><ul><li><p>call: MethodCall类型,它包含方法调用所需的信息</p></li><li><p>result: Result类型,用于处理方法调用结果</p></li></ul><p>Result是一个回调接口,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodChannel</span> </span>&#123;    .......    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Result</span> </span>&#123;        <span class="hljs-comment">// 方法调用处理成功时,调用success()</span>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">success</span><span class="hljs-params">(@Nullable Object result)</span></span>;        <span class="hljs-comment">// 方法调用处理失败时,调用error()</span>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(String errorCode, @Nullable String errorMessage, @Nullable Object errorDetails)</span></span>;        <span class="hljs-comment">// 方法调用遇到为定义的方法时,调用notImplemented()</span>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notImplemented</span><span class="hljs-params">()</span></span>;    &#125;    .......&#125;</code></pre><h2 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h2><h3 id="Java-gt-Native"><a href="#Java-gt-Native" class="headerlink" title="Java -&gt; Native"></a>Java -&gt; Native</h3><p>回到IncomingMethodCallHandler中的<code>onMessage()</code>中,我们看到在调用MethodCallHandler的<code>onMethodCall()</code>时,以匿名内部的形式实现了Result接口,而且在实现中又调用reply实例的<code>reply()</code>方法来把响应数据写会到Flutter层.reply是BinaryReply接口类型,其具体实现之前已经说过(即<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/io/flutter/view/FlutterNativeView.java?utm_source=share#L182:21" target="_blank" rel="noopener">PlatformMessageHandlerImpl</a>,在此就不做重复了.</p><p>当数据需要写回时,数据首先通过codec被编码成ByteBuffer类型,然后调用reply的<code>reply()</code>方法.在<code>reply()</code>方法中,对于非null类型的ByteBuffer,会调用FlutterJNI中的<code>invokePlatformMessageResponseCallback()</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterJNI</span> </span>&#123;  <span class="hljs-keyword">private</span> Long nativePlatformViewId;      ......    <span class="hljs-meta">@UiThread</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokePlatformMessageResponseCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseId, ByteBuffer message, <span class="hljs-keyword">int</span> position)</span> </span>&#123;    <span class="hljs-comment">// 1.检查FlutterJNI是否已经attach到Native层,如若没有则抛出异常  </span>    ensureAttachedToNative();    <span class="hljs-comment">// 2.继续调用nativeInvokePlatformMessageResponseCallback()  </span>    nativeInvokePlatformMessageResponseCallback(        nativePlatformViewId,        responseId,        message,        position    );  &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeInvokePlatformMessageResponseCallback</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-keyword">long</span> nativePlatformViewId,</span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-keyword">int</span> responseId,</span></span><span class="hljs-function"><span class="hljs-params">     ByteBuffer message,</span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-keyword">int</span> position</span></span><span class="hljs-function"><span class="hljs-params">  )</span></span>;         ......          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureAttachedToNative</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// FlutterJNI attach到Native层后,会返回一个long类型的值用来初始化nativePlatformViewId  </span>    <span class="hljs-keyword">if</span> (nativePlatformViewId == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot execute operation because FlutterJNI is not attached to native."</span>);    &#125;  &#125;&#125;</code></pre><p>在上述<code>invokePlatformMessageResponseCallback()</code>方法中,首先检查当前FlutterJNI实例是否已经attach到Native层,然后调用Native方法<code>nativeInvokePlatformMessageResponseCallback()</code>向JNI层写入数据,该Native方法Native层的实现在<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/platform_view_android_jni.cc?utm_source=share#L583:20" target="_blank" rel="noopener">platform_view_android.cc</a>,其中参数responseId是之前Native层生成,又传至Java层的,现在有又需要将它传至Native层:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RegisterApi</span><span class="hljs-params">(JNIEnv* env)</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> JNINativeMethod flutter_jni_methods[] = &#123;        ......         &#123;          .name = <span class="hljs-string">"nativeInvokePlatformMessageResponseCallback"</span>,          .signature = <span class="hljs-string">"(JILjava/nio/ByteBuffer;I)V"</span>,          .fnPtr = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(&amp;shell::InvokePlatformMessageResponseCallback),         &#125;,        .......    &#125;    .......&#125;</code></pre><p>通过上述代码定义不难看出其最终<a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/shell/platform/android/platform_view_android.cc?utm_source=share#L108" target="_blank" rel="noopener">实现</a>如下:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PlatformViewAndroid::InvokePlatformMessageResponseCallback</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    JNIEnv* env,</span></span><span class="hljs-function"><span class="hljs-params">    jint response_id,</span></span><span class="hljs-function"><span class="hljs-params">    jobject java_response_data,</span></span><span class="hljs-function"><span class="hljs-params">    jint java_response_position)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!response_id)    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 1.通过response_id从pending_responses_中取出response  </span>  <span class="hljs-keyword">auto</span> it = pending_responses_.<span class="hljs-built_in">find</span>(response_id);  <span class="hljs-keyword">if</span> (it == pending_responses_.<span class="hljs-built_in">end</span>())    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 2.GetDirectBufferAddress函数返回一个指向被传入的ByteBuffer对象的地址指针  </span>  <span class="hljs-keyword">uint8_t</span>* response_data =      <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(env-&gt;GetDirectBufferAddress(java_response_data));  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint8_t</span>&gt; response = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint8_t</span>&gt;(      response_data, response_data + java_response_position);  <span class="hljs-keyword">auto</span> message_response = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(it-&gt;second);  <span class="hljs-comment">// 3.从pending_responses_中移除该response  </span>  pending_responses_.erase(it);  <span class="hljs-comment">// 4.调用response的Complete()方法将二进制结果返回</span>  message_response-&gt;Complete(      <span class="hljs-built_in">std</span>::make_unique&lt;fml::DataMapping&gt;(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(response)));&#125;</code></pre><p>在上述代码中,首先以response_id为key,从<code>pending_responsed_</code>取出对应response.然后通过GetDirectBufferAddress函数获取二进制响应数据java_response_data对象的指针,最后调用reponse的<code>Complete()</code>方法将二进制结果返回.</p><h3 id="Native-gt-Dart"><a href="#Native-gt-Dart" class="headerlink" title="Native -&gt; Dart"></a>Native -&gt; Dart</h3><p>上文提到response是PlatformMessageResponseDart类型,简单看一下其<code>Complete()</code><a href="https://sourcegraph.com/github.com/flutter/engine@053f7a8fa3bb4c50c28451f5403f176846692ce0/-/blob/lib/ui/window/platform_message_response_dart.cc?utm_source=share#L63:6" target="_blank" rel="noopener">方法实现</a>:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PlatformMessageResponseDart::Complete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;fml::Mapping&gt; data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (callback_.is_empty())    <span class="hljs-keyword">return</span>;  FML_DCHECK(!is_complete_);  is_complete_ = <span class="hljs-literal">true</span>;  ui_task_runner_-&gt;PostTask(fml::MakeCopyable(      [callback = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(callback_), data = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data)]() <span class="hljs-keyword">mutable</span> &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;tonic::DartState&gt; dart_state =            callback.dart_state().lock();        <span class="hljs-keyword">if</span> (!dart_state)          <span class="hljs-keyword">return</span>;        tonic::DartState::Scope scope(dart_state);<span class="hljs-comment">// 将Native层的二进制数据data转为Dart中的二进制数据byte_buffer</span>        Dart_Handle byte_buffer = WrapByteData(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(data));        tonic::DartInvoke(callback.Release(), &#123;byte_buffer&#125;);      &#125;));&#125;</code></pre><p>在上述代码中,向ui_task_runner_添加了一个新的Task,在该Task中首先将Native层二进制数据转为Dart中的二进制数据,然后调用Dart中的callback将数据返回到Dart层.Dart层在接受到数据后,使用MethodCodec进行解码数据并将其返回到业务代码.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上述以Dart作为发起方,完整梳理一次从Dart向Android平台发起方法调用(MethodCall)流程.实际MethodCall也支持以Android平台为发起方,通过MethodChannel调用Dart中的方法,对此就不做说明了.=</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前为止,关于Platform Channel基本原理已经讲解完成,最后通过对MethodChannel工作原理进行分析来加深理解.对于IOS开发者而言,其原理实现类似.</p><p>总体而言,Flutter中实现跨平台通信的机制简单却高效,总体难度不大.最后祝大家新年快乐,人人都能拐卖小学妹😈(Flutter).</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Flutter</tag>
      
      <tag>Platform Channel</tag>
      
      <tag>Dart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思考快与慢(一):高效开发之Intellij IDEA</title>
    <link href="/2019/01/27/%E6%80%9D%E8%80%83%E5%BF%AB%E4%B8%8E%E6%85%A2(%E4%B8%80)_%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E4%B9%8BIntellij%20IDEA/"/>
    <url>/2019/01/27/%E6%80%9D%E8%80%83%E5%BF%AB%E4%B8%8E%E6%85%A2(%E4%B8%80)_%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E4%B9%8BIntellij%20IDEA/</url>
    
    <content type="html"><![CDATA[<p>在15年开始从Eclipse转入IDEA时,为了兼容当时的使用习惯,自定义了许多快捷键.但随着后面MacOS逐渐成为我主要的开发平台,原先在Windows平台上定义的很多快捷键与MacOS原生快捷键有很多的冲突,经过一个阶段的思考与实践之后,我决定放弃原有的习惯,以全新的视角接受Intellij IDEA中的快捷键.</p><blockquote><p>下述快捷键适用于MacOS平台,基于<code>Mac 10.5+</code>.</p></blockquote><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>Command+Space</td><td>Basic code completion</td><td>基本代码补齐</td></tr><tr><td>Command+Shift+Space</td><td>Smart code completion</td><td>智能补齐</td></tr><tr><td>Command+Shift+Enter</td><td>Complete statement</td><td>语句补全(末尾自动加分号)</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+Alt+Enter</td><td>Start New Line Before Current</td><td>从上方开始一行</td></tr><tr><td>Shift+Enter</td><td>Start New Line</td><td>从下方开始一行</td></tr><tr><td>Shift+Alt+↑/↓</td><td>Move Line Up/Down</td><td>上移/下移一行</td></tr><tr><td>Shift+Command+↑/↓</td><td>Move Statement Up/Down</td><td>上移/下移一个块</td></tr><tr><td>Alt+↑/↓</td><td>Extend/Shrink Selection</td><td>选中/反选代码块</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+P</td><td>Parameter info</td><td>参数信息提示</td></tr><tr><td>Command+Y</td><td>Open quick definition lookup</td><td>浮窗快速查看定义</td></tr><tr><td>Ctrl+J</td><td>Quick documentation lookup</td><td>文档快速预览</td></tr><tr><td>Ctrl+O</td><td>Override methods</td><td>可覆盖方法快速预览</td></tr><tr><td>Crtl+I</td><td>Implement Code</td><td>实现接口方法</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+Shift+delete</td><td>Last edit location</td><td>跳转到上次编辑的地方</td></tr><tr><td>Command+Z</td><td>Undo</td><td>撤销修改</td></tr><tr><td>Command+Shift+Z</td><td>Redo</td><td>恢复刚才修改</td></tr><tr><td>Command+/</td><td>Comment/uncomment wiht line comment</td><td>注释/反注释行</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+N</td><td>Generate code</td><td>生成代码</td></tr><tr><td>Command+Alt+T</td><td>Surround with</td><td>嵌入代码块，如try…catch</td></tr><tr><td>Command+Alt+L</td><td>Reformat code</td><td>格式化代码</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+X</td><td>Cut current line to clipboard</td><td>剪贴行到剪贴板</td></tr><tr><td>Command+C</td><td>Copy current line to clipboard</td><td>复制行</td></tr><tr><td>Command+V</td><td>Paste from clipboard</td><td>粘贴</td></tr><tr><td>Command+D</td><td>Duplicate current line</td><td>复制行</td></tr><tr><td>Command+Delete</td><td>Delete line at caret</td><td>删除行</td></tr><tr><td>Command+W</td><td>Close active editor tab</td><td>关闭当前编辑窗口</td></tr></tbody></table><h1 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h1><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>Command+J</td><td>Insert Live Template</td><td>模板插入</td></tr><tr><td>Alt+Enter</td><td>Show Intention Actions</td><td>意图预测与智能帮助,比如简单重构,移除死代码,结构调整,自动导包等</td></tr><tr><td>Command+Shift+A</td><td>Find Action</td><td>命令查询</td></tr></tbody></table><h2 id="模板补全"><a href="#模板补全" class="headerlink" title="模板补全"></a>模板补全</h2><p>在使用Command+J选中模板关键字或者直接敲如模板关键字后,可以直接通过Tab或Enter键触发补全操作,其中<code>$1$2…</code>是我们要填充的模板变量,常见的模板操作如下</p><table><thead><tr><th>关键字</th><th>模板定义</th><th>说明</th></tr></thead><tbody><tr><td><code>ifn</code></td><td><code>if ($1 == null) {}</code></td><td>判空操作</td></tr><tr><td><code>inn</code></td><td><code>if ($1 != null) {}</code></td><td>判非空操作</td></tr><tr><td><code>fori</code></td><td><code>for (int $1 = 0; $1 &lt; $2; $1++) {}</code></td><td>创建索引循环</td></tr><tr><td><code>todo</code></td><td><code>// TODO: $1</code></td><td>添加todo说明</td></tr><tr><td><code>fixme</code></td><td><code>// FIXME: 7/19/16 $1</code></td><td>添加fixme说明</td></tr><tr><td><code>inst</code></td><td><code>if ($1 instanceof $2) {}</code></td><td>类型关系判断</td></tr><tr><td><code>sout</code></td><td><code>System.out.println($1);</code></td><td>标准输出</td></tr></tbody></table><h2 id="后缀完成"><a href="#后缀完成" class="headerlink" title="后缀完成"></a>后缀完成</h2><p><a href="https://blog.jetbrains.com/idea/2014/03/postfix-completion/" target="_blank" rel="noopener">后缀完成</a>是JetBrains系IDE的一项新功能,目的是减少光标经常性的前后移动,其使用惯例为:先使用元素,再考虑变量声明或结构补全.它的主要功能是根据当前元素的属性,提供可能的行为建议,例如使用if-else结构包围,判(非)空,格式化,进行类型转换等,常用的后缀声明如下:</p><table><thead><tr><th>后缀完成关键字</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>element.<code>sout</code></td><td><code>System.out.println(element);</code></td><td>将当前内容element定位到标准输出流</td></tr><tr><td>element.<code>return</code></td><td><code>return element;</code></td><td>将当前元素element作为返回值</td></tr><tr><td>element.<code>null</code></td><td><code>if (string == null) {}</code></td><td>元素判空操作</td></tr><tr><td>element.<code>notnull</code></td><td>if (string != null) {}</td><td>元素判非空操作</td></tr></tbody></table><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>F2/Shift+F2</td><td>Next/previous hghlighted error</td><td>下一个/上一个错误处,常配合Alt+Enter使用</td></tr><tr><td>Command+F1</td><td>Show desciptions of error</td><td>错误提示信息</td></tr></tbody></table><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>Shift+F6</td><td>Rename</td><td>重命名类/方法/变量</td></tr><tr><td>Ctrl+T</td><td>Refactor This</td><td>开始重构,重构一切</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+F6</td><td>Change Signature</td><td>修改方法签名</td></tr><tr><td>Command+Alt+M</td><td>Extract Method</td><td>重构成方法</td></tr><tr><td>Command+Alt+V</td><td>Extract Variable</td><td>重构成变量</td></tr><tr><td>Command+Alt+F</td><td>Extract Field</td><td>重构成字段</td></tr><tr><td>Command+Alt+C</td><td>Extract Constant</td><td>重构成静态变量</td></tr><tr><td>Command+Alt+P</td><td>Extract Parameter</td><td>重构参数列表</td></tr><tr><td></td><td></td><td></td></tr><tr><td>F5</td><td>Copy</td><td>拷贝类/目录等</td></tr><tr><td>F6</td><td>Move</td><td>移动类/目录等</td></tr></tbody></table><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>Command+O</td><td>Go to class</td><td>搜索类</td></tr><tr><td>Command+Shift+O</td><td>Go to file</td><td>搜索文件</td></tr><tr><td>Command+Alt+O</td><td>Go to sysbol</td><td>搜索符号</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+L</td><td>Go to line</td><td>跳转到某行</td></tr><tr><td>Command+U</td><td>Go to super-method/super-class</td><td>跳转到父级方法/类</td></tr><tr><td>Command+E</td><td>Recent files popup</td><td>跳到最近编辑过的文件列表</td></tr><tr><td>Command+B</td><td>Go to declaration</td><td>跳转到定义行</td></tr><tr><td>Command+Alt+B</td><td>Go to implementation(s)</td><td>进入接口实现方法</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+F12</td><td>File structure popup</td><td>文件结构弹窗,包含本类及所有基类方法</td></tr><tr><td>Ctrl+H</td><td>Type hierarchy</td><td>类继承体系</td></tr><tr><td>Ctrl+Alt+H</td><td>Call hierarchy</td><td>调用层次结构</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+Shift+F12</td><td>Hide All Tools Window</td><td>隐藏所有工具窗口,代码区最大</td></tr><tr><td>Command+1~9</td><td>Open corresponding tool window</td><td>显示对应工具窗口</td></tr></tbody></table><h1 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h1><table><thead><tr><th>快捷键</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>Shift+Shift</td><td>Search everywhere</td><td>全局搜索</td></tr><tr><td>Alt+F7</td><td>Find usages</td><td>查找引用点</td></tr><tr><td>Command+Alt+F7</td><td>Show usages</td><td>展示引用点</td></tr><tr><td>Command+Shift+F7</td><td>Highlight usages in file</td><td>高亮文件内引用点</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+F</td><td>Find</td><td>文件内查找</td></tr><tr><td>Command+Shift+F</td><td>Find in path</td><td>项目内查找</td></tr><tr><td>Command+G/Command+Shift+G</td><td>Find next/previous</td><td>按选择字符查找下一个/上一个</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Command+R</td><td>Replace</td><td>替换字符</td></tr><tr><td>Command+Shift+R</td><td>Replace in path</td><td>项目内替换</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Ctrl+G</td><td>Select next occurrence</td><td>选择下一个所选文本内容,可同时编辑</td></tr><tr><td>Ctrl+Command+G</td><td>Select all occurrences</td><td>选择全部相同文本，可同时编辑</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效</tag>
      
      <tag>开发</tag>
      
      <tag>快与慢</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenJDK系列(四):从JVM谈C/C++编译流程</title>
    <link href="/2018/09/25/OpenJDK%E7%B3%BB%E5%88%97(%E5%9B%9B)_%E4%BB%8EJVM%E8%B0%88C:C++%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2018/09/25/OpenJDK%E7%B3%BB%E5%88%97(%E5%9B%9B)_%E4%BB%8EJVM%E8%B0%88C:C++%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="编译器的这点事"><a href="#编译器的这点事" class="headerlink" title="编译器的这点事"></a>编译器的这点事</h1><p>gcc和g++还傻傻分不清楚?clang与gcc有什么关系?llvm又是什么?下面将对一些常见的名词进行说明以免在后续阅读中感到疑惑.</p><h2 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h2><p>gcc 即 GNU C Compiler, 刚开始它就是一个c编译器项目。后来越来越多的其他语言编译器也被添加到这个项目中,如用于编译c++代码的cc1plus.此时的gcc代表的是一堆编译器的集合(the GNU Compiler Collection).</p><p>现在编译系统中,我们执行的gcc已经不是特指当初的C语言编译器了,而是一个编译驱动程序:根据代码源文件后缀名来决定调用哪种的编译器或编译驱动器.比如后缀.c会调用c编译器(cc1)和链接器;如果后缀是.cpp则会调用g++(g++同样是一个驱动程序),g++最终会调用cc1plus编译器及链接器.用张图简单描述如下:</p><p><img src="https://i.imgur.com/r5bk7Cm.png" srcset="/img/loading.gif" alt="image-20180929111926694"></p><p>需要注意上图只是用来描述gcc和g++的位置关系.对于HelloWorld.c文件,当然我们也可以直接用g++驱动器,那下述两种方式有什么区别么?</p><pre><code class="hljs shell">gcc HelloWorld.c -o HelloWorld.out<span class="hljs-meta">#</span><span class="bash"> 或</span>g++ HelloWorld.c -o HelloWorld.out</code></pre><ul><li><p>对于 <em>.c和</em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</p><p>比如以下代码:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<span class="hljs-keyword">if</span>(argv == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;printDebug(argv);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printDebug</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-built_in">string</span>)</span> </span>&#123;  <span class="hljs-built_in">sprintf</span>(<span class="hljs-built_in">string</span>, <span class="hljs-string">"debug\n"</span>);&#125;</code></pre><p>如果将其保存成.c文件,gcc按照C的语法规则对其编译,没有任何问题.但是一旦将其保存为cpp文件,那gcc会按照C++语法规则对其编译,此时报错:<code>use of undeclared identifier &#39;printDebug&#39;</code></p></li><li><p>对于 <em>.c和</em>.cpp文件，g++统一当做cpp文件编译.编译过程中如果遇到C代码,则仍会调用C编译器进行编译.</p></li></ul><p>此外在编译阶段,使用g++会自动链接标准库STL，而gcc不会需要通过指定–lstdc++来进行链接.当然还有一宏定义上的区别,有兴趣的可以进一步探索.</p><h2 id="LLVM和Clang"><a href="#LLVM和Clang" class="headerlink" title="LLVM和Clang"></a>LLVM和Clang</h2><p>LLVM(Low Level Virtual Machine) 是一个开源的编译器架构，采用C++编写,由Chris Lattner负责.在Chris Lattner加入Apple公司后,Apple公司成为LLVM计划的主要资助者.和其他现代编译器架构一样,LLVM同样分为前端编译器和后端编译器,早期在LLVM架构中最重要组成部分是后端编译器.</p><p>Apple公司在早期使用GCC作为其官方的编译工具,但随着Objective-C推出,其中许多新特性需要编译器来支持,但GCC的开发者并不买Apple的帐,同时由于GCC过于复杂繁重,加之和XCode的配合不好,Apple公司在LLVM的基础上开发前端编译器Clang以取代GCC.现代LLVM整体架构如下,关于前端编译器和后端编译器后续说明.</p><p><img src="https://i.imgur.com/t62jQOQ.png" srcset="/img/loading.gif" alt="image-20180929131023721"></p><p>相比于 GCC，Clang 具有如下优点：</p><ul><li>更快的编译速度：在某些平台上，Clang 的编译速度要比GCC快很多</li><li>内存占用小：Clang 生成的 AST 所占用的内存要远远小于GCC</li><li>Clang输出的信息更详细,更容易理解,和GCC相比,更易排查和定位问题</li><li>诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。</li><li>Clang采用模块化设计,整个项目相比GCC要清晰简单,扩展性较好.</li></ul><p>当然Clang由于面世时间较短,其最大的问题仍然是对语言和平台的支持度不够,和GCC相比,Clang目前只支持C/C++/Objective-C/Objective-C++/Swift,且当前只能应用于Linux/Windows/Mac OS.</p><p>另外通过下图来展示Apple公司中编译系统的演化过程:</p><p><img src="https://i.imgur.com/OIdBCD0.png" srcset="/img/loading.gif" alt="image-20180929130227827"></p><p>需要注意,从Mac OS X 10.9/Xcode 5开始,系统中已经不预装GCC了.此时我们在MacOS中使用的gcc只是clang的别名.此时通过<code>gcc -v</code>查看版本信息:</p><p><img src="https://i.imgur.com/A3IK39a.png" srcset="/img/loading.gif" alt="image-20180929172256863"></p><p>在大多情况,使用clang并不会遇到什么问题.但如果你从事Android系统开发,那么在编译MTK平台上会遇到编译错误,其原因在于MTK的某些工具只支持GCC.</p><p>尽管在细节来看Mac OS中的gcc(即clang)和Linux下gcc有所差异,但不妨碍我们整体把握编译流程.如果你想体会原汁原味的GCC,那么在Mac OS可使用Hombrew自行安装:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看Homebrew支持的Gcc版本,目前支持:apple-gcc42,gcc,gcc@4.9,gcc@5,gcc@6,gcc@7</span>brew search gcc<span class="hljs-meta">#</span><span class="bash"> 安装指定版本,比如这里我安装gcc-6</span>brew install gcc@6</code></pre><p>安装完成后,gcc的命令需要替换为gcc-6,比如<code>gcc HelloWorld.c</code>需要修改为<code>gcc-6 HelloWorld.c</code>.如果你不想这么麻烦,那么将为gcc-6定义别名,在.bash_profile中添加以下:</p><pre><code class="hljs shell">alias gcc='gcc-6'alias cc='gcc-6'alias g++='g++-6'alias c++='c++-6'</code></pre><p>添加完成后,保存退出,执行<code>source ~/.bash_profile</code>使其生效,这样我们就可以使用真正的gcc了:</p><p><img src="https://i.imgur.com/ZHj7w5t.png" srcset="/img/loading.gif" alt="image-20180929191626320"></p><h2 id="GDB和LLDB"><a href="#GDB和LLDB" class="headerlink" title="GDB和LLDB"></a>GDB和LLDB</h2><p>GDB是GCC中提供的诊断工具,调试时非常有用.同样的,在Clang中也提供了类似的诊断工具<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">LLDB</a>.LLDB在GDB的基础上进行扩展,更加好用.从XCode 4.3开始,已经默认LLDB来代替之前的GDB了.得益于LLDB良好的兼容性,对于IOS开发者而言,基本上可以实现平稳过渡.</p><h1 id="C语言编译流程"><a href="#C语言编译流程" class="headerlink" title="C语言编译流程"></a>C语言编译流程</h1><p>学习OpenJDK首先要学会如何编译OpenJDK,之前在OpenJDK根目录下执行.configure脚本即可实现对OpenJDK的编译.抱着知其然更知其所以然的态度,我们重新来捋一捋关于编译的事情,当然由于VM主要是由C/C++来开发的,因此我们这里谈的编译就非Java视角中的编译了.</p><p>C++是C语言的超集,其编译流程和C编译流程一样,这里选择C语言.C语言的源码文件的扩展名是.c,最终其可执行文件的扩展名是.out.任何一个.c到.out都要经过以下四步:</p><ol><li>预处理(Prepressing)</li><li>编译(Compilation)</li><li>汇编(Assembly)</li><li>链接(Linking)</li></ol><p>需要注意的是,使用IDE开发时所谈的编译是个高层概念,是以上四个步骤的统称.以下述代码HelloWorld.c为例:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在命令行工具中执行以下命令来编译并运行该程序:</p><pre><code class="hljs shell">gcc HelloWorld.c -o HelloWorld./HelloWorld</code></pre><p>第一行命令实际上就是对HelloWorld.c依次进行了<code>预处理-&gt;编译-&gt;汇编-&gt;链接</code>操作,得到可执行文件HelloWorld.out;第二行命令则是对HelloWorld.out进行装载操作.</p><p>下面分开来看每个过程.gcc允许指定不同的参数来了控制整个编译过程,下表中是我们将要用到的参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>只进行预处理,不进行编译,汇编,链接</td></tr><tr><td>-S</td><td>只进行编译,不进行汇编和链接</td></tr><tr><td>-c</td><td>进行编译和汇编,不进行链接</td></tr><tr><td>-o</td><td>输出可执行文件</td></tr></tbody></table><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译过程主要包括删除注释,添加行号和文件名标志等用于调试的信息以及处理源代码中以”#”开始的预编译指令.C语言中常用的预编译指令有:</p><ul><li>宏定义指令<code>#define</code></li><li>条件编译指令<code>#if</code>,<code>#ifdef</code>,<code>#elif</code>,<code>#else</code>,<code>#endif</code></li><li>文件包含指令<code>#include</code></li><li><code>#pragma</code>编译器指令</li></ul><p>预处理器对不同的预编译指令有不同的处理过程,简单概括为:</p><ul><li><code>#include</code>:将被包含的文件插入到该预编译指令的位置.该过程是递归进行的,也就是被包含的文件可能还包含其他文件.</li><li><code>#define</code>:将所有的<code>#define</code>删除,并展开所有的宏定义</li><li><code>#pragma</code>:保留所有的#pragma指令</li></ul><p>预处理之后的文件扩展名是.i,其本质仍然是C代码.执行以下命令获得预处理之后的文件:</p><pre><code class="hljs shell">gcc -E HelloWorld.c -o HelloWorld.i</code></pre><p><img src="https://i.imgur.com/DFRiaHY.png" srcset="/img/loading.gif" alt="image-20180928183318187"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程需要编译器的介入,所谓的编译器就是将一种语言编译另一种语言的工具.对于C语言编译器而言,在Linux上由程序cc1实现从c转为汇编代码的过程,该过程涉及一系列的词法分析,语法分析,语义分析及优化后生成相应的汇编代码文件.cc1会对预处理后生成的.i文件进行处理以生成对应的汇编代码,通过执行以下命令来获得编译后的文件:</p><pre><code class="hljs shell">gcc -S HelloWorld.i -o HelloWorld.s<span class="hljs-meta">#</span><span class="bash"> 或</span>gcc -S HelloWorld.c -o HelloWorld.s</code></pre><p><img src="https://i.imgur.com/byNyoMZ.png" srcset="/img/loading.gif" alt="image-20180928184800603"></p><blockquote><p>用一句话来描述汇编语言:所谓的汇编代码就是不同CPU指令二进制代码对应助记符的集合.汇编代码需要借助汇编器才能转换为平台相关的二进制代码.</p></blockquote><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析是编译过程的第一阶段,也称为扫描,其主要任务是读入源程序的输入字符,并将其分割成一系列的词法单元(Token),最终输出一个词法单元序列.以代码<code>int result = (index +2) * (5 - 2)</code>为例,分析之后生成的词法单元序列如下:</p><table><thead><tr><th>词法单元</th><th>属性</th></tr></thead><tbody><tr><td>int</td><td>标志符</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>(</td><td>左括号</td></tr><tr><td>index</td><td>标志符</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>)</td><td>右括号</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>(</td><td>左括号</td></tr><tr><td>5</td><td>数字</td></tr><tr><td>-</td><td>加号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>)</td><td>右括号</td></tr></tbody></table><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>接下来词法分析器会对由词法分析器生成的词法单元序列进行语法分析,从而产生语法树.至于生成语法的方法不做详解,有兴趣的同学可以阅读龙书.还是以<code>int result = (index +2) * (5 - 2)</code>为例:</p><p><img src="https://i.imgur.com/EJm5uN6.png" srcset="/img/loading.gif" alt="image-20180928210949857"></p><p>该赋值表达式左边是一个变量,右边是一个乘法表达式.这里符号和数字就是最小的表达式,表现为树的叶子节点.在语法分析的过程中,运算符的优先级和含义也会被确认下来.在分析的过程,如果表达式不合法,比如缺少括号不匹配,编译就会报错.</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>正如我们英语翻译,语法分析能够保证当前句子合乎语法规则,但一个正确的句子还应该有正确的语义.比如<code>Dog is pig</code>合乎语法,但是却没有正确的语义.对于代码表达式而言,保证语义正确性同样是不可或缺的,比如对一个指针和浮点数进行乘法操作是否合法,赋值操作类型是否合法等等.</p><p>根据其检查的时机不同,语义分析分为静态语义分析和动态语义分析.静态语义分析作用于编译阶段,比如类型检查等;动态语义分析作用于运行阶段,比如数组访问越界等.同样表达式<code>int result = (index +2) * (5 - 2)</code>为例:</p><p><img src="https://i.imgur.com/nS1SqbR.png" srcset="/img/loading.gif" alt="image-20180928213339605"></p><p>不难发现,语义分析完后,整个语法树的节点被标志了类型.实际上,整个语义分析的过程更为复杂,只不过由于我们的表达式比较简单,且本文重点不在于描述编译的细节,因此很多地方我们一笔带过.</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>将给定语言翻译成特定的目标机器代码的过程中,编译器可能会构造出一系列的中间表示.其中高层的中间的表示接近于源代码,而底层中间表示接近于目标机器代码.</p><p><img src="https://i.imgur.com/MMiNMlK.png" srcset="/img/loading.gif" alt="image-20180928214909526"></p><p>语法树是高层的表示,描述了源代码的自然的层次性结构;低层次的表示形式适用于机器相关的处理任务.为什么不是源代码直接翻译成目标代码,而要加入中间代码呢?</p><p>其原因在于编译器在执行过程中不仅仅是按部就班的进行代码的转换,还需要进行一定的优化.要直接在语法树上进行优化相对困难,因此引入了中间代码,然后在中间代码的基础上进行一系列的操作.仍然以<code>int result = (index +2) * (5 - 2)</code>为例,由于子表达式(5-2)在编译阶段即可确定值为3,因此最终会被优化成<code>int result = (index + 2) * 3</code>.这里我们只是举了简单的例子,实际上编译器对代码的优化流程非常复杂.后面会用单独的篇幅来讲述.</p><p>此外以中间代码为分割线,可以将编译器分为前端编译器和后端编译器.前端编译器负责生成与平台无关的中间代码,后端编译器则负责将其转换为目标代码.从这方面来说中间代码的引入也为支持多平台提供了有力的帮助.</p><p><img src="https://i.imgur.com/dIBvACA.png" srcset="/img/loading.gif" alt="image-20180928223246860"></p><p>到现在关于前端编译器已经说清楚了,接下来便是目标代码的生成,即后端编译器的主要功能.</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>前端编译器最终生成的中间代码会作为后端编译器的输入,其中后端编译器主要包括用于生成目标代码的代码生成器以及对目标机器代码进行优化的目标代码优化器.其中目标代码优化器最终目标提高寻址速度以及减少指令调用以提供性能.</p><p>C/C++生成的中间代码是汇编语言,因此需用到汇编器将汇编代码转成机器代码(此处的汇编器即代码生成器).和编译器相比,汇编器比较简单:多数情况下每个汇编语句都对应于一条机器指令,因此汇编器只需要按汇编指令和机器指令的对照表一一进行翻译即可.</p><p>通过执行以下指令来进行汇编操作,最终得到可重定位目标文件HelloWorld.o:</p><pre><code class="hljs shell">as HelloWorld.s -o HelloWorld.o<span class="hljs-meta">#</span><span class="bash"> 或</span>gcc -c HelloWorld.c -o HelloWorld.o</code></pre><p>常见的三种格式的目标文件如下表所示:</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>可重定位目标文件(Relocatable File)</td><td>包含数据和二进制代码,可以在编译时与其他可重定位目标合并,创建一个可执行目标文件</td></tr><tr><td>可执行目标文件(Executable File)</td><td>包含数据和二进制代码,可以直接被复制到到内存并执行.其典型代表为Linux下的ELF</td></tr><tr><td>共享目标文件(Shared Object File)</td><td>特殊类型的可重定位目标文件,包含数据和二进制代码,可在加载或者运行时被动态地加载到内存并连接.</td></tr></tbody></table><p>目标文件中存放是与源程序等效的目标机器语言代码.在目标文件中,引入了Section概念,它是一种数据结构,有时我们也称之为段.根据描述对象的不同划分了不同的段,目前只需要用于描述源代码的代码段以及用于变量的数据段即可</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>由汇编程序生成的目标文件通常不能被直接运行.比如一个项目有许多模块组成,不同的模块之间存在引用关系,如何将这些模块”拼接”成一个可执行的程序的过程就叫做链接.更准确说,链接就是各种代码和数据片段收集并组合成一个单一文件的过程,这个文件可以加载到内存并执行.为了构造可执行目标文件,链接器需要完成以下两个功能:</p><ul><li>符号解析(symbol resolution):目标文件定义和引用符号,每个符号对应于一个函数,全局变量/静态变量,符号解析需要将每个符号引用正好是符号定义关联起来.</li><li>重定位(relocation):编译器和汇编器生成从地址0开始的代码段/数据段,链接器通过把每个符号定义和内存位置关联起来,从而重定位这些段(定位了段,根据段内代码的偏移量也就可以定位具体的代码/数据),然后修改对这些符号的引用,使它们指向这个内存位置,以便代码能被正确的运行.</li></ul><p>此外根据作用的时期不同,链接分为编译时链接,加载时链接和运行时链接.像Java这种语言采用的是加载时链接.对C而言我们常说的是静态链接和动态链接.</p><p>通过执行以下指令来进行链接操作,最终得到可执行目标文件HelloWorld:</p><pre><code class="hljs shell">gcc HelloWorld.s -o HelloWorld</code></pre><p>现在有了可执行目标文件后,就可以将其加载到内存并运行.链接的过程比较有趣,后面会另加解释.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到现在为止整个编译流程已经描述完成,下图是整个编译流程的描述.(此处的编译是我们说的高层概念)</p><p><img src="https://i.imgur.com/W5JHqAn.png" srcset="/img/loading.gif" alt="image-20180929222737155"></p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>clang</tag>
      
      <tag>llvm</tag>
      
      <tag>预处理</tag>
      
      <tag>编译</tag>
      
      <tag>汇编</tag>
      
      <tag>链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenJDK系列(三):JVM对CAS的设计与实现</title>
    <link href="/2018/06/27/OpenJDK%E7%B3%BB%E5%88%97(%E4%B8%89)_VM%E4%B8%ADCAS%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/06/27/OpenJDK%E7%B3%BB%E5%88%97(%E4%B8%89)_VM%E4%B8%ADCAS%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a>CAS简介</h1><p>CAS即Compare-and-Swap的缩写,即比较并交换,它是一种实现乐观锁的技术.在CAS中包含三个操作数:</p><ul><li>V: 需要读写的内存位置,从java角度你可以把它当成一个变量</li><li>A: 预期值,也就是要进行比较的值</li><li>B: 拟写入的新值</li></ul><p>当且仅当V的值等于A时,CAS才会通过<strong>原子</strong>方式用新值B来更新V的值,否则不会执行任何操作.无论位置V的值是否等于A,最终都会返回V原有的值.换句话说:”我认为V的值应该是A,如果是,那么就将V的值更新为B,否则不修改并告诉V的实际值是多少”.</p><p>当多个线程使用CAS同时更新同一个变量时,只有其中一个线程能够成功更新变量的值,其他线程都将失败.和锁机制不同,失败的线程并不会被挂起,而是告知用户当前失败的情况,并由用户决定是否要再次尝试或者执行其他操作,其典型的流程如下:</p><p><img src="https://i.imgur.com/P4iFBcL.png" srcset="/img/loading.gif" alt="image-20180910121551030"></p><h2 id="传统锁实现CAS语义"><a href="#传统锁实现CAS语义" class="headerlink" title="传统锁实现CAS语义"></a>传统锁实现CAS语义</h2><p>在明白CAS的语义后,我们用传统的锁机制来实现该语义.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCAS</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">// 比较并交换语义,最终都返回原有值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareAndSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exectedValue, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;        <span class="hljs-keyword">int</span> oldValue = value;        <span class="hljs-keyword">if</span> (oldValue == exectedValue) &#123;            value = newValue;        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">// 比较并设置语义,返回成功与否    </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> exectedValue, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> exectedValue == compareAndSwap(exectedValue, newValue);    &#125;&#125;</code></pre><p>在上述代码中,<code>compareAndSwap()</code>用于实现”比较并交换”的语义,在此之上我们还实现了”比较并设置”的语义.</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>CAS典型使用模式是:首先从V中读取值A,并根据A计算出新值B,然后再通过CAS以原子方式将V中的值变成B(如果在此期间没有任何线程将V的值修改为其他值).我们借助刚才的SimpleCAS实现一个计数器,借此来说明其使用场景:</p><pre><code class="hljs java"><span class="hljs-comment">// 线程安全的计数器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeCounter</span> </span>&#123;    <span class="hljs-keyword">private</span> SimpleCAS cas;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SafeCounter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cas = <span class="hljs-keyword">new</span> SimpleCAS();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cas.getValue();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">int</span> newValue;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 读取旧值A</span>            value = cas.getValue();            <span class="hljs-comment">// 根据A计算新值B</span>            newValue = value + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">while</span> (!cas.compareAndSet(value, newValue));<span class="hljs-comment">// 使用CAS来设置新值B</span>        <span class="hljs-keyword">return</span> newValue;    &#125;&#125;</code></pre><p>SafeCounter不会阻塞,如果其他线程同时更新计数器,那么会执行多次重试操作直至成功.到现在有关CAS的语义和使用已经说完,下面我们要说的是CAS在JAVA中的应用以及JVM中如何实现CAS.</p><h1 id="CAS实现"><a href="#CAS实现" class="headerlink" title="CAS实现"></a>CAS实现</h1><p>通过传统的锁实现的CAS语义并非JVM真正对CAS的实现,这点需要记住.JVM中能够实现CAS本质是现代CPU已经支持Compare-and-Swap指令.从Java 5.0开始,JVM中直接调用了相关指令.</p><h2 id="JVM对CAS的支持"><a href="#JVM对CAS的支持" class="headerlink" title="JVM对CAS的支持"></a>JVM对CAS的支持</h2><p>有关原子性变量的操作被统一定义在atomic.hpp,并以模板方法提供,其路径为:</p><p><code>/OpenJDK10/hotspot/src/share/vm/runtime/atomic.hpp</code></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> D, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> D <span class="hljs-title">Atomic::cmpxchg</span><span class="hljs-params">(T exchange_value,</span></span><span class="hljs-function"><span class="hljs-params">                         D <span class="hljs-keyword">volatile</span>* dest,</span></span><span class="hljs-function"><span class="hljs-params">                         U compare_value,</span></span><span class="hljs-function"><span class="hljs-params">                         cmpxchg_memory_order order)</span> </span>&#123;  <span class="hljs-keyword">return</span> CmpxchgImpl&lt;T, D, U&gt;()(exchange_value, dest, compare_value, order);&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Atomic</span>:</span>:CmpxchgImpl&lt;  T, T, T,  <span class="hljs-keyword">typename</span> EnableIf&lt;IsIntegral&lt;T&gt;::value || IsRegisteredEnum&lt;T&gt;::value&gt;::type&gt;  VALUE_OBJ_CLASS_SPEC&#123;  <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T exchange_value, T <span class="hljs-keyword">volatile</span>* dest, T compare_value,</span></span><span class="hljs-function"><span class="hljs-params">               cmpxchg_memory_order order)</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-comment">// Forward to the platform handler for the size of T.</span>    <span class="hljs-keyword">return</span> PlatformCmpxchg&lt;<span class="hljs-keyword">sizeof</span>(T)&gt;()(exchange_value,                                        dest,                                        compare_value,                                        order);  &#125;&#125;;</code></pre><p>不同的平台PlatformCmpxchg实现不同,比如在mac平台上,其实现在</p><p><code>/OpenJDK10/hotspot/src/os_cpu/bsd_x86/vm/atomic_bsd_x86.hpp</code></p><pre><code class="hljs c++"><span class="hljs-comment">// 1字节长度</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">1</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order <span class="hljs-comment">/* order */</span>) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">1</span> == <span class="hljs-keyword">sizeof</span>(T));  <span class="hljs-comment">// 内嵌汇编代码,最终调用cmpxchgb指令实现"比较并交换"  </span>  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(  <span class="hljs-string">"lock cmpxchgb %1,(%3)"</span></span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"=a"</span> (exchange_value)</span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"q"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest)</span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>)</span></span>;  <span class="hljs-keyword">return</span> exchange_value;&#125;<span class="hljs-comment">// 4字节长度</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">4</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order <span class="hljs-comment">/* order */</span>) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">4</span> == <span class="hljs-keyword">sizeof</span>(T));  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(  <span class="hljs-string">"lock cmpxchgl %1,(%3)"</span></span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"=a"</span> (exchange_value)</span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"r"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest)</span></span><span class="hljs-function"><span class="hljs-params">                    : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>)</span></span>;  <span class="hljs-keyword">return</span> exchange_value;&#125;<span class="hljs-comment">// 8字节长度</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">8</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order <span class="hljs-comment">/* order */</span>) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">8</span> == <span class="hljs-keyword">sizeof</span>(T));  __asm__ __volatile__ (  <span class="hljs-string">"lock cmpxchgq %1,(%3)"</span>                        : <span class="hljs-string">"=a"</span> (exchange_value)                        : <span class="hljs-string">"r"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest)                        : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>);  <span class="hljs-keyword">return</span> exchange_value;&#125;</code></pre><p>在window_x86平台中,其实现在<code>/OpenJDK10/hotspot/src/os_cpu/windows_x86/vm/atomic_windows_x86.hpp</code></p><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">1</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order order) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">1</span> == <span class="hljs-keyword">sizeof</span>(T));  <span class="hljs-comment">// alternative for InterlockedCompareExchange</span>  <span class="hljs-comment">// 内嵌汇编代码,最终调用cmpxchg指令实现"比较并交换"   </span>  __asm &#123;    mov edx, dest    mov cl, exchange_value    mov al, compare_value    lock cmpxchg <span class="hljs-keyword">byte</span> ptr [edx], cl  &#125;&#125;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">4</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order order) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">4</span> == <span class="hljs-keyword">sizeof</span>(T));  <span class="hljs-comment">// alternative for InterlockedCompareExchange</span>  __asm &#123;    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    lock cmpxchg dword ptr [edx], ecx  &#125;&#125;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> T Atomic::PlatformCmpxchg&lt;<span class="hljs-number">8</span>&gt;::<span class="hljs-keyword">operator</span>()(T exchange_value,                                                T <span class="hljs-keyword">volatile</span>* dest,                                                T compare_value,                                                cmpxchg_memory_order order) <span class="hljs-keyword">const</span> &#123;  STATIC_ASSERT(<span class="hljs-number">8</span> == <span class="hljs-keyword">sizeof</span>(T));  jint ex_lo  = (jint)exchange_value;  jint ex_hi  = *( ((jint*)&amp;exchange_value) + <span class="hljs-number">1</span> );  jint cmp_lo = (jint)compare_value;  jint cmp_hi = *( ((jint*)&amp;compare_value) + <span class="hljs-number">1</span> );   <span class="hljs-comment">// 内嵌汇编代码,最终调用cmpxchg8b指令实现"比较并交换"8字节   </span>  __asm &#123;    push ebx    push edi    mov eax, cmp_lo    mov edx, cmp_hi    mov edi, dest    mov ebx, ex_lo    mov ecx, ex_hi    lock cmpxchg8b qword ptr [edi]    pop edi    pop ebx  &#125;&#125;</code></pre><p>不难发现,最终都是通过内嵌汇编代码的形式来实现对于CPU指令cmpxchg的调用,关于该指令后续单独进行说明.到目前为止,对于JVM中的CAS操作已经了解的差不多了,但在Java层又是如何使用的呢?在开始了解Java层之前,我们先来看JVM是如何向Java层暴露这些操作的.</p><p>Java层无法直接调用CPU指令,必须借助JNI,这里对CAS的调用在Java层就体现在sun.misc.Unsafe类上,UnSafe类中定义了很多Native方法:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNatives</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">static</span> &#123;        registerNatives();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Unsafe</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe = <span class="hljs-keyword">new</span> Unsafe();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                                    Object expected,</span></span><span class="hljs-function"><span class="hljs-params">                                                    Object x)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,</span></span><span class="hljs-function"><span class="hljs-params">                                                 <span class="hljs-keyword">int</span> expected,</span></span><span class="hljs-function"><span class="hljs-params">                                                 <span class="hljs-keyword">int</span> x)</span></span>;    .......&#125;</code></pre><p>其对应的C++实现类是:</p><p><code>/OpenJDK10/hotspot/src/share/vm/prims/unsafe.cpp</code>,这里的compareAndSetInt()其实就对应于unsafe.cpp中的Unsafe_CompareAndSetInt():</p><pre><code class="hljs c++">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) &#123;  oop p = JNIHandles::resolve(obj);  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);  <span class="hljs-comment">// 调用Atomic.cpp中的cmpxchg()</span>  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;&#125; UNSAFE_END</code></pre><p>总结一下,sun.misc.Unsafe中Native方法的调用,最终都会通过JNI调用到unsafe.cpp中,而unsafe.cpp中的实现本质都是调用CPU的cmpxchg指令.关于cmpxchg指令将在后续单独说明.</p><p>到现在为止,JVM如何实现CAS以及如何向Java层暴露CAS操作这两个流程已经比较明了了,接下来还是要回归到Java层,来明白Java层中对CAS的支持.</p><h2 id="Java层对CAS的支持"><a href="#Java层对CAS的支持" class="headerlink" title="Java层对CAS的支持"></a>Java层对CAS的支持</h2><p>在Java层面,原子变量类(java.util.concurrent.atomic中的AtomicXXX)在底层充分使用了来此JVM对CAS的支持,来实现高效的原子操作,此外,java.util.concurrent中的大多数类在实现时也是借助了这些原子变量类.以AtomicInteger为例,来了解下Atomic如何使用CAS.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6214790243416807050L</span>;    <span class="hljs-comment">// Unsafe类型的成员变量U</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialValue)</span> </span>&#123;        value = initialValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expectedValue, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> U.compareAndSetInt(<span class="hljs-keyword">this</span>, VALUE, expectedValue, newValue);    &#125;        ......&#125;</code></pre><p>通过上述代码不难看出,AtomicInteger本质就是CAS在Java层的应用.在明白CAS原理后,对AtomicInteger并不会感到难以理解.可以说正是有了CPU对Compare-and-Swap的支持,才使得Java在并发上有了突飞猛进的提升.另外在不支持Compare-and-Swap的平台上,JVM将使用自旋锁来代替.</p><h1 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h1><p>ABA问题是CAS中是一种常见的问题:在于并发环境下,当第一个线程执行CAS(V,A,B)操作,在已经获取到当前变量V，但还没将其修改为新值B前，其他线程在其期间连续修改了两次变量V的值，使得该值又恢复为旧值.在这种情况下,我们无法判断这个变量是否已被修改过.其流程如下:</p><p><img src="https://i.imgur.com/GyRDyLY.png" srcset="/img/loading.gif" alt="image-20180910153730654"></p><p>在大多数情况下,ABA问题并不会影响最终的计算结果,但如果需要避免ABA问题该怎么办呢?从上述流程看出导致ABA的问题个根源是在时间线推进过程中没有为每次修改记录版本号导致.解决该问题只需要在每次修改时记录下其当前时间戳作为版本号就可以避免.在Java中,AtomicStampedReference原子类实现原理就是如此:设置值时要求对象值以及时间戳都必须满足期望值才能写入成功.(可以理解为git中的commit-id,先将A修改为B,再修改成A,最终内容虽然没变,但通过版本commit-id,我们仍然可以知道中间发生了变化)</p><p>除了ABA问题外,如果自旋CAS长时间失败会给CPU带来很大的开销,在并发激烈的时候该问题尤其明显.另外,CAS使用场景比较单一,只能用于保证一个共享变量的原子操作.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenJDK</tag>
      
      <tag>HotSpot</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenJDK系列(二):从ClassFileParser谈Endian</title>
    <link href="/2018/06/22/OpenJDK%E7%B3%BB%E5%88%97(%E4%BA%8C)_%E4%BB%8EClassFileParser%E8%B0%88Endian/"/>
    <url>/2018/06/22/OpenJDK%E7%B3%BB%E5%88%97(%E4%BA%8C)_%E4%BB%8EClassFileParser%E8%B0%88Endian/</url>
    
    <content type="html"><![CDATA[<h1 id="Endian"><a href="#Endian" class="headerlink" title="Endian"></a>Endian</h1><p>Endian即所谓的字节序,通俗点说就是多于一个类型的数据在内存中存取的顺序目前有两种字节序.</p><ul><li>Big-Endian: 也称为大端序:高位字节存放在内存的低地址端,低位字节存放在内存的高地址端.</li><li>Little-Endian: 也称为小端序:高位字节存放在内存的高地址端,低位字节存放在内存的低地址端.</li></ul><h2 id="Endian与内存单元"><a href="#Endian与内存单元" class="headerlink" title="Endian与内存单元"></a>Endian与内存单元</h2><p>对于0x12345678而言,1234是高四位,5678是低四位.再以十进制的98来说9是高位,8是低位.现在回顾下内存的抽象模型:由不同的存储单元的构成,每个存储单元容量为1个字节.</p><p><img src="https://i.imgur.com/quksnoX.png" srcset="/img/loading.gif" alt="image-20180905111953115"></p><p>也就是说一个内存单元可以存放C语言中一个char类型数据,如果是short类型,则需要占用2个内存单元,而int类型则需要占据4个内存单元,比如int类型的305419896,其十六进制为0x12345678,需要占据4个内存单元,那这个4个内存单元中到底该如何存放数据呢?此时就用到了刚才的Endian.</p><p>如果按照Big-Endian方式,其内存布局如下:</p><p><img src="https://i.imgur.com/yU8oxKu.png" srcset="/img/loading.gif" alt="image-20180905105723144"></p><p>如果按照Little-Endian方法,其内存布局如下:</p><p><img src="https://i.imgur.com/Z66SXoD.png" srcset="/img/loading.gif" alt="image-20180905105758961"></p><p>可以看出,对于超过一个字节类型的数据按照不同Endian会在内存中呈现不同的存放顺序,那为什么会出现大小端呢?</p><h2 id="Endian起因"><a href="#Endian起因" class="headerlink" title="Endian起因"></a>Endian起因</h2><p>Endian产生根本原因在于CPU要想读写内存中的数据必须借助于寄存器.内存单元的容量一直保持1Byte不变,但寄存器却随着发展其容量不断增加,比如现代计算机的寄存器的容量都是超过1Byte的.这种寄存器容量和内存单元容量的差异最终导致字节序问题.寄存器如何保存超过一个字节数据必然涉及到某种顺序,这种顺序就体现在寄存器高低位的定义,而这种定义又会影响到数据在寄存器中的存放,最终在内存的存储顺序上体现出来.</p><h1 id="Endian与Class解析"><a href="#Endian与Class解析" class="headerlink" title="Endian与Class解析"></a>Endian与Class解析</h1><p>Endian和字节流解析有什么联系呢?在单机上采用同一种模式进行存取操作时,CPU会自动处理这种变化,保证数据写入和读取之后的结果一致.但涉及到网络传输或者跨平台后,就无法保证双方使用的是同一种模式,如果不一致则会导致数据问题,因此需要进行大小端的转换.</p><p>对于Java这种跨平台语言而言,同样需要关注这种差异.Java输出的字节信息都是大端模式,但JVM是却由C/C++编写的.在默认情况下C/C++的大小端模式与当前计算机硬件平台的大小端模式保持一致,如果JVM对此不做特殊处理,最终读取的字节码文件会有问题.在实际开发中,我们并不会关注该问题,这是因为JVM在读取字节码文件时做了特殊处理:如果检测到当前平台采用的是小端模式,会将其转为大端模式,以保证字节码文件的在JVM中的一致性.</p><p>整个流程可以简单描述为:当一个类需要被加载时,最终会交给classload.cpp的<code>load_class()</code>,接下来由ClassFileParser.cpp的<code>parse_stream()</code>负责解析.class文件对应ClassFileStream,在解析的过程中会根据平台的Endian来决定是否要进行转换.</p><h2 id="ClassFileStream"><a href="#ClassFileStream" class="headerlink" title="ClassFileStream"></a>ClassFileStream</h2><p>ClassFileStream是用于读取.class文件的输入流,其路径为:</p><p><code>/OpenJDK10/OpenJDK10/hotspot/src/share/vm/classfile/classFileParser.hpp</code></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassFileStream</span>:</span> <span class="hljs-keyword">public</span> ResourceObj &#123; <span class="hljs-keyword">private</span>:  <span class="hljs-keyword">const</span> u1* <span class="hljs-keyword">const</span> _buffer_start; <span class="hljs-comment">// Buffer bottom</span>  <span class="hljs-keyword">const</span> u1* <span class="hljs-keyword">const</span> _buffer_end;   <span class="hljs-comment">// Buffer top (one past last element)</span>  <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">const</span> u1* _current;    <span class="hljs-comment">// Current buffer position</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> _source;     <span class="hljs-comment">// Source of stream (directory name, ZIP/JAR archive name)</span>  <span class="hljs-keyword">bool</span> _need_verify;             <span class="hljs-comment">// True if verification is on for the class file</span>      .......  &#125;</code></pre><p><code>_current</code>指针指向Java字节流中当前已经读取到的位置.当class文件刚被加载时,<code>_current</code>指向当前字节流的第一个字节所在的位置,后续随着解析操作的不断进行,<code>_current</code>指针不断的往后移动,直至当前字节流最后.</p><p>根据字节码规范,该类中定义了用于读取固定字节长度的方法:</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassFileStream</span>:</span> <span class="hljs-keyword">public</span> ResourceObj &#123;......            <span class="hljs-keyword">public</span>:      ClassFileStream(<span class="hljs-keyword">const</span> u1* <span class="hljs-built_in">buffer</span>,                  <span class="hljs-keyword">int</span> length,                  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* source,                  <span class="hljs-keyword">bool</span> verify_stream = verify);        <span class="hljs-function">u2 <span class="hljs-title">get_u2_fast</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    u2 res = Bytes::get_Java_u2((address)_current);    _current += <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> res;    &#125;          <span class="hljs-function">u4 <span class="hljs-title">get_u4_fast</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;      u4 res = Bytes::get_Java_u4((address)_current);      _current += <span class="hljs-number">4</span>;      <span class="hljs-keyword">return</span> res;   &#125;       <span class="hljs-function">u8 <span class="hljs-title">get_u8_fast</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;      u8 res = Bytes::get_Java_u8((address)_current);      _current += <span class="hljs-number">8</span>;      <span class="hljs-keyword">return</span> res;   &#125;   ......&#125;</code></pre><p>除此之外也定义用于跳过固定字节码长度的常用方法,比如:<code>skip_u4_fast(int length)</code>等.在后续的字节码解析过程中,这几个方法非常常见.</p><h2 id="ClassFileParser"><a href="#ClassFileParser" class="headerlink" title="ClassFileParser"></a>ClassFileParser</h2><p>ClassFileParser负责class文件解析,并尝试创建oops.创建ClassFileParser对象后会继续调用其parse_stream()`对当前类文件的字节码流进行解析.由于class文件解析相对复杂,因此这里只介绍magic number是如何被解析出来的.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClassFileParser::parse_stream</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ClassFileStream* <span class="hljs-keyword">const</span> stream,</span></span><span class="hljs-function"><span class="hljs-params">                                   TRAPS)</span> </span>&#123;  assert(stream != <span class="hljs-literal">NULL</span>, <span class="hljs-string">"invariant"</span>);  assert(_class_name != <span class="hljs-literal">NULL</span>, <span class="hljs-string">"invariant"</span>);  <span class="hljs-comment">// BEGIN STREAM PARSING</span>  stream-&gt;guarantee_more(<span class="hljs-number">8</span>, CHECK);  <span class="hljs-comment">// magic, major, minor</span>  <span class="hljs-comment">// Magic value</span>  <span class="hljs-keyword">const</span> u4 magic = stream-&gt;get_u4_fast();  guarantee_property(magic == JAVA_CLASSFILE_MAGIC,                     <span class="hljs-string">"Incompatible magic value %u in class file %s"</span>,                     magic, CHECK);  <span class="hljs-comment">// Version numbers</span>  _minor_version = stream-&gt;get_u2_fast();  _major_version = stream-&gt;get_u2_fast();      ......      &#125;</code></pre><p>按照字节码规范,字节码前三部分依次是magic number,minor_version及major_version,分别占用u4,u2,u2,即4个字节,2个字节,2个字节,总共是8个字节,<code>guarantee_more(8, CHECK)</code>中的参数8含义就是如此:比较当前字节流文件剩余的长度是否大于想要读取的字节长度,否则报错.</p><p>校验通过后,调用stream的get_u4_fast()方法从字节码流中读取u4长度的字节序,即ClassFileStream中<code>get_u4_fast()</code>:</p><pre><code class="hljs c++"><span class="hljs-function">u4 <span class="hljs-title">get_u4_fast</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  u4 res = Bytes::get_Java_u4((address)_current);  <span class="hljs-comment">// 读取完4个字节后,需要后移_current,因此需要对其进行+4  </span>  _current += <span class="hljs-number">4</span>;  <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>在该方法中,从字节流中读取4个字节的操作由<code>Bytes::get_Java_u4((address)_current)</code>实现.其中<strong>Bytes</strong>是与CPU架构相关的类.我这边CPU采用的是x86架构,因此调用的是:</p><p><code>/OpenJDK10/hotspot/src/cpu/x86/vm/bytes_x86.hpp</code></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bytes</span>:</span> AllStatic &#123;    ......    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> u4 <span class="hljs-title">get_Java_u4</span><span class="hljs-params">(address p)</span> </span>&#123;        <span class="hljs-comment">// 调用模板方法get_Java()</span>        <span class="hljs-keyword">return</span> get_Java&lt;u4&gt;(p);     &#125;        ......         <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> T <span class="hljs-title">get_Java</span><span class="hljs-params">(<span class="hljs-keyword">const</span> address p)</span> </span>&#123;       <span class="hljs-comment">// 1.读取u4,即get_native&lt;u4&gt;(p) </span>       T x = get_native&lt;T&gt;(p);       <span class="hljs-comment">// 2.如果当前平台的字节序和Java不一样,即不是Big-Endian,需要进行转换</span>       <span class="hljs-comment">// 也就是将Little_Endian转为Big_Endian </span>       <span class="hljs-keyword">if</span> (Endian::is_Java_byte_ordering_different()) &#123;         <span class="hljs-comment">//3.大小端转换,即swap&lt;u4&gt;(x)  </span>         x = swap&lt;T&gt;(x);       &#125;       <span class="hljs-keyword">return</span> x;&#125;       &#125;</code></pre><p>在模板方法<code>get_Java()</code>先是调用与平台相关的函数<code>get_native&lt;u4&gt;()</code>来读取4个字节:</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bytes</span>:</span> AllStatic &#123;      <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> T <span class="hljs-title">get_native</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* p)</span> </span>&#123;    assert(p != <span class="hljs-literal">NULL</span>, <span class="hljs-string">"null pointer"</span>);    T x;<span class="hljs-comment">// is_aligned()用于判断当前值是否对齐与给定值,未对齐则使用memcpy从p指针出拷贝u4数据到x</span>    <span class="hljs-keyword">if</span> (is_aligned(p, <span class="hljs-keyword">sizeof</span>(T))) &#123;      <span class="hljs-comment">// 此处由于是读取u4,因此最终将指针p强转为u4*类型的指针.  </span>      x = *(T*)p;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">memcpy</span>(&amp;x, p, <span class="hljs-keyword">sizeof</span>(T));    &#125;    <span class="hljs-keyword">return</span> x;  &#125;       ......      &#125;</code></pre><p>读取完成后判断当前平台的模式是否和Java中的一致,即当前是否是大端模式,如果不是则继续调用<code>swap&lt;u4&gt;()</code>实现小端到大端的转换.</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bytes</span>:</span> AllStatic &#123;  ......        <span class="hljs-comment">// Efficient swapping of byte ordering</span>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-function"><span class="hljs-keyword">static</span> T <span class="hljs-title">swap</span><span class="hljs-params">(T x)</span> </span>&#123;    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">sizeof</span>(T)) &#123;    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">sizeof</span><span class="hljs-params">(u1)</span>: <span class="hljs-keyword">return</span> x</span>;    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">sizeof</span><span class="hljs-params">(u2)</span>: <span class="hljs-keyword">return</span> <span class="hljs-title">swap_u2</span><span class="hljs-params">(x)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">sizeof</span><span class="hljs-params">(u4)</span>: <span class="hljs-keyword">return</span> <span class="hljs-title">swap_u4</span><span class="hljs-params">(x)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">sizeof</span><span class="hljs-params">(u8)</span>: <span class="hljs-keyword">return</span> <span class="hljs-title">swap_u8</span><span class="hljs-params">(x)</span></span>;    <span class="hljs-keyword">default</span>:      guarantee(<span class="hljs-literal">false</span>, <span class="hljs-string">"invalid size: "</span> SIZE_FORMAT <span class="hljs-string">"\n"</span>, <span class="hljs-keyword">sizeof</span>(T));      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> u2   <span class="hljs-title">swap_u2</span><span class="hljs-params">(u2 x)</span></span>;                   <span class="hljs-comment">// compiler-dependent implementation</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> u4   <span class="hljs-title">swap_u4</span><span class="hljs-params">(u4 x)</span></span>;                   <span class="hljs-comment">// compiler-dependent implementation</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> u8   <span class="hljs-title">swap_u8</span><span class="hljs-params">(u8 x)</span></span>;&#125;</code></pre><p>需要注意swap_u4()是夸平台,为了兼容,可以看到在<code>/OpenJDK10/OpenJDK10/hotspot/src/os_cpu</code>根据平台进行了不同的实现,比如我这边用的是<code>/OpenJDK10/hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp</code>:</p><p><img src="https://i.imgur.com/nu15eHO.png" srcset="/img/loading.gif" alt="image-20180905154857898"></p><p>此处内嵌了一段汇编代码来实现大小端的转换.至此,我们已经清楚JVM是如何统一成大端模式的.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenJDK</tag>
      
      <tag>HotSpot</tag>
      
      <tag>Endian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenJDK系列(一):编译/调试与项目结构</title>
    <link href="/2018/06/20/OpenJDK%E7%B3%BB%E5%88%97(%E4%B8%80)_%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <url>/2018/06/20/OpenJDK%E7%B3%BB%E5%88%97(%E4%B8%80)_%E7%BC%96%E8%AF%91%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenJDK编译"><a href="#OpenJDK编译" class="headerlink" title="OpenJDK编译"></a>OpenJDK编译</h1><p>之前的基于OpenJDK8的资料由于人为因素丢失了,索性就重新来过:以OpenJDK10为例.此外,如无特殊说明,开发平台皆为MacOS.</p><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>在mac平台上,可以通过HomeBrew进行OpenJDK源码的下载,以OpenJDK10为例.由于OpenJDK的源码采用mercurial进行管理,因此需要安装mercurial,另外由于编译需要,我们同时安装ccache和freetype工具:</p><pre><code class="hljs shell">brew install mercurialbrew install install ccachebrew install freetype</code></pre><p>接下来通过以下命令正式进行下载:</p><pre><code class="hljs shell">hg clone http://hg.openjdk.java.net/jdk10/jdk10 OpenJDK10<span class="hljs-meta">#</span><span class="bash"> 进入OpenJDK10目录下执行命令</span>bash ./get_source.sh</code></pre><p><img src="https://i.imgur.com/DmElUJT.png" srcset="/img/loading.gif" alt="image-20180903153521528"></p><p>现在我们已经将所有的源码下载到本地了,接下来我们可以进行编译来满足下好奇心,</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在正式编译之前需要我们先配置编译信息,该过程通过configure.sh脚本实现,其存放在OpenJDK源码的根目录.使用该脚本需要制定一些参数参数,在mac平台下,配置如下:</p><pre><code class="hljs shell">./configure --with-target-bits=64 --with-freetype=/usr/local/Cellar/freetype/2.9.1 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs="-Xlint:deprecation -Xlint:unchecked" --disable-zip-debug-info --disable-warnings-as-errors --with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log</code></pre><p>注意不要写错freetype的路径,可以通过 brew list freetype命令来查看当前freetype的安装路径.</p><p>configure中提供了大量的参数,通过命令<code>bash ./configure --help=short</code>,当然你也可以直接查看OpenJDK<a href="http://hg.openjdk.java.net/build-infra/jdk9/raw-file/tip/README-builds.html" target="_blank" rel="noopener">的官方说明</a>,这里我们只是简单介绍几个:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>–with-target-bits</td><td>设置32为/64编译</td></tr><tr><td>–with-freetype</td><td>指定freetype目录</td></tr><tr><td>–with-jvm-variants=server,client</td><td>设置要构建的JVM的变体,目前可以选择server,client,minimal,core,zero,zeroshark,custom</td></tr><tr><td>–with-boot-jdk-jvmargs</td><td>设置运行boot JDK所需要的JVM参数,例如–with-boot-jdk-jvmargs=”-Xmx8G”</td></tr><tr><td>–with-debug-level</td><td>调试等级,目前可以指定为release,fastdebug,是slowdebug,optimized</td></tr></tbody></table><p>编译信息配置后之后,通过以下命令进行编译即可:</p><pre><code class="hljs shell">export LANG=Cmake all LOG=debug 2&gt;&amp;1 | tee make_mac_x64.log</code></pre><p>期间可能会遇到一些编译问题,<a href="https://bugs.openjdk.java.net/projects/JDK/issues/JDK-8210205?filter=allopenissues" target="_blank" rel="noopener">大多可以官网找到方法</a>,编译的产物会被存放在build目录下:</p><p><img src="https://i.imgur.com/bsLAExC.png" srcset="/img/loading.gif" alt="image-20180903161446477"></p><p>执行以下命令,验证下编译结果</p><pre><code class="hljs java">cd OpenJDK10/build/macosx-x86_64-normal-serverANDclient-slowdebug/jdk/bin./java -version</code></pre><p><img src="https://i.imgur.com/2SvqV9F.png" srcset="/img/loading.gif" alt="image-20180903161734147"></p><h1 id="OpenJDK调试"><a href="#OpenJDK调试" class="headerlink" title="OpenJDK调试"></a>OpenJDK调试</h1><p>对于OpenJDK调试而言,常用的工具有gdb和lldb,在MacOS使用更多的是lldb.直接使用lldb进行调试,相对比较原始,对于比较复杂的项目还可以借助Xcode或者CLion.</p><h2 id="Xcode调试OpenJDK"><a href="#Xcode调试OpenJDK" class="headerlink" title="Xcode调试OpenJDK"></a>Xcode调试OpenJDK</h2><p>以Xcode 9为例.</p><h3 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h3><p>首先使用Xcode创建一个新的项目OpenSDK10,为Command Line Tool类型.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuwqqejp5vj31fu10i7py.jpg" srcset="/img/loading.gif" alt="step1"></p><p>点击Next继续配置其他信息.</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuwqrgvl3uj31bk0zewvt.jpg" srcset="/img/loading.gif" alt="step2"></p><p>创建完成后,先删除默认生成的文件.</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuwqt12oqcj310m0kq7h1.jpg" srcset="/img/loading.gif" alt="step3"></p><h3 id="源码导入"><a href="#源码导入" class="headerlink" title="源码导入"></a>源码导入</h3><p> 右键OpenJDK10,选则Add Files To “OpenJDK10”,将之前用于OpenJDK10的源码根目录下的文件都添加进来.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuwqxq6eqij30u60r0kb4.jpg" srcset="/img/loading.gif" alt="step4"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuwqwpjaphj310a0pa4gn.jpg" srcset="/img/loading.gif" alt="step5"></p><p>现在我们来配置下项目.选择Product -&gt; Scheme -&gt; Edit Scheme.在左侧的Run选项中先配置info标签页中的Executable,此处指定为之前我们已经编译好的java命令,按照我们之前的编译配置,此处路径即为:</p><p><code>/OpenJDK10/build/macosx-x86_64-normal-serverANDclient-slowdebug/jdk/bin/java</code></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuwrbklw8ej316m0mm7a8.jpg" srcset="/img/loading.gif" alt="step9"></p><p>接下来继续配置Arguments标签页中的Arguments Passed On Launch.随便写的一个Hello.java文件,如下内容:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;          System.out.println(<span class="hljs-string">"Hello World !"</span>);    &#125;&#125;</code></pre><p>然后将其放在java命令所在的目录,即上述提到的<code>/OpenJDK10/build/macosx-x86_64-normal-serverANDclient-slowdebug/jdk/bin</code>中,在该目录下执行’./javac Hello.java’将其编译成class文件.</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuwr5ainy5j31he0wa7id.jpg" srcset="/img/loading.gif" alt="step8"></p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>到现在,所有的准备工作已经做好了,可以进行调试了.在main.c的<code>main()</code>打几个断点后开始调试.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuwrnvz4f4j31h6118kip.jpg" srcset="/img/loading.gif" alt="step10"></p><p>到现在已经可以正常调试了,但继续调试可能会遇到signal SIGSEGV错误</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuwrpwggqoj31ha0ysh9v.jpg" srcset="/img/loading.gif" alt="step11"></p><p>此时只需要在lldb中设置<code>(lldb) process handle SIGSEGV --stop=false</code>,然后继续调试即可.</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuwrwggk0bj31380w6aeh.jpg" srcset="/img/loading.gif" alt="step12"></p><p>不出意外,最终我们会在lldb控制台看到输出结果”<strong>Hello World !</strong> “,如下:</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuwrzyztmdj311y0qyae8.jpg" srcset="/img/loading.gif" alt="step12"></p><p>至此关于Xcode下调试OpenJDK源码的流程已经完成.</p><h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>OpenJDK源码结构如下:</p><p><img src="https://i.imgur.com/a7Nauul.png" srcset="/img/loading.gif" alt="image-20180903162039612"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>build</td><td>OpenJDK编译产物</td></tr><tr><td>common</td><td></td></tr><tr><td>corba</td><td>包含corba功能源代码</td></tr><tr><td>hotspot</td><td>包含Hotspot虚拟机实现源码</td></tr><tr><td>jaxp</td><td>jaxp功能的源代码,用于处理XML,提供了</td></tr><tr><td>jaxws</td><td>jax-ws功能的源代码,用于构建Web服务的API</td></tr><tr><td>jdk</td><td>包含Java工具包</td></tr><tr><td>langtool</td><td>语言工具的源代码如javac,javap等</td></tr><tr><td>nashorn</td><td>JavaScript引擎实现</td></tr></tbody></table><h2 id="hotspot"><a href="#hotspot" class="headerlink" title="hotspot"></a>hotspot</h2><p>jdk是我们平时开发主要关注的地方,而hotspot使我们了解虚拟机重要的目录,下面我们来了解hotspot目录,重点来看其src子目录:</p><p><img src="https://i.imgur.com/u8uWBgm.png" srcset="/img/loading.gif" alt="image-20180903163506096"></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>make</td><td>编译流程控制</td></tr><tr><td>src</td><td>VM源码</td></tr><tr><td>test</td><td>单元测试代码</td></tr></tbody></table><p>src目录下包含了有关VM实现的代码:</p><p><img src="https://i.imgur.com/lfBx8hW.png" srcset="/img/loading.gif" alt="image-20180903165531524"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>不同平台上CPU相关的代码,</p><p><img src="https://i.imgur.com/R5rhLS1.png" srcset="/img/loading.gif" alt="image-20180903164728943"></p><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><p>不同操作系统相关代码.根据不同的系统分为不同的目录</p><p><img src="https://i.imgur.com/qKECybi.png" srcset="/img/loading.gif" alt="image-20180903164636220"></p><h3 id="os-cpu"><a href="#os-cpu" class="headerlink" title="os_cpu"></a>os_cpu</h3><p>操作系统和cpu组合的相关代码.</p><p><img src="https://i.imgur.com/CGsQABh.png" srcset="/img/loading.gif" alt="image-20180903164806923"></p><h3 id="share"><a href="#share" class="headerlink" title="share"></a>share</h3><p>与具体平台无关的代码.该目录下又分为tools和vm目录.其中tools中提供了相关工具代码.vm是虚拟机实现的核心代码.</p><p><img src="https://i.imgur.com/jb7mLvj.png" srcset="/img/loading.gif" alt="image-20180903165455427"></p><h3 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h3><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>hsdis</td><td>反汇编工具</td></tr><tr><td>idealGraphVisualizer</td><td>中间代码可视化工具</td></tr><tr><td>LogCompilation</td><td>将使用-XX:LogCompiliation输出的日志格式化更容易阅读的工具</td></tr></tbody></table><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>adlc</td><td>平台描述文件的编译器</td></tr><tr><td>aot</td><td>aot编译器实现,用于静态编译</td></tr><tr><td>asm</td><td>汇编器接口</td></tr><tr><td>c1</td><td>Client编译器,即我们常说的C1编译器</td></tr><tr><td>ci</td><td>动态编译器公共接口</td></tr><tr><td>classfile</td><td>类文件处理</td></tr><tr><td>code</td><td>管理动态生成的代码</td></tr><tr><td>compiler</td><td>VM调用动态编译器的接口</td></tr><tr><td>gc</td><td>GC的实现,包含cms,g1,parallel,serial目录(对应四种GC器实现代码)以及有关GC器的公共代码实现目录shared</td></tr><tr><td>interpreter</td><td>解释器的实现,模板解释器和C++解释器</td></tr><tr><td>jvmci</td><td>JVM编译器接口</td></tr><tr><td>libadt</td><td>抽象数据结构</td></tr><tr><td>logging</td><td>VM通过日志记录系统</td></tr><tr><td>memory</td><td>内存管理相关</td></tr><tr><td>metaprogramming</td><td></td></tr><tr><td>oops</td><td>HotSpot中关于对象系统的实现</td></tr><tr><td>opto</td><td>Server编译器,即我们常说的C2编译器</td></tr><tr><td>precompiled</td><td></td></tr><tr><td>prims</td><td>VM对外接口以及jvmti(用于调试)实现</td></tr><tr><td>runtime</td><td>运行时支持库,比如线程管理,锁,反射等</td></tr><tr><td>services</td><td>支持JMX之类的管理功能的接口</td></tr><tr><td>shark</td><td>基于LLVM的JIT编译器</td></tr><tr><td>trace</td><td></td></tr><tr><td>utilities</td><td>一些工具类代码</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenJDK</tag>
      
      <tag>HotSpot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入Android辅助服务架构与设计</title>
    <link href="/2018/03/22/%E6%B7%B1%E5%85%A5Android%E8%BE%85%E5%8A%A9%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2018/03/22/%E6%B7%B1%E5%85%A5Android%E8%BE%85%E5%8A%A9%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>首先我们需要明确在整个AccessibilityService体系中共包含三个部分,其结构基本如下:</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1fyj4wv7zqrj317a0o6tco.jpg" srcset="/img/loading.gif" alt="image-20181225174719637"></p><ul><li>被监控应用端: 即我们需要监控的应用,比如微信,系统某些界面等等;</li><li>监控服务端: 用来实时接受来自被监控应用端的事件,并作出处理,即我们自行实现的AccessibilityService</li><li>AccessibilityManagerService: 由于被监控应用端和监控服务端涉涉及跨进程通信,同时它们之间又是多对多的关系,因此为了需要引入中间管理器来对两端进行管理.(为了方便起见,后续我们简称为AMS,注意不要和ActivityManagerService进行混淆)</li></ul><p>需要注意的对于被监控客户端和AMS以及监控服务端和AMS而言,都可以单独的当成C-S架构来看:对于被监控客户端和AMS: 前者是客户端Client,后者是服务端Server;对于监控服务端和AMS: 前者是客户端Client,后者是Server.</p><p>在后续的正文中,将按照 <code>监控服务端和AMS -&gt; 被监控客户端和AMS</code>的顺序来讲述,前者以AccessibilityService注册为主题,后者以AccessibilityEvnet分为为主旨.</p><h1 id="AccessibilityService注册流程"><a href="#AccessibilityService注册流程" class="headerlink" title="AccessibilityService注册流程"></a>AccessibilityService注册流程</h1><p>在AccessibilityService注册中主要涉及AMS绑定我们自定义AccessibilityService的过程.在该阶段,当AMS检测到系统中AccessibilityService状态变化后会做出相应的处理,比如检测到某个AccessibilityService被安装到系统并被用户启用后,AMS会主动绑定AccessibilityService,这和绑定远程服务的流程一样.</p><h2 id="AccessibilityService架构"><a href="#AccessibilityService架构" class="headerlink" title="AccessibilityService架构"></a>AccessibilityService架构</h2><p>在开发辅助服务时,需要我们继承AccessibilityService,那AccessibilityService到底是什么呢?首先来看一张基本结构图:</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1fyj5f0kwq7j31890u0akz.jpg" srcset="/img/loading.gif" alt="image-20181225180514185"></p><p>AccessibilityService继承自Service,也就是说它就是一个标准的服务,该服务只能由AMS进行绑定.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;         <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;        <span class="hljs-comment">// AMS主动绑定时,将返回IAccessibilityServiceClientWrapper实例</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IAccessibilityServiceClientWrapper(<span class="hljs-keyword">this</span>, getMainLooper(), <span class="hljs-keyword">new</span> Callbacks() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span> </span>&#123;                AccessibilityService.<span class="hljs-keyword">this</span>.dispatchServiceConnected();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInterrupt</span><span class="hljs-params">()</span> </span>&#123;                AccessibilityService.<span class="hljs-keyword">this</span>.onInterrupt();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;                AccessibilityService.<span class="hljs-keyword">this</span>.onAccessibilityEvent(event);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectionId, IBinder windowToken)</span> </span>&#123;                mConnectionId = connectionId;                mWindowToken = windowToken;                <span class="hljs-comment">// The client may have already obtained the window manager, so</span>                <span class="hljs-comment">// update the default token on whatever manager we gave them.</span>                <span class="hljs-keyword">final</span> WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);                wm.setDefaultToken(windowToken);            &#125;       ......                        &#125;);    &#125;        ......    &#125;</code></pre><p>不难发现AccessibilityService的<code>onBind()</code>方法中返回类型为IAccessibilityServiceClientWrapper的对象,IAccessibilityServiceClientWrapper以内部类的形式存在于AccessibilityService中,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAccessibilityServiceClientWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IAccessibilityServiceClient</span>.<span class="hljs-title">Stub</span></span><span class="hljs-class">           <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerCaller</span>.<span class="hljs-title">Callback</span> </span>&#123;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_INIT = <span class="hljs-number">1</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_INTERRUPT = <span class="hljs-number">2</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_ACCESSIBILITY_EVENT = <span class="hljs-number">3</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_GESTURE = <span class="hljs-number">4</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_CLEAR_ACCESSIBILITY_CACHE = <span class="hljs-number">5</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_KEY_EVENT = <span class="hljs-number">6</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_MAGNIFICATION_CHANGED = <span class="hljs-number">7</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_SOFT_KEYBOARD_SHOW_MODE_CHANGED = <span class="hljs-number">8</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_GESTURE_COMPLETE = <span class="hljs-number">9</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_FINGERPRINT_ACTIVE_CHANGED = <span class="hljs-number">10</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ON_FINGERPRINT_GESTURE = <span class="hljs-number">11</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ACCESSIBILITY_BUTTON_CLICKED = <span class="hljs-number">12</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DO_ACCESSIBILITY_BUTTON_AVAILABILITY_CHANGED = <span class="hljs-number">13</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HandlerCaller mCaller;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callbacks mCallback;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mConnectionId = AccessibilityInteractionClient.NO_ID;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IAccessibilityServiceClientWrapper</span><span class="hljs-params">(Context context, Looper looper,</span></span><span class="hljs-function"><span class="hljs-params">               Callbacks callback)</span> </span>&#123;           mCallback = callback;           mCaller = <span class="hljs-keyword">new</span> HandlerCaller(context, looper, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*asyncHandler*/</span>);       &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(IAccessibilityServiceConnection connection, <span class="hljs-keyword">int</span> connectionId,</span></span><span class="hljs-function"><span class="hljs-params">               IBinder windowToken)</span> </span>&#123;           Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,                   connection, windowToken);           mCaller.sendMessage(message);       &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInterrupt</span><span class="hljs-params">()</span> </span>&#123;           Message message = mCaller.obtainMessage(DO_ON_INTERRUPT);           mCaller.sendMessage(message);       &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event, <span class="hljs-keyword">boolean</span> serviceWantsEvent)</span> </span>&#123;           Message message = mCaller.obtainMessageBO(                   DO_ON_ACCESSIBILITY_EVENT, serviceWantsEvent, event);           mCaller.sendMessage(message);       &#125;.......&#125;</code></pre><p>IAccessibilityServiceClientWrapper继承自IAccessibilityServiceClient.Stub,而IAccessibilityServiceClient用来代表AccessibilityService组件.在IAccessibilityServiceClient接口中定义了暴露给AMS可操作的方法:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccessibilityServiceClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">IInterface</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">accessibilityservice</span>.<span class="hljs-title">IAccessibilityServiceClient</span> </span>&#123;        ......                     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">accessibilityservice</span>.<span class="hljs-title">IAccessibilityServiceClient</span> </span>&#123;         &#125;                ......    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(android.accessibilityservice.IAccessibilityServiceConnection connection, <span class="hljs-keyword">int</span> connectionId, android.os.IBinder windowToken)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(android.view.accessibility.AccessibilityEvent event, <span class="hljs-keyword">boolean</span> serviceWantsEvent)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInterrupt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onGesture</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gesture)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearAccessibilityCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onKeyEvent</span><span class="hljs-params">(android.view.KeyEvent event, <span class="hljs-keyword">int</span> sequence)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMagnificationChanged</span><span class="hljs-params">(android.graphics.Region region, <span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> centerX, <span class="hljs-keyword">float</span> centerY)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSoftKeyboardShowModeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> showMode)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPerformGestureResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequence, <span class="hljs-keyword">boolean</span> completedSuccessfully)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFingerprintCapturingGesturesChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> capturing)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFingerprintGesture</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gesture)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityButtonClicked</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityButtonAvailabilityChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> available)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;&#125;</code></pre><p>此外IAccessibilityServiceClientWrapper的构造函数中存在参数类型为Callbacks的回调接口.该回调接口最终会被AMS调用,其定义如下:</p><p>android.accessibilityservice.AccessibilityService.Callbacks</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callbacks</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onInterrupt</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectionId, IBinder windowToken)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onGesture</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gestureId)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onKeyEvent</span><span class="hljs-params">(KeyEvent event)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMagnificationChanged</span><span class="hljs-params">(@NonNull Region region,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">float</span> scale, <span class="hljs-keyword">float</span> centerX, <span class="hljs-keyword">float</span> centerY)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSoftKeyboardShowModeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> showMode)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPerformGestureResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequence, <span class="hljs-keyword">boolean</span> completedSuccessfully)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFingerprintCapturingGesturesChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> active)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFingerprintGesture</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gesture)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityButtonClicked</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityButtonAvailabilityChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> available)</span></span>;&#125;</code></pre><p>在AccessibilityService启用时,AMS会主动绑定该服务,并通过<code>onBind()</code>返回IAccessibilityServiceClientWrapper对象,当AMS需要与AccessibilityService通信时,就会回远程回调此处的Callbacks接口,以分发AccessibilityEvent到对应的AccessibilityService为例,此时AMS会远程回调Callbacks中的<code>onAccessibilityEvent()</code>:</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> IAccessibilityServiceClientWrapper(<span class="hljs-keyword">this</span>, getMainLooper(), <span class="hljs-keyword">new</span> Callbacks() &#123;               <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;                <span class="hljs-comment">// 事件分发</span>                AccessibilityService.<span class="hljs-keyword">this</span>.onAccessibilityEvent(event);            &#125;        ......&#125;</code></pre><p>我们发现在Callbacks的匿名实现类中,最终又调用了AccessibilityService实例中的<code>onAccessibilityEvent(event)</code>,此方法是抽象类AccessibilityService中的抽象方法,也是我们在自定义AccessibilityService时必须要重写的方法:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;......            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span></span>;        .......&#125;</code></pre><h2 id="AMS绑定AccessibilityService时机"><a href="#AMS绑定AccessibilityService时机" class="headerlink" title="AMS绑定AccessibilityService时机"></a>AMS绑定AccessibilityService时机</h2><p>和AMS启动时机一样,AccessibilityServiceManager也是由SystemServer启动,其构造函数如下:</p><p>com.android.server.accessibility.AccessibilityManagerService#AccessibilityManagerService</p><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccessibilityManagerService</span><span class="hljs-params">(Context context)</span> </span>&#123;      mContext = context;      mPackageManager = mContext.getPackageManager();      mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);      mWindowManagerService = LocalServices.getService(WindowManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      mUserManager = (UserManager) context.getSystemService(Context.USER_SERVICE);      mSecurityPolicy = <span class="hljs-keyword">new</span> SecurityPolicy();      mAppOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);      mMainHandler = <span class="hljs-keyword">new</span> MainHandler(mContext.getMainLooper());      mGlobalActionPerformer = <span class="hljs-keyword">new</span> GlobalActionPerformer(mContext, mWindowManagerService);<span class="hljs-comment">// 动态注册广播接收器</span>      registerBroadcastReceivers();      <span class="hljs-keyword">new</span> AccessibilityContentObserver(mMainHandler).register(              context.getContentResolver());  &#125;</code></pre><p>其中<code>registerBroadcastReceivers()</code>动态注册PackageMonitor类型的广播接收器.其中PackageMonitor用于监听app安装,删除,更新以及SD卡增加/移除的广播通知,然后根据这些广播通知,来决定什么时候要主动绑定某个AccessibilityService或者和某个AccessibilityService断开.比如当某个App从系统中被删除或者被强制停止时,会分别调用<code>onPackageRemoved()</code>和<code>onHandleForceStop()</code>方法,如下所示:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBroadcastReceivers</span><span class="hljs-params">()</span> </span>&#123;        PackageMonitor monitor = <span class="hljs-keyword">new</span> PackageMonitor() &#123;                        <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSomePackagesChanged</span><span class="hljs-params">()</span> </span>&#123;                ......                onUserStateChangedLocked();                ......                &#125;                        <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPackageRemoved</span><span class="hljs-params">(String packageName, <span class="hljs-keyword">int</span> uid)</span> </span>&#123;                ......                onUserStateChangedLocked();                ......            &#125;                        <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onHandleForceStop</span><span class="hljs-params">(Intent intent, String[] packages,<span class="hljs-keyword">int</span> uid, <span class="hljs-keyword">boolean</span> doit)</span> </span>&#123;               ......                onUserStateChangedLocked();               ......              &#125;                        ......        &#125;</code></pre><p>通过上述代码不难看出AccessibilityManagerService通过监听系统状态变化的广播,并决定是否调用<code>onUserStateChangedLocked()</code>来更新状态,更新的时机主要涉及以下场景:</p><ul><li>用户在系统设置界面,为某个APP开启辅助服务的时候</li><li>用户在系统设置界面,关闭某个APP辅助功能</li><li>接受到用户删除APP事件的时候</li><li>接受到某个App被强制停止</li></ul><p>接下来来看看onUserStateChangedLocked()中到底做了什么:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserStateChangedLocked</span><span class="hljs-params">(UserState userState)</span> </span>&#123;       <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove this hack</span>       mInitialized = <span class="hljs-keyword">true</span>;       updateLegacyCapabilitiesLocked(userState);       updateServicesLocked(userState);       updateAccessibilityShortcutLocked(userState);       updateWindowsForAccessibilityCallbackLocked(userState);       updateAccessibilityFocusBehaviorLocked(userState);       updateFilterKeyEventsLocked(userState);       updateTouchExplorationLocked(userState);       updatePerformGesturesLocked(userState);       updateDisplayDaltonizerLocked(userState);       updateDisplayInversionLocked(userState);       updateMagnificationLocked(userState);       updateSoftKeyboardShowModeLocked(userState);       scheduleUpdateFingerprintGestureHandling(userState);       scheduleUpdateInputFilter(userState);       scheduleUpdateClientsIfNeededLocked(userState);       updateRelevantEventsLocked(userState);       updateAccessibilityButtonTargetsLocked(userState);   &#125;</code></pre><p>上述代码中会调用很多状态更新的方法,但我们目前只关心AMS什么时候主动绑定AccessibilityService.因此先看方法<code>updateServicesLocked()</code>:</p><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateServicesLocked</span><span class="hljs-params">(UserState userState)</span> </span>&#123;      Map&lt;ComponentName, AccessibilityServiceConnection&gt; componentNameToServiceMap =              userState.mComponentNameToServiceMap;      <span class="hljs-keyword">boolean</span> isUnlockingOrUnlocked = LocalServices.getService(UserManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                  .<span class="hljs-title">isUserUnlockingOrUnlocked</span>(<span class="hljs-title">userState</span>.<span class="hljs-title">mUserId</span>)</span>;<span class="hljs-comment">// mInstalledServices表示手机中所有已经安装的AccessibilityService,</span>      <span class="hljs-comment">// 每个AccessibilityService用AccessibilityServiceInfo表示</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, count = userState.mInstalledServices.size(); i &lt; count; i++) &#123;          AccessibilityServiceInfo installedService = userState.mInstalledServices.get(i);          ComponentName componentName = ComponentName.unflattenFromString(                  installedService.getId());          AccessibilityServiceConnection service = componentNameToServiceMap.get(componentName);          <span class="hljs-comment">// Ignore non-encryption-aware services until user is unlocked</span>          <span class="hljs-keyword">if</span> (!isUnlockingOrUnlocked &amp;&amp; !installedService.isDirectBootAware()) &#123;              Slog.d(LOG_TAG, <span class="hljs-string">"Ignoring non-encryption-aware service "</span> + componentName);              <span class="hljs-keyword">continue</span>;          &#125;          <span class="hljs-comment">// Wait for the binding if it is in process.</span>          <span class="hljs-keyword">if</span> (userState.mBindingServices.contains(componentName)) &#123;              <span class="hljs-keyword">continue</span>;          &#125;          <span class="hljs-keyword">if</span> (userState.mEnabledServices.contains(componentName)                  &amp;&amp; !mUiAutomationManager.suppressingAccessibilityServicesLocked()) &#123;              <span class="hljs-comment">// 当前AccessibilityService被启用后,为其创建连接对象</span>              <span class="hljs-comment">// AccessibilityServiceConnection</span>              <span class="hljs-keyword">if</span> (service == <span class="hljs-keyword">null</span>) &#123;                  service = <span class="hljs-keyword">new</span> AccessibilityServiceConnection(userState, mContext, componentName,                          installedService, sIdCounter++, mMainHandler, mLock, mSecurityPolicy,                          <span class="hljs-keyword">this</span>, mWindowManagerService, mGlobalActionPerformer);              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userState.mBoundServices.contains(service)) &#123;                  <span class="hljs-keyword">continue</span>;              &#125;              <span class="hljs-comment">// 调用AccessibilityServiceConnection的bindLocked()方法主动连接</span>              <span class="hljs-comment">// AccessibilityService</span>              service.bindLocked();          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;                  service.unbindLocked();              &#125;          &#125;      &#125;      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = userState.mBoundServices.size();      mTempIntArray.clear();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;          <span class="hljs-keyword">final</span> ResolveInfo resolveInfo =                  userState.mBoundServices.get(i).mAccessibilityServiceInfo.getResolveInfo();          <span class="hljs-keyword">if</span> (resolveInfo != <span class="hljs-keyword">null</span>) &#123;              mTempIntArray.add(resolveInfo.serviceInfo.applicationInfo.uid);          &#125;      &#125;      <span class="hljs-comment">// Calling out with lock held, but to a lower-level service</span>      <span class="hljs-keyword">final</span> AudioManagerInternal audioManager =              LocalServices.getService(AudioManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (audioManager != <span class="hljs-keyword">null</span>) &#123;          audioManager.setAccessibilityServiceUids(mTempIntArray);      &#125;      updateAccessibilityEnabledSetting(userState);  &#125;</code></pre><p>这里面主要做了三件事情:</p><ol><li>遍历手机中所有已安装的辅助服务,这些服务信息被保存在<code>UserState.mInstalledServices</code>中;</li><li>根据componentName,在<code>mEnabledServices</code>(mEnableServices保存了所有启动的辅助服务,即AMS绑定过的AccessibilityService)里面查找enabled状态的AccessibilityService组件,如果不存在就构造一个service.这里service类型是AccessibilityServiceConnection,在AMS中,用AccessibilityServiceConnection表示AMS和某个AccessibilityService的连接.</li><li>调用service的bindLocked方法来进行真正的绑定操作</li></ol><p>其实componentName里面保存的就是AccessibilityService的packageName和className.重点来看service的<code>bindLocked()</code>操作:</p><p>com.android.server.accessibility.AccessibilityServiceConnection#bindLocked</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindLocked</span><span class="hljs-params">()</span> </span>&#123;    UserState userState = mUserStateWeakReference.get();    <span class="hljs-keyword">if</span> (userState == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> identity = Binder.clearCallingIdentity();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> flags = Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE;        <span class="hljs-keyword">if</span> (userState.mBindInstantServiceAllowed) &#123;            flags |= Context.BIND_ALLOW_INSTANT;        &#125;        <span class="hljs-comment">// 调用bindServiceAsUser()来绑定服务,其中第二个参数this类型是ServiceConnection</span>        <span class="hljs-keyword">if</span> (mService == <span class="hljs-keyword">null</span> &amp;&amp; mContext.bindServiceAsUser(                mIntent, <span class="hljs-keyword">this</span>, flags, <span class="hljs-keyword">new</span> UserHandle(userState.mUserId))) &#123;            userState.getBindingServicesLocked().add(mComponentName);        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        Binder.restoreCallingIdentity(identity);    &#125;        &#125;</code></pre><p>上述代码中最终调用<code>bindServiceAsUser()</code>来绑定AccessibilityService.绑定成功后回调ServiceConnection中的<code>onServiceConnected()</code>,即AccessibilityServiceConnection中的<code>onServiceConnected()</code>:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder service)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        <span class="hljs-comment">// 此处service即AccessibilityService中onBind()方法返回的</span>        <span class="hljs-comment">// IAccessibilityServiceClientWrapper对象</span>        <span class="hljs-keyword">if</span> (mService != service) &#123;            <span class="hljs-keyword">if</span> (mService != <span class="hljs-keyword">null</span>) &#123;                mService.unlinkToDeath(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>);            &#125;            mService = service;            <span class="hljs-keyword">try</span> &#123;                mService.linkToDeath(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>);            &#125; <span class="hljs-keyword">catch</span> (RemoteException re) &#123;                Slog.e(LOG_TAG, <span class="hljs-string">"Failed registering death link"</span>);                binderDied();                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// mServiceInterface是AccessibilityServiceConnection类型</span>        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);        UserState userState = mUserStateWeakReference.get();        <span class="hljs-keyword">if</span> (userState == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 调用AMS的addServiceLocked()方法将该Connection实例保存在mBoundServices</span>        <span class="hljs-comment">// 成员变量中</span>        userState.addServiceLocked(<span class="hljs-keyword">this</span>);        mSystemSupport.onClientChange(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">// Initialize the service on the main handler after we're done setting up for</span>        <span class="hljs-comment">// the new configuration (for example, initializing the input filter).</span>        <span class="hljs-comment">// 主线程继续调用initializeService()方法来继续完成初始化操作</span>        mMainHandler.sendMessage(obtainMessage(                AccessibilityServiceConnection::initializeService, <span class="hljs-keyword">this</span>));    &#125;&#125;</code></pre><p>不难看出其实每个AccessibilityServiceConnection都关联了对应AccessibilityService中返回的IAccessibilityServiceClientWrapper对象,即上述代码中的mService.然后将该AccessibilityServiceConnection保存在AMS中对应UserState的mBoundServices中:</p><p>com.android.server.accessibility.AccessibilityManagerService.UserState#addServiceLocked</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserState</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ArrayList&lt;AccessibilityServiceConnection&gt; mBoundServices = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addServiceLocked</span><span class="hljs-params">(AccessibilityServiceConnection serviceConnection)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!mBoundServices.contains(serviceConnection)) &#123;              serviceConnection.onAdded();              mBoundServices.add(serviceConnection);              mComponentNameToServiceMap.put(serviceConnection.mComponentName, serviceConnection);              scheduleNotifyClientsOfServicesStateChange(<span class="hljs-keyword">this</span>);          &#125;      &#125;        ......&#125;</code></pre><p>接下来继续调用<code>initializeService()</code>来完成初始化操作:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeService</span><span class="hljs-params">()</span> </span>&#123;    IAccessibilityServiceClient serviceInterface = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        UserState userState = mUserStateWeakReference.get();        <span class="hljs-keyword">if</span> (userState == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;        Set&lt;ComponentName&gt; bindingServices = userState.getBindingServicesLocked();        <span class="hljs-keyword">if</span> (bindingServices.contains(mComponentName) || mWasConnectedAndDied) &#123;            bindingServices.remove(mComponentName);            mWasConnectedAndDied = <span class="hljs-keyword">false</span>;            serviceInterface = mServiceInterface;        &#125;    &#125;    <span class="hljs-keyword">if</span> (serviceInterface == <span class="hljs-keyword">null</span>) &#123;        binderDied();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 远程调用IAccessibilityServiceClient的init()方法以便AccessibilityService所在</span>        <span class="hljs-comment">// 进程能够持有当前AccessibilityServiceConnection的代理对象</span>        serviceInterface.init(<span class="hljs-keyword">this</span>, mId, mOverlayWindowToken);    &#125; <span class="hljs-keyword">catch</span> (RemoteException re) &#123;        Slog.w(LOG_TAG, <span class="hljs-string">"Error while setting connection for service: "</span>                + serviceInterface, re);        binderDied();    &#125;&#125;</code></pre><p>最终初始化完成后,在AMS进程一端,AMS持有远程AccessibilityService中IAccessibilityServiceClientWrapper的本地代理对象,在AMS需要和AccessibilityService通信时,就会远程回调IAccessibilityServiceClientWrapper中Callbacks接口;此外AccessibilityService也持有了AMS端中对应AccessibilityServiceConnection的本地代理对象,在AccessibilityService需要和AMS通信时便会借助该代理对象.</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1fyjefsx7hlj31f00kgjt8.jpg" srcset="/img/loading.gif" alt="image-20181225231722678"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当AMS监听到一些系统状态变化时,最终会调用<code>onUserStateChangedLocked()</code>进行用户状态更新操作.在此期间会根据componentName,在mEnabledServices里面查找enabled状态的AccessibilityService组件,并为其生成对应AccessibilityServiceConnection对象,然后调用该对象的<code>bindLocked()</code>方法,在<code>bindLocked()</code>中会调用context的<code>bindServiceAsUser(mIntent...)</code>来绑定AccessibilityService.</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1fykhsbwuf4j31ko0u0qi4.jpg" srcset="/img/loading.gif" alt="image-20181226215836704"></p><h1 id="AccessibilityEvent分发"><a href="#AccessibilityEvent分发" class="headerlink" title="AccessibilityEvent分发"></a>AccessibilityEvent分发</h1><p>AccessibilityEvent代表将可能系统中产生的事件,该事件对象产生后会通过跨进程的方式传送给AMS,然后AMS继续通过跨进程的方式传递给对应AccessibilityService进程.</p><h2 id="AccessibilityEvent生成及初始化"><a href="#AccessibilityEvent生成及初始化" class="headerlink" title="AccessibilityEvent生成及初始化"></a>AccessibilityEvent生成及初始化</h2><p>当一个View想要对外发送AccessibilityEvent时,需要用到以下接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccessibilityEventSource</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eventType)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEventUnchecked</span><span class="hljs-params">(AccessibilityEvent event)</span></span>;&#125;</code></pre><p>该接口中定义了两个方法用来发送AccessibilityEvent.Android官方希望任何一个View在开始设计时都能对残疾人友好,因此选择在View来实现该接口,这样我们在View及其子类就可以方便的支持无障碍服务了.首先来看View中关于点击操作所发出的事件的流程,即<code>performClick()</code>:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Drawable</span>.<span class="hljs-title">Callback</span>, <span class="hljs-title">KeyEvent</span>.<span class="hljs-title">Callback</span>,</span><span class="hljs-class">        <span class="hljs-title">AccessibilityEventSource</span> </span>&#123;    AccessibilityDelegate mAccessibilityDelegate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performClick</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result;        <span class="hljs-keyword">final</span> ListenerInfo li = mListenerInfo;        <span class="hljs-comment">// 1.设置ClickListener的情况,先回调onClick()</span>        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-keyword">null</span>) &#123;            playSoundEffect(SoundEffectConstants.CLICK);            li.mOnClickListener.onClick(<span class="hljs-keyword">this</span>);            result = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            result = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 2.向辅助服务发送CLICKED事件</span>        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);        notifyEnterOrExitForAutoFillIfNeeded(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eventType)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mAccessibilityDelegate != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 如果已经设置了委托,则调用委托者的sendAccessibilityEvent()</span>            mAccessibilityDelegate.sendAccessibilityEvent(<span class="hljs-keyword">this</span>, eventType);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 没有设置委托的情况下,调用sendAccessibilityEventInternal()</span>            sendAccessibilityEventInternal(eventType);        &#125;    &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEventInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eventType)</span></span>&#123;        <span class="hljs-comment">// isEnabled()用来检查系统辅助功能是否开启</span>        <span class="hljs-keyword">if</span>(AccessibilityManager.getInstance(mContext).isEnabled())&#123;            <span class="hljs-comment">// 继续调用sendAccessibilityEventUnchecked()实现事件发送</span>            sendAccessibilityEventUnchecked(AccessibilityEvent.obtain(eventType))        &#125;           &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEventUnchecked</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;        <span class="hljs-comment">// 如果已经设置了委托,则调用委托者的sendAccessibilityEventUnchecked()</span>        <span class="hljs-keyword">if</span> (mAccessibilityDelegate != <span class="hljs-keyword">null</span>) &#123;            mAccessibilityDelegate.sendAccessibilityEventUnchecked(<span class="hljs-keyword">this</span>, event);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 继续调用sendAccessibilityEventUncheckedInternal()实现事件发送</span>            sendAccessibilityEventUncheckedInternal(event);        &#125;    &#125;                                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEventUncheckedInternal</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;        <span class="hljs-comment">// 1.isShown()用递归检查当前view以及其父view是否可见.如果不可见了就没必要继续处理了</span>        <span class="hljs-keyword">if</span> (!isShown()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 2.使用有关View的事件源的信息初始化AccessibilityEvent对象</span>        onInitializeAccessibilityEvent(event);        <span class="hljs-comment">// Only a subset of accessibility events populates text content.</span>        <span class="hljs-keyword">if</span> ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != <span class="hljs-number">0</span>) &#123;            dispatchPopulateAccessibilityEvent(event);        &#125;<span class="hljs-comment">// ViewRootImpl是ViewParent的实现类</span>        ViewParent parent = getParent();        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 3. 请求父View发送AccessibilityEvent,这里最终调用了ViewRootImpl的</span>            <span class="hljs-comment">// requestSendAccessibilityEvent()方法</span>            getParent().requestSendAccessibilityEvent(<span class="hljs-keyword">this</span>, event);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccessibilityDelegate</span><span class="hljs-params">(@Nullable AccessibilityDelegate delegate)</span> </span>&#123;        mAccessibilityDelegate = delegate;    &#125;&#125;</code></pre><p>在上述代码中主要做了两件事:</p><ul><li>事件生成: 指定要发送的AccessibilityEvent类型,并生成对应的AccessibilityEvent事件</li><li>事件发送: 在没有设置委托的情况下,最终调用<code>ViewRootImpl#requestSendAccessibilityEvent()</code>请求发送事件</li></ul><h3 id="事件生成"><a href="#事件生成" class="headerlink" title="事件生成"></a>事件生成</h3><p>由于系统中会产生大量的事件,如果为每个事件都创建对应AccessibilityEvent对象可能会造成GC频繁发生,进而影响整体性能,因此Google采用享元模式来实现对AccessibilityEvent对象的复用.</p><p>AccessibilityEvent.obtain()根据事件类型返回一个缓存的AccessibilityEvent实例,享元模式.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityEvent</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">//sPool是对象池</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SynchronizedPool&lt;AccessibilityEvent&gt; sPool =            <span class="hljs-keyword">new</span> SynchronizedPool&lt;AccessibilityEvent&gt;(MAX_POOL_SIZE);            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AccessibilityEvent <span class="hljs-title">obtain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eventType)</span> </span>&#123;        AccessibilityEvent event = AccessibilityEvent.obtain();        event.setEventType(eventType);        <span class="hljs-keyword">return</span> event;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AccessibilityEvent <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;        AccessibilityEvent event = sPool.acquire();        <span class="hljs-keyword">return</span> (event != <span class="hljs-keyword">null</span>) ? event : <span class="hljs-keyword">new</span> AccessibilityEvent();    &#125;    &#125;</code></pre><h3 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h3><p>在获取AccessibilityEvent对象之后接下来会用当前事件源的信息对AccessiblityEvent对象进行初始化操作.在没有设置mAccessibilityDelegate的情况下默认通过View.onInitializeAccessibilityEventInternal()进行初始化:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInitializeAccessibilityEventInternal</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;        <span class="hljs-comment">// 1.设置当前View为事件源</span>        event.setSource(<span class="hljs-keyword">this</span>);        <span class="hljs-comment">// 2.将产生该事件所在类的类名设置为AccessibilityEvent的mClassName.View的子类中通过</span>    <span class="hljs-comment">// 复写getAccessibilityClassName()来返回事件类的类名</span>        event.setClassName(getAccessibilityClassName());        <span class="hljs-comment">// 3.该事件是由那个应用产生的</span>        event.setPackageName(getContext().getPackageName());    <span class="hljs-comment">// 4.产生该事件的View是否在可用状态</span>        event.setEnabled(isEnabled());    <span class="hljs-comment">// 5.该View对应的内容概要信息,可以通过android:contentDescription来设置</span>        event.setContentDescription(mContentDescription);        <span class="hljs-keyword">switch</span> (event.getEventType()) &#123;            <span class="hljs-keyword">case</span> AccessibilityEvent.TYPE_VIEW_FOCUSED: &#123;                ArrayList&lt;View&gt; focusablesTempList = (mAttachInfo != <span class="hljs-keyword">null</span>)                        ? mAttachInfo.mTempArrayList : <span class="hljs-keyword">new</span> ArrayList&lt;View&gt;();                getRootView().addFocusables(focusablesTempList, View.FOCUS_FORWARD, FOCUSABLES_ALL);                event.setItemCount(focusablesTempList.size());                event.setCurrentItemIndex(focusablesTempList.indexOf(<span class="hljs-keyword">this</span>));                <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span>) &#123;                    focusablesTempList.clear();                &#125;            &#125; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED: &#123;                CharSequence text = getIterableTextForAccessibility();                <span class="hljs-keyword">if</span> (text != <span class="hljs-keyword">null</span> &amp;&amp; text.length() &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//设置选中字符的开始位置</span>                    event.setFromIndex(getAccessibilitySelectionStart());                    <span class="hljs-comment">//设置选中字符的结束位置</span>                    event.setToIndex(getAccessibilitySelectionEnd());                    <span class="hljs-comment">//设置选中字符的长度,为什么不把选中的文字设置过来呢?</span>                    event.setItemCount(text.length());                &#125;            &#125; <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre><p>上面的代码在View中对AccessibilityEvent对象的一些公共属性进行初始化,在View的子类可以重写此方法以便根据不同View组件来添加更多的信息.比如在TextView重写了此方法,进一步添加了事件的信息:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewTreeObserver</span>.<span class="hljs-title">onPreDrawListener</span></span>&#123;         <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInitializeAccessibilityEventInternal</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onInitializeAccessibilityEventInternal(event);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPassword = hasPasswordTransformationMethod();        event.setPassword(isPassword);        <span class="hljs-keyword">if</span> (event.getEventType() == AccessibilityEvent.TYPE_VIEW_TEXT_SELECTION_CHANGED) &#123;            event.setFromIndex(Selection.getSelectionStart(mText));            event.setToIndex(Selection.getSelectionEnd(mText));            event.setItemCount(mText.length());        &#125;    &#125;        &#125;</code></pre><h2 id="AccessibilityEvent发送到AMS"><a href="#AccessibilityEvent发送到AMS" class="headerlink" title="AccessibilityEvent发送到AMS"></a>AccessibilityEvent发送到AMS</h2><p>将AccessibilityEvent发送给AMS的具体操作最终由<code>ViewRootImpl#requestSendAccessibilityEvent</code>完成,具体流程如下:</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requestSendAccessibilityEvent</span><span class="hljs-params">(View child, AccessibilityEvent event)</span> </span>&#123;     <span class="hljs-keyword">if</span> (mView == <span class="hljs-keyword">null</span> || mStopped || mPausedForTransition) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;     &#125;     <span class="hljs-comment">// Immediately flush pending content changed event (if any) to preserve event order</span>     <span class="hljs-keyword">if</span> (event.getEventType() != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED             &amp;&amp; mSendWindowContentChangedAccessibilityEvent != <span class="hljs-keyword">null</span>             &amp;&amp; mSendWindowContentChangedAccessibilityEvent.mSource != <span class="hljs-keyword">null</span>) &#123;         mSendWindowContentChangedAccessibilityEvent.removeCallbacksAndRun();     &#125;     <span class="hljs-comment">// Intercept accessibility focus events fired by virtual nodes to keep</span>     <span class="hljs-comment">// track of accessibility focus position in such nodes.</span>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> eventType = event.getEventType();     <span class="hljs-keyword">switch</span> (eventType) &#123;         <span class="hljs-keyword">case</span> AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED: &#123;             <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sourceNodeId = event.getSourceNodeId();             <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> accessibilityViewId = AccessibilityNodeInfo.getAccessibilityViewId(                     sourceNodeId);             View source = mView.findViewByAccessibilityId(accessibilityViewId);             <span class="hljs-keyword">if</span> (source != <span class="hljs-keyword">null</span>) &#123;                 AccessibilityNodeProvider provider = source.getAccessibilityNodeProvider();                 <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) &#123;                     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> virtualNodeId = AccessibilityNodeInfo.getVirtualDescendantId(                             sourceNodeId);                     <span class="hljs-keyword">final</span> AccessibilityNodeInfo node;                     node = provider.createAccessibilityNodeInfo(virtualNodeId);                     setAccessibilityFocus(source, node);                 &#125;             &#125;         &#125; <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED: &#123;             <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sourceNodeId = event.getSourceNodeId();             <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> accessibilityViewId = AccessibilityNodeInfo.getAccessibilityViewId(                     sourceNodeId);             View source = mView.findViewByAccessibilityId(accessibilityViewId);             <span class="hljs-keyword">if</span> (source != <span class="hljs-keyword">null</span>) &#123;                 AccessibilityNodeProvider provider = source.getAccessibilityNodeProvider();                 <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) &#123;                     setAccessibilityFocus(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                 &#125;             &#125;         &#125; <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED: &#123;             handleWindowContentChangedEvent(event);         &#125; <span class="hljs-keyword">break</span>;     &#125;     <span class="hljs-comment">// mAccessibilityManager是AccessibilityManager类型实例,最终调用</span>     <span class="hljs-comment">// AccessibilityManager实例的sendAccessibilityEvent()来发送事件</span>     mAccessibilityManager.sendAccessibilityEvent(event);     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; &#125;</code></pre><p>在上述方法中首先对一些特殊类型的事件做了处理,最后调用AccessibilityManager实例的<code>sendAccessibilityEvent()</code>来向AccessibilityManagerService发送事件.</p><h3 id="AccessibilityManager创建"><a href="#AccessibilityManager创建" class="headerlink" title="AccessibilityManager创建"></a>AccessibilityManager创建</h3><p>AccessibilityManager以单例的形式存在,在其构造函数中会尝试连接AMS服务,即AccessibilityManagerService.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityManager</span> </span>&#123;    <span class="hljs-keyword">final</span> Handler.Callback mCallback;    <span class="hljs-keyword">final</span> Handler mHandler;        ...        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AccessibilityManager <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (sInstanceSync) &#123;            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId;                ......                sInstance = <span class="hljs-keyword">new</span> AccessibilityManager(context, <span class="hljs-keyword">null</span>, userId);            &#125;        &#125;        <span class="hljs-keyword">return</span> sInstance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccessibilityManager</span><span class="hljs-params">(Context context, IAccessibilityManager service, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;        mCallback = <span class="hljs-keyword">new</span> MyCallback();        mHandler = <span class="hljs-keyword">new</span> Handler(context.getMainLooper(), mCallback);        mUserId = userId;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-comment">// 尝试连接到AMS服务</span>            tryConnectToServiceLocked(service);        &#125;    &#125;    &#125;</code></pre><p>在AccessibilityManager的构造函数中,最终的的是通过<code>tryConnectToServiceLocked()</code>方法来连接AMS:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryConnectToServiceLocked</span><span class="hljs-params">(IAccessibilityManager service)</span> </span>&#123;        <span class="hljs-keyword">if</span> (service == <span class="hljs-keyword">null</span>) &#123;            IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);            <span class="hljs-keyword">if</span> (iBinder == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span>;            &#125;            service = IAccessibilityManager.Stub.asInterface(iBinder);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> userStateAndRelevantEvents = service.addClient(mClient, mUserId);            setStateLocked(IntPair.first(userStateAndRelevantEvents));            mRelevantEventTypes = IntPair.second(userStateAndRelevantEvents);            mService = service;        &#125; <span class="hljs-keyword">catch</span> (RemoteException re) &#123;            Log.e(LOG_TAG, <span class="hljs-string">"AccessibilityManagerService is dead"</span>, re);        &#125;    &#125;</code></pre><p>上述代码中首先通过ServiceManager来获取AccessibilityManagerService在本地代理对象,即IAccessibilityManager实例,在IAccessibilityManager接口中暴露了AccessibilityManagerService对外提供的方法,这是典型Binder通信过程,在系统代码中涉及多进程通信的过程基本类似.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccessibilityManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">IInterface</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">view</span>.<span class="hljs-title">accessibility</span>.<span class="hljs-title">IAccessibilityManager</span> </span>&#123;        .......    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">view</span>.<span class="hljs-title">accessibility</span>.<span class="hljs-title">IAccessibilityManager</span> </span>&#123;        .......                     <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEvent</span><span class="hljs-params">(android.view.accessibility.AccessibilityEvent uiEvent, <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;            .......        &#125;                <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">addClient</span><span class="hljs-params">(android.view.accessibility.IAccessibilityManagerClient client, <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;            ......        &#125;              .....            &#125;&#125;</code></pre><p>AccessibilityManager在获取AMS的本地代理对象IAccessibilityManager后,会继续调用IAccessibilityManager的<code>addClient()</code>方法来将mClient通过跨进程的方式传递到AccessibilityManagerService中.那mClient到底是什么呢?其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityManager</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IAccessibilityManagerClient.Stub mClient =            <span class="hljs-keyword">new</span> IAccessibilityManagerClient.Stub() &#123;            .......        &#125;&#125;</code></pre><p>不难发现这里mClient同样是Binder对象.当AccessibilityManagerService需要通知客户端一些变化时会利用到它.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccessibilityManagerClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">IInterface</span> </span>&#123;         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">view</span>.<span class="hljs-title">accessibility</span>.<span class="hljs-title">IAccessibilityManagerClient</span> </span>&#123;       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_setState = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>);   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_notifyServicesStateChanged = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">1</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_setRelevantEventTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">2</span>);                  ......                      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">view</span>.<span class="hljs-title">accessibility</span>.<span class="hljs-title">IAccessibilityManagerClient</span> </span>&#123;        .......    &#125;         &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> stateFlags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyServicesStateChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRelevantEventTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eventTypes)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;&#125;</code></pre><h3 id="AccessibilityManagerService-addClient"><a href="#AccessibilityManagerService-addClient" class="headerlink" title="AccessibilityManagerService#addClient"></a>AccessibilityManagerService#addClient</h3><p>现在回过头来看AMS中的<code>addClient()</code>中具体做了什么事?</p><p>com.android.server.accessibility.AccessibilityManagerService#addClient</p><pre><code class="hljs java"> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">addClient</span><span class="hljs-params">(IAccessibilityManagerClient callback, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;     <span class="hljs-keyword">synchronized</span> (mLock) &#123;         <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resolvedUserId = mSecurityPolicy                 .resolveCallingUserIdEnforcingPermissionsLocked(userId);         UserState userState = getUserStateLocked(resolvedUserId);<span class="hljs-comment">// 对每个请求与AccessibilityManagerService通信的客户端创建Client对象</span>         Client client = <span class="hljs-keyword">new</span> Client(callback, Binder.getCallingUid(), userState);         <span class="hljs-keyword">if</span> (mSecurityPolicy.isCallerInteractingAcrossUsers(userId)) &#123;             mGlobalClients.register(callback, client);             <span class="hljs-keyword">return</span> IntPair.of(                     userState.getClientState(),                     client.mLastSentRelevantEventTypes);         &#125; <span class="hljs-keyword">else</span> &#123;             userState.mUserClients.register(callback, client);             <span class="hljs-keyword">return</span> IntPair.of(                     (resolvedUserId == mCurrentUserId) ? userState.getClientState() : <span class="hljs-number">0</span>,                     client.mLastSentRelevantEventTypes);         &#125;     &#125; &#125;</code></pre><p> 对于每个客户端而言,即从AccessibilityManager传来的mClient对象,也就是该方法的callback参数,AccessibilityManagerService会将其封装为Client.</p><p><img src="https://tva1.sinaimg.cn/large/006tNc79ly1fz558yimelj310s0bct9o.jpg" srcset="/img/loading.gif" alt="image-20190113184139607"></p><h3 id="AccessibilityManager-sendAccessibilityEvent"><a href="#AccessibilityManager-sendAccessibilityEvent" class="headerlink" title="AccessibilityManager#sendAccessibilityEvent"></a>AccessibilityManager#sendAccessibilityEvent</h3><p>AccessibilityManager发送事件到远程服务AccessibilityManagerService,</p><p>android.view.accessibility.AccessibilityManager#sendAccessibilityEvent</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;    <span class="hljs-keyword">final</span> IAccessibilityManager service;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        <span class="hljs-comment">// 1.首先获取到AccessibilityManagerService的本地代理对象</span>        service = getServiceLocked();        <span class="hljs-keyword">if</span> (service == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 2.检查Accessibility是否启用</span>        <span class="hljs-keyword">if</span> (!mIsEnabled) &#123;            Looper myLooper = Looper.myLooper();            <span class="hljs-keyword">if</span> (myLooper == Looper.getMainLooper()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(                        <span class="hljs-string">"Accessibility off. Did you forget to check that?"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> ((event.getEventType() &amp; mRelevantEventTypes) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        userId = mUserId;    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 3.更新当前事件的时间</span>        event.setEventTime(SystemClock.uptimeMillis());        <span class="hljs-keyword">long</span> identityToken = Binder.clearCallingIdentity();        <span class="hljs-comment">// 4.最终调用了AccessibilityManagerService服务的</span>        <span class="hljs-comment">// sendAccessibilityEvent()方法将事件发送到AMS</span>        service.sendAccessibilityEvent(event, userId);        Binder.restoreCallingIdentity(identityToken);    &#125; <span class="hljs-keyword">catch</span> (RemoteException re) &#123;        Log.e(LOG_TAG, <span class="hljs-string">"Error during sending "</span> + event + <span class="hljs-string">" "</span>, re);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//释放event对象,使其重新加入对象池以便重复利用</span>        event.recycle();    &#125;&#125;</code></pre><p>在上述代码中,首先通过<code>getServiceLocked()</code>获取AccessibilityManagerService在本地的代理对象,即IAccessibilityManager的实例,其实现如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> IAccessibilityManager <span class="hljs-title">getServiceLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mService == <span class="hljs-keyword">null</span>) &#123;        tryConnectToServiceLocked(<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-keyword">return</span> mService;&#125;</code></pre><p>在该方法中最终还是借助<code>tryConnectToServiceLocked()</code>来连接AccessibilityManagerService.该方法返回的mService即之前IAccessibilityManager类型实例,也就是AMS在本地的代理对象,其真正的操作在<code>AccessibilityManagerService.sendAccessibilityEvent()</code>中,直接来看其实现:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessibilityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IAccessibilityManager</span>.<span class="hljs-title">Stub</span> </span>&#123;        ...        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> dispatchEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-keyword">if</span> (event.getWindowId() ==                AccessibilityWindowInfo.PICTURE_IN_PICTURE_ACTION_REPLACER_WINDOW_ID) &#123;                <span class="hljs-comment">// The replacer window isn't shown to services. Move its events into the pip.</span>                AccessibilityWindowInfo pip = mSecurityPolicy.getPictureInPictureWindow();                <span class="hljs-keyword">if</span> (pip != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">int</span> pipId = pip.getId();                    event.setWindowId(pipId);                &#125;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resolvedUserId = mSecurityPolicy                    .resolveCallingUserIdEnforcingPermissionsLocked(userId);            <span class="hljs-comment">// This method does nothing for a background user.</span>            <span class="hljs-keyword">if</span> (resolvedUserId == mCurrentUserId) &#123;                <span class="hljs-keyword">if</span> (mSecurityPolicy.canDispatchAccessibilityEventLocked(event)) &#123;                    mSecurityPolicy.updateActiveAndAccessibilityFocusedWindowLocked(                            event.getWindowId(), event.getSourceNodeId(),                            event.getEventType(), event.getAction());                    mSecurityPolicy.updateEventSourceLocked(event);                    dispatchEvent = <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">if</span> (mHasInputFilter &amp;&amp; mInputFilter != <span class="hljs-keyword">null</span>) &#123;                    mMainHandler.obtainMessage(                            MainHandler.MSG_SEND_ACCESSIBILITY_EVENT_TO_INPUT_FILTER,                            AccessibilityEvent.obtain(event)).sendToTarget();                &#125;            &#125;        &#125;<span class="hljs-comment">// 1.需要分发事件</span>        <span class="hljs-keyword">if</span> (dispatchEvent) &#123;            <span class="hljs-keyword">if</span> (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED                    &amp;&amp; mWindowsForAccessibilityCallback != <span class="hljs-keyword">null</span>) &#123;                WindowManagerInternal wm = LocalServices.getService(WindowManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                wm.computeWindowsForAccessibility();            &#125;            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                <span class="hljs-comment">// 2.通知对应的AccessibilityServices</span>                notifyAccessibilityServicesDelayedLocked(event, <span class="hljs-keyword">false</span>);                notifyAccessibilityServicesDelayedLocked(event, <span class="hljs-keyword">true</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span> (OWN_PROCESS_ID != Binder.getCallingPid()) &#123;            event.recycle();        &#125;    &#125;        ...&#125;</code></pre><p>dispatchEvent为true表示需要向AccessibilityService分发事件,当需要进行事件分发时,最终会调用<code>notifyAccessibilityServicesDelayedLocked()</code>:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAccessibilityServicesDelayedLocked</span><span class="hljs-params">(AccessibilityEvent event,</span></span><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">boolean</span> isDefault)</span> </span>&#123;       <span class="hljs-keyword">try</span> &#123;           UserState state = getCurrentUserStateLocked();           <span class="hljs-comment">// mBoundServices保存了所有AccessibilityService与AMS的连接</span>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, count = state.mBoundServices.size(); i &lt; count; i++) &#123;               Service service = state.mBoundServices.get(i);               <span class="hljs-keyword">if</span> (service.mIsDefault == isDefault) &#123;                   <span class="hljs-keyword">if</span> (doesServiceWantEventLocked(service, event)) &#123;                       service.notifyAccessibilityEvent(event, <span class="hljs-keyword">true</span>);                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (service.mUsesAccessibilityCache                           &amp;&amp; (AccessibilityCache.CACHE_CRITICAL_EVENTS_MASK                               &amp; event.getEventType()) != <span class="hljs-number">0</span>) &#123;                       service.notifyAccessibilityEvent(event, <span class="hljs-keyword">false</span>);                   &#125;               &#125;           &#125;       &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException oobe) &#123;                 &#125;   &#125;</code></pre><p>上述方法中的mBoundServices是AMS中的成员变量,定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ArrayList&lt;AccessibilityServiceConnection&gt; mBoundServices = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre><p>其中AccessibilityServiceConnection代表已经注册到AMS的AccessibilityService,也就是说mBoundServices保存了所有AccessibilityService与AMS的连接.比如我们自定义了一个辅助服务WXAccessibilityService,当该服务被启用时,AMS就会与该服务进行绑定,并生成对应的AccessibilityServiceConnection保存在mBoundServices中.(AccessibilityServiceConnection继承自AbstractAccessibilityServiceConnection)</p><p>在<code>notifyAccessibilityServicesDelayedLocked()</code>方法中会遍历所有的AccessibilityServiceConnection对象,并调用其<code>notifyAccessibilityEvent()</code>来通知事件发生变化:</p><p><code>com.android.server.accessibility.AbstractAccessibilityServiceConnection#notifyAccessibilityEvent</code>:</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAccessibilityEvent</span><span class="hljs-params">(AccessibilityEvent event)</span> </span>&#123;     <span class="hljs-keyword">synchronized</span> (mLock) &#123;         <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> eventType = event.getEventType();         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> serviceWantsEvent = wantsEventLocked(event);         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> requiredForCacheConsistency = mUsesAccessibilityCache                 &amp;&amp; ((AccessibilityCache.CACHE_CRITICAL_EVENTS_MASK &amp; eventType) != <span class="hljs-number">0</span>);         <span class="hljs-keyword">if</span> (!serviceWantsEvent &amp;&amp; !requiredForCacheConsistency) &#123;             <span class="hljs-keyword">return</span>;         &#125;         AccessibilityEvent newEvent = AccessibilityEvent.obtain(event);         <span class="hljs-comment">// 1.根据event创建Message对象,后续将通过Handler进行处理</span>         Message message;         <span class="hljs-keyword">if</span> ((mNotificationTimeout &gt; <span class="hljs-number">0</span>)                 &amp;&amp; (eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED)) &#123;             <span class="hljs-comment">// Allow at most one pending event</span>             <span class="hljs-keyword">final</span> AccessibilityEvent oldEvent = mPendingEvents.get(eventType);             mPendingEvents.put(eventType, newEvent);             <span class="hljs-keyword">if</span> (oldEvent != <span class="hljs-keyword">null</span>) &#123;                 mEventDispatchHandler.removeMessages(eventType);                 oldEvent.recycle();             &#125;             message = mEventDispatchHandler.obtainMessage(eventType);         &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">// Send all messages, bypassing mPendingEvents</span>             message = mEventDispatchHandler.obtainMessage(eventType, newEvent);         &#125;         message.arg1 = serviceWantsEvent ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">// 2.发送Message,最终将其切换到主线程中进行处理</span>         mEventDispatchHandler.sendMessageDelayed(message, mNotificationTimeout);     &#125; &#125;</code></pre><p>由于此处分发过程发生在Binder线程池,需要借助Handler将其切换到主线程中,即mEventDispatchHandler,简单来看该Handler的创建以及对Message的处理过程:</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAccessibilityServiceConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IAccessibilityServiceConnection</span>.<span class="hljs-title">Stub</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceConnection</span>, <span class="hljs-title">IBinder</span>.<span class="hljs-title">DeathRecipient</span>, <span class="hljs-title">KeyEventDispatcher</span>.<span class="hljs-title">KeyEventFilter</span>,</span><span class="hljs-class">        <span class="hljs-title">FingerprintGestureDispatcher</span>.<span class="hljs-title">FingerprintGestureClient</span> </span>&#123;        ......            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractAccessibilityServiceConnection</span><span class="hljs-params">(Context context, ComponentName componentName,</span></span><span class="hljs-function"><span class="hljs-params">            AccessibilityServiceInfo accessibilityServiceInfo, <span class="hljs-keyword">int</span> id, Handler mainHandler,</span></span><span class="hljs-function"><span class="hljs-params">            Object lock, SecurityPolicy securityPolicy, SystemSupport systemSupport,</span></span><span class="hljs-function"><span class="hljs-params">            WindowManagerInternal windowManagerInternal,</span></span><span class="hljs-function"><span class="hljs-params">            GlobalActionPerformer globalActionPerfomer)</span> </span>&#123;  ......        <span class="hljs-comment">// 1.创建Handler,用于切换到主线程    </span>        mEventDispatchHandler = <span class="hljs-keyword">new</span> Handler(mainHandler.getLooper()) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> eventType =  message.what;                AccessibilityEvent event = (AccessibilityEvent) message.obj;                <span class="hljs-keyword">boolean</span> serviceWantsEvent = message.arg1 != <span class="hljs-number">0</span>;                <span class="hljs-comment">// 2.事件处理</span>                notifyAccessibilityEventInternal(eventType, event, serviceWantsEvent);            &#125;        &#125;;       .......    &#125;           ......         &#125;</code></pre><p>在handleMessage()中继续调用<code>notifyAccessibilityEventInternal()</code>来将事件分发给具体的AccessibilityService.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAccessibilityEventInternal</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">              <span class="hljs-keyword">int</span> eventType,</span></span><span class="hljs-function"><span class="hljs-params">              AccessibilityEvent event,</span></span><span class="hljs-function"><span class="hljs-params">              <span class="hljs-keyword">boolean</span> serviceWantsEvent)</span> </span>&#123;          IAccessibilityServiceClient listener;          <span class="hljs-keyword">synchronized</span> (mLock) &#123;              listener = mServiceInterface;              <span class="hljs-keyword">if</span> (listener == <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-keyword">return</span>;              &#125;<span class="hljs-comment">// 1.根据eventType取出事件</span>              <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>) &#123;                  event = mPendingEvents.get(eventType);                  <span class="hljs-keyword">if</span> (event == <span class="hljs-keyword">null</span>) &#123;                      <span class="hljs-keyword">return</span>;                  &#125;                  mPendingEvents.remove(eventType);              &#125;              <span class="hljs-comment">// 2.进行权限检查,检查服务是否允许检索窗口内容</span>              <span class="hljs-keyword">if</span> (mSecurityPolicy.canRetrieveWindowContentLocked(<span class="hljs-keyword">this</span>)) &#123;                  event.setConnectionId(mId);              &#125; <span class="hljs-keyword">else</span> &#123;                  event.setSource((View) <span class="hljs-keyword">null</span>);              &#125;              event.setSealed(<span class="hljs-keyword">true</span>);          &#125;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">// 3.回调服务服务中的onAccessibityEvent()方法</span>              listener.onAccessibilityEvent(event, serviceWantsEvent);              ...          &#125; <span class="hljs-keyword">catch</span> (RemoteException re) &#123;              Slog.e(LOG_TAG, <span class="hljs-string">"Error during sending "</span> + event + <span class="hljs-string">" to "</span> + listener, re);          &#125; <span class="hljs-keyword">finally</span> &#123;              event.recycle();          &#125;      &#125;</code></pre><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>当应用界面产生AccessibilityEvent需要被发送给辅助服务时,最终会调用ViewRootImpl中的<code>requestSendAccessibilityEvent()</code>,在该方法中最终通过AccessibilityManager跨进程调用AMS的<code>sendAccessibilityEvent()</code>方法将AccessibilityEvent传递到AMS中,AMS接受到该事件后遍历所有已经注册到系统的AccessibilityService,然后再次以跨进程的方式将AccessibilityEvent发送至自定义AccessibilityService所在进程.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相比于ActivityManagerService或者PackageManagerService而言,AccessibilityServiceManager总体设计和架构都比较简单,更能加深对Binder使用的理解,同时通过简单的源码梳理,能帮助大家更有效的学习和使用辅助服务.此文拟稿与18年初,终结于19年初,一方面是向老东家360致敬,另一方面也作为新起点的标记.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AccessibilityService</tag>
      
      <tag>ViewRootImpl</tag>
      
      <tag>AccessibilityManagerService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android图形显示系统基本原理</title>
    <link href="/2017/09/12/%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E5%88%B0Android%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2017/09/12/%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E5%88%B0Android%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形显示系统"><a href="#计算机图形显示系统" class="headerlink" title="计算机图形显示系统"></a>计算机图形显示系统</h1><h2 id="人眼与帧率"><a href="#人眼与帧率" class="headerlink" title="人眼与帧率"></a>人眼与帧率</h2><p>要理解应用流程度,我们首先引入FPS这个概念.FPS是Frames Per Second,它描述的是GPU在一秒内能够渲染出静态画面的数量(一张静态图片称之为一帧),通俗点讲就是GPU每秒钟能画出多少画面.FPS是衡量GPU性能的一个重要指标,通常来说性能越强的显卡,一秒内能够渲染出静态画面的数量越多,给我们的视觉效果越好.</p><p>解释完帧率之后,我们还要具备一点生物学的知识,即需要了解视觉暂留现象.由于人眼特殊的生理结构,如果所看的画面以每秒10~12帧的速度播放时,此时我们就认为这些图片时连贯的,这种现象就是视觉暂留.在视觉暂留的基础上,如果我把一张一张的静态图像按顺序以一定的速度出现在我们眼前,此时我们大脑就会认为画面中的物体是在运动的,这就是典型动画的原理.</p><h2 id="屏幕刷新率与VSync"><a href="#屏幕刷新率与VSync" class="headerlink" title="屏幕刷新率与VSync"></a>屏幕刷新率与VSync</h2><p>FPS是描述GPU的一个重要指标,但GPU画出来的图像需要借助显示器来显示出来才能被我们所感知.与帧率相对应,显示器也有一个指标用来描述一秒内从GPU取出画面的的数量,我们称之为刷新率.</p><p>屏幕刷新率(Refresh Rate)是指屏幕每秒钟更新画面的次数,对于特定设备而言它是个常量,单位Hz.为了方便,我们采用一张图来描述其关系:</p><p><img src="https://i.imgur.com/QqVSdp2.png" srcset="/img/loading.gif" alt="image-20181127192131031"></p><p>由于帧率和刷新率分别是用于描述不同设备的指标,而这两个指标因设备不同而有所差异,换句话说这两者并不总是能保持相同的节奏,根据情况,可以分为以下三种:</p><ul><li>帧率和刷新率相等</li><li>帧率大于刷新率</li><li>帧率小于刷新率</li></ul><p>在帧率和刷新率相等的情况,GPU每画出一帧,显示器就显示一帧,但实际情况却是由于硬件不同或需要渲染的界面复杂度问题,我们很难保证帧率和刷新率一定是相等的.实际上,更多的是遇到除此之外的情况,即后两者.但其余两种情况都会或多或少的产生问题.</p><h3 id="帧率小于刷新率"><a href="#帧率小于刷新率" class="headerlink" title="帧率小于刷新率"></a>帧率小于刷新率</h3><p>在帧率小于刷新率的情况下,比如帧率是30fps,显示器刷新率是60HZ,此时我们一秒钟内看到屏幕内的画面还是更新了60次,只不过其中一些更新画面是没有变化的而已,因此该情况下由显卡输出的一张图片(一帧)实际上在显示器期内被刷新了两次而已,这种现象带给我们的就是卡顿感.</p><p><img src="https://i.imgur.com/Aif4jk3.png" srcset="/img/loading.gif" alt="image-20181128103849709"></p><h3 id="帧率大于刷新率"><a href="#帧率大于刷新率" class="headerlink" title="帧率大于刷新率"></a>帧率大于刷新率</h3><p>那对于帧率大于刷新率的情况又是如何呢?比如帧率是75fps,刷新率是100Hz,这意味在显示器更新画面的时间里,GPU描画了1+1/3的画面.这样在画面显示的时候,那个1/3的画面就会覆盖那个完整画面上部的1/3,在下次的图像刷新的时候,GPU会描画剩下来得2/3和新的2/3的画面.因为屏幕的更新只能跟上画面更新的2/3,这样图像的上部的1/3或是下部的1/3就会和剩下的画面合不上,以屏幕快速显示数字为例,在帧率和屏幕显示率一致的情况下,其效果如下:</p><p><img src="https://i.imgur.com/wuAnkzo.png" srcset="/img/loading.gif" alt="image-20181128101842907"></p><p>但在帧率大于刷新率的情况下可能出现以下现象:</p><p><img src="https://i.imgur.com/dsNKxfI.png" srcset="/img/loading.gif" alt="image-20181128101938613"></p><p>对于像上图所示的现象,我们称之为画面撕裂,即一个画面上出现了两帧画面的内容.如何解决画面撕裂问题呢?在了解其解决方案之前,得先来认识Vsync.</p><h2 id="显卡与VSync"><a href="#显卡与VSync" class="headerlink" title="显卡与VSync"></a>显卡与VSync</h2><h3 id="CRT显示器与VSync"><a href="#CRT显示器与VSync" class="headerlink" title="CRT显示器与VSync"></a>CRT显示器与VSync</h3><p>VSync(Verti Synchronization)在计算机显示系统领域是一个非常古老的名词了,通常我们将它翻译成垂直同步.VSync是显卡的一项功能,用来限制GPU绘制的帧数,使其与显示器在一秒内刷新的次数相匹配,也就是指显卡的输出帧数和屏幕的垂直刷新率相等.其实VSync本来只是CRT显示器上的概念,CRT即我们常说的模拟显示器,其显示原理是通过电子枪扫描荧光屏来显示图像的.其扫描过程是从左到右,从上到下逐行刷新的过程,前者称之为水平刷新,后者称之为垂直刷新,其流程大概如下所示:</p><p><img src="https://i.imgur.com/Vg3yPIb.png" srcset="/img/loading.gif" alt="image-20181127174542323"></p><p>假设我们现在有一个<code>4*4</code>的图片要显示在<code>4*4</code>的显示器上(单位是像素):</p><table><thead><tr><th>A1</th><th>A2</th><th>A3</th><th>A4</th></tr></thead><tbody><tr><td>B1</td><td>B2</td><td>B3</td><td>B4</td></tr><tr><td>C1</td><td>C2</td><td>C3</td><td>C4</td></tr><tr><td>D1</td><td>D2</td><td>D3</td><td>D4</td></tr></tbody></table><p>当显示器要电子枪扫描到最后一个像素D4时,显卡会发出一个VSync信号,来通知显示器已经完成一帧画面的扫描,需要回到A1开始进行下一帧的扫描.总之,这个VSync信号由显卡发出,一方面用来告诉显示器需要回到A1位置,另一方面通知显卡准备输出下一帧画面.</p><p>在LCD显示器中已经没有垂直扫描这回事了,因此VSync名字本身已经没有意义了.但是LCD仍然需要VSync信号,不然显卡就无法知道在什么时候才可以输出下一帧画面,显示器也无法知道什么时候可以开始处理一帧画面.因此这个VSync这个名称就这样沿袭下来.</p><p>现在,我们只需要记住VSync就是用来保持显卡生成帧的速度和屏幕刷新的速度一致的存在,即帧率和刷新率.比如,如果屏幕的刷新率为60Hz,那么生成显卡生成一帧画面的时间就应该固定在<code>(1/60)s</code>,即60fps.</p><h3 id="显卡工作流程"><a href="#显卡工作流程" class="headerlink" title="显卡工作流程"></a>显卡工作流程</h3><p>抛开具体实现不说,显卡的工作流程还是比较清晰的,简单点说它接受来自CPU和内存的数据,经过处理之后,生成一帧图片.循环往复,继续生成下一帧的图片,下图揭示了其工作流程:</p><p><img src="https://i.imgur.com/FUZGCaI.png" srcset="/img/loading.gif" alt="image-20181128152242597"></p><p>在上图中,需要重点注意帧缓冲器,其本质就是显存中划出来的一块区域,用于存储一帧图片每个像素点的数据,显卡会将该区域的数据依次输出到显示器中,当全部输出完毕后,会发出一个VSync信号到显示器内,如此往复.实际上,后面垂直同步,以及后面要提到双重缓存,三种缓存本质上描述的就是帧缓冲器数据输出规则.</p><p>通过上图不难发现该区域的数据是由显卡的光栅操作单元生成的,此外缓冲区采取的更新策略是”新数据覆盖老数据的”,这意味着在实际数据处理过程中,缓冲区内的数据如果没有及时被输出到显示器,该区域内的部分数据可能会被由光栅操作单元生成新数据覆盖.举个例子,假设当前帧缓冲区内已经有一帧完整的图片A,此时显卡生成了下一帧的画面B,并准备写入帧缓冲区,在写到一半的时候,收到了VSync信号,这时候缓冲区的数据被输出到显示器.糟糕的是此时缓冲区的数据是一半是A画面一半是B画面,因此我们会在显示器上由两张图片拼接出来的画面,这就是画面撕裂现象的原因,之前数字4显示不全同理.</p><p>那该如何解决该问题呢?分析上面问题的根源在于写缓冲区的的操作和VSync信号到来时机没有同步导致,如果我们让他们同步起来会如何呢?回想下我们是如何利用<code>生产者-消费者</code>解决同步问题的.现在我们来定义这么一条规则就是:当显卡生成一帧完整的图片并写入帧缓冲区后,停下来等待VSync信号的到来,接下来在继续渲染下一帧图片并写入缓冲区.这条规则能够保证帧缓冲区内始终是一帧完整图片的数据,就不会出现画面撕裂现象了.</p><p><img src="https://i.imgur.com/AVCjaPM.png" srcset="/img/loading.gif" alt="11111111"></p><h3 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h3><p>从性能角度出发,如果只对一块缓冲区进行读写无疑效率比较低下:一方面屏幕要从该区域去读,另一方面显卡要等待去写.因此在实际中,其实帧缓冲区实则被划分为两部分:</p><ul><li>前缓冲区: 用来缓存要显示到屏幕的帧数据</li><li>后缓冲区: 用来缓存显卡生成的帧数据.</li></ul><p>屏幕只能前缓冲区读取数据用于显示,显卡只能往后缓冲区写入新生成的帧数据.需要注意的是两块缓冲区并不发生实际上的数据拷贝操作,即将后缓冲区的帧数据拷贝到前缓冲区,而是在前缓冲区的帧数据已经推到屏幕上,且新的帧数据被写入到后台缓冲区后,进行指针交换操作,将原来的后缓冲区变为前缓冲区.</p><p><img src="https://i.imgur.com/S4TuSRM.png" srcset="/img/loading.gif" alt="image-20181128171645499"></p><h3 id="三缓冲机制"><a href="#三缓冲机制" class="headerlink" title="三缓冲机制"></a>三缓冲机制</h3><p>三缓冲机制是在双缓冲机制基础上发展而来,其目的是在发生卡顿时能够充分利用CPU资源,同时保证尽可能快的从卡顿现象恢复成流畅状态.更具体的解释见下文.</p><h1 id="Android显示系统"><a href="#Android显示系统" class="headerlink" title="Android显示系统"></a>Android显示系统</h1><p>在Android体系架构中,通常我们采用XML进行布局描述,CPU会对抽象的XML布局内容进行<code>Measure -&gt; Layout -&gt; Draw</code>操作,然后将其内容计算成Polygons(多边形)或Texture(纹理),GPU会对Polygons或Texture进行Rasterization(栅格化)操作,Rasterization后的数据会被写入到帧缓冲区等待显示器显示.下图描述了上述过程:</p><p><img src="https://i.imgur.com/6OskezQ.png" srcset="/img/loading.gif" alt="image-20181128173844650">和计算机显示</p><p>此外计算图形显示系统一样,Android显示系统同样会遇到屏幕刷新率和帧率一致的情况:</p><ul><li>帧率小于屏幕刷新率: 可能会导致卡顿现象</li><li>帧率大于屏幕刷新率: 可能会导致画面撕裂现象</li></ul><p>对于该问题,Android采用之前计算机系统一致的方案来解决.为了更好的了解Android是如何解决赶问题的,首先要对Android显示原理有所了解.</p><h2 id="Android显示原理"><a href="#Android显示原理" class="headerlink" title="Android显示原理"></a>Android显示原理</h2><p>从开发者的角度出发,Google抽象出View概念,因此在开发过程中我们只需要重点关注View的样子,而无需去了解图形系统底层知识.对于View而言,Activity只是Google我们抽象出来的View控制器,以便我们在此可以对View进行一些控制,比如控制View被点击后的行为,那View真正的载体是什么?</p><p>在Android中,View真正的载体是Window,即窗口(其实用视窗系统来描述Android显示系统更形象),每一个Window都包含了各自想要显示内容,不同的Window之间有层级关系,即Z-Order,用来描述Window的显示次序,其本质就是在二维坐标系<code>x-y</code>添加了Z轴,其方向为垂直于屏幕表面指向屏幕外.</p><p><img src="https://i.imgur.com/l1RiXc2.png" srcset="/img/loading.gif" alt="image-20181128180954524"></p><p>每个Window对应于一个Surface,Surface内部含有一块可供”涂鸦”的画布Canvas.在Android系统提供了WindowManagerService服务用于管理系统中所有的Window.当一个应用需要渲染UI时,WindowManagerService服务会为其创建描述其Window信息的WindowState对象,然后通过SurfaceFinger服务将需要显示的多个Surface按照Z-Order次序混合输出到FrameBuffer(帧缓冲区),接下来就是等待VSync信号到来,再显示在屏幕上.</p><h2 id="Android之Project-Butter"><a href="#Android之Project-Butter" class="headerlink" title="Android之Project Butter"></a>Android之Project Butter</h2><p>在Android 4.1之前,界面卡顿是Android中最受诟病的一点.为了解决界面卡顿问题,Google为Android引入了Project Butter计划,即常说的黄油计划.在该项目中,Google对Android显示系统进行重构,并引入了三个至关重要的改进:</p><ul><li>VSync增强: VSync不仅仅用于避免画面撕裂现象,现在它还会通知GPU在渲染下一帧之前要等待屏幕完成逐行绘制.</li><li>Triple Buffer: 三缓冲机制</li><li>Choreographer: 用于协同nimations,input和drawing一起工作</li></ul><p>需要注意的是Android中一直存在VSync机制,只不过早期VSync只是为了避免画面撕裂(screen tearing)现象.为了更好的了解增强过的VSync和Triple Buffer,我们先来看一下早期图像显示的过程,即VSync只用来避免画面撕裂的情况:</p><p><img src="https://i.imgur.com/uUscHLu.png" srcset="/img/loading.gif" alt="image-20181128230745131"></p><p>在上图中,横轴表示时间,纵轴表示Buffer的使用者,对于GPU和CPU一行中的长方形其代表的是帧缓冲,其宽度可以认为是处理该帧所需要的时长,而长方形中数字代表当前帧数.此外两个VSync信号之间间隔16.6ms.</p><p>我们从左往右开始看,开始时当前屏幕显示第0帧,CPU和GPU开始准备第1帧的数据(CPU计算第1帧的纹理后交给GPU进行栅格化),并及时计算完成,并等待下一个VSync信号后屏幕显示第1帧画面在显示第1帧画面时,CPU和GPU开始准备第2帧的数据,但由于某些原因导致系统缓慢或者画面太复杂导致第2帧数据没有在第二个VSync信号到来时准备好,显示器仍然显示理第1帧的画面.这种同一帧数据被显示多次的情况称之为”Jank”.</p><p><img src="https://i.imgur.com/3h4kzGz.png" srcset="/img/loading.gif" alt="image-20181128235257542"></p><p>不难发现早期的VSync尽管能够避免画面撕裂线程,但却无法避免Jank.</p><p>现在我们来看4.1之后,被增强过的VSync机制:GPU在渲染下一帧之前要等待屏幕完成逐行绘制,也就是每一帧处理都从接受到VSync信号开始,这样我们就可以充分利用这16.6ms.</p><p><img src="https://i.imgur.com/wUlL8ek.png" srcset="/img/loading.gif" alt="image-20181128235621846"></p><p>在上图中,时间从屏幕显示第0帧开始,CPU/GPU开始准备第1帧数据,一旦接受到下一个VSync信号,除了将原来准备好的第1帧数据显示出来,同时还会CPU/GPU还会开始准备第2帧数据…不难发现在这种情况下,CPU/GPU的工作速度和VSync保持一致,</p><p>除了增强的VSync机制,Google还采用三缓冲机制来帮助从卡段中快速恢复成流畅的状态.首先来看传统的双缓冲机制,理想情况下,其工作状态如下:</p><p><img src="https://i.imgur.com/Ixtd3d5.png" srcset="/img/loading.gif" alt="image-20181129001112405"></p><p>在上图中,以GPU一行为例,长方形A和B分别代表两块缓冲区域,分别代表前台缓冲区和后台缓冲区.开始时A作为前台缓冲区,此时GPU会想后台缓冲区B写入帧数据;当B缓冲区准备就绪后,A,B交换,B变成前台缓冲区,A变成后台缓冲区(其交换原理并不是实质的数据拷贝和转移,详见之前).</p><p>从上图看起来,一切都很流程,CPU/GPU充分利用每个16.6ms,在前一个VSync到来时开始准备数据,并在后一个VSync到来时准备好数据.但问题时,我们无法确保CPU/GPU都能在16.6ms内能够准备好数据,如下所示:</p><p><img src="https://i.imgur.com/Szc0102.png" srcset="/img/loading.gif" alt="image-20181129002236319"></p><p>还是从左边开始看起,此时进入第一个16.6ms,当前显示前台缓冲区A中的帧画面,与此同时CPU/GPU开始准备下一帧的数据.糟糕的是在下一个VSync信号到来之前,GPU未能及时准备好数据,也就是没有及时把帧数据写入到后台缓冲区B中,这种情况下后台缓冲区数据未就绪,因此不能交换前台缓冲区A和后台缓冲区B,这种情况下,显示器只能继续使用前台缓冲区A中的数据,即显示和之前相同的帧,即发生Jank.</p><p>更糟糕的是,改进后的VSync要求每一帧数据处理必须要从接受到VSync信号开始,在这种GPU未能及时在下一个VSync到来前及时完成工作的情况,CPU在后一个16.6ms内只能处于空闲状态,也就是上图第2个16.6ms内CPU一直处在空闲状态,而不是进行下一帧的处理操作.如果CPU/GPU大部分时间内都无法完成一帧数据的处理,那么就将导致连续的卡顿现象.</p><p>既然Jank难以完全避免,那如果是否能在Jank发生时充分利用CPU而不是使其处在空闲状态呢?如果能,那就可以在发生Jank后,快速恢复成流畅的状态?Google为了解决该问题,引入的三缓冲机制,即在原来双缓冲的机制上加入了第三块缓冲区.</p><p><img src="https://i.imgur.com/ni8zA7z.png" srcset="/img/loading.gif" alt="image-20181129004214237"></p><p>如上图,以CPU一行为例,共存在A,B,C三个缓冲区.在第一个VSync信号到来时,尽管A和B缓冲区都在使用中,但CPU仍然可以使用第三个缓冲区C来生成帧数据.从上图也可以看出,整个过程就在开始时Jank了一次,后续都是流畅的.这就是三缓冲区帮助Android从卡顿现象中快速恢复成流畅状态的原理.</p><p>值得注意的是,Android系统并非一直都是启用三缓冲机制,多一个缓冲区意味着消耗更多的资源.此外一个缓冲区的帧数据要想被显示到屏幕上,最终要跨越两个VSync信号,这样会让用户感觉到延迟.</p><p><img src="https://i.imgur.com/y4n7Tea.png" srcset="/img/loading.gif" alt="image-20181129005317770"></p><h3 id="VSync总结"><a href="#VSync总结" class="headerlink" title="VSync总结"></a>VSync总结</h3><p>现在关于VSync和Triple Buffer的作用已经明了,接下来总结下VSync相关的知识,首先需要知道的是在Android设备中存在两种VSync信号:</p><ul><li>由硬件VSync产生: 由硬件中断产生,是一个脉冲信号,类似CPU时钟</li><li>由软件VSync产生: 在硬件不支持的情况下,通过软件模拟产生:SurfaceFlinger会模拟该信号,并通过Binder传给Choreographer,</li></ul><p>简单描述下硬件是如何产生VSync信号:在Android启动过程中,init进程会启动SurfaceFinger进程,并执行main_surfaceflinger.cpp中的<code>main()</code>方法,在该方法的执行过程中会初始化HWComposer.而HWComposer就是基于硬件实现的VSync信号发生器,该信号用来通知SurfaceFlinger以便控制生成帧的速度.</p><h3 id="Choreographer总结"><a href="#Choreographer总结" class="headerlink" title="Choreographer总结"></a>Choreographer总结</h3><p>Choreographer被设计用来接收VSync信号(通过注册DisplayEventReceiver来接受VSync信号)的Java类,正如含义一样,它的主要工作是用来指挥和协调动画,输入和绘制的时序.如果将显示过程当做一台舞蹈剧的话,那它无疑相当于编舞者了.在Choreographer中存在FrameCallback接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FrameCallback</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span></span>;  &#125;</code></pre><p>在新一帧画面被渲染时会被会调用该接口的<code>doFrame(long frameTimeNanos)</code>方法,其参数frameTimeNanos代表该帧开始渲染时的时间.基于该接口,我们可以借助它来实现帧率检测功能.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次主要谈了计算机图形显示系统中一些概念,如帧率和屏幕刷新率,并重点分析了卡顿和画面撕裂现象的由来.此外进一步延伸到Android显示系统部分原理.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>inotify</tag>
      
      <tag>FileObserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow学习笔记(一)</title>
    <link href="/2017/05/12/TensorFlow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2017/05/12/TensorFlow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习是人工智能的一个分支，也是用来实现人工只能的一种方法。简单来说，机器学习就是通过算法，使得机器能从大量历史数据中学习规律，从而对新的样本做智能识别或对未来做预测,与传统的使用特定指令集手写软件不同，我们使用大量数据和算法来“训练”机器，由此带来机器学习如何完成任务.从1980年代末期以来，机器学习的发展大致经历了两次浪潮：浅层学习（Shallow Learning）和深度学习（Deep Learning）。</p><h3 id="浅层学习"><a href="#浅层学习" class="headerlink" title="浅层学习"></a>浅层学习</h3><p>90年代，各种各样的浅层机器学习模型相继被提出，比如SVM、Boosting、最大熵方法等。这些模型在是理论分析或者工程应用领域都获得了巨大的成功最成功的应用,比如搜索广告系统的广告点击率CTR预估、网页搜索排序、垃圾邮件过滤系统、基于内容的推荐系统等。</p><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>深度学习是实现机器学习的一种技术,现在所说的深度学习很大层次上是指神经网络。神经网络是受人类大脑的启发：神经元之间的相互连接。对比看来,人类大脑中的神经元与特定范围内的任意神经元连接，而人工神经网络中数据传播要经历不同的层，且传播方向也不同.</p><p>现在来说说在神经网络算法中,每个神经元的作用:每个神经元都会给其输入指定一个权重：相对于执行的任务该神经元的正确和错误程度。最终的输出由这些权重共同决定。</p><p><img src="https://i.imgur.com/v5aciFo.png" srcset="/img/loading.gif" alt=""></p><p>现在来看看上面提到的停止标志示例。一张停止标志图像的属性，被一一细分，然后被神经元“检查”：形状、颜色、字符、标志大小和是否运动。神经网络的任务是判断这是否是一个停止标志。它将给出一个“概率向量”，这其实是基于权重做出的猜测结果。</p><h3 id="为什么需要深度学习"><a href="#为什么需要深度学习" class="headerlink" title="为什么需要深度学习"></a>为什么需要深度学习</h3><p>浅层模型有一个重要特点，就是假设靠人工经验来抽取样本的特征，在模型的运用不出差错的前提下（如假设互联网公司聘请的是机器学习的专家），特征的好坏就成为整个系统性能的瓶颈。要发现一个好的特征，就要求开发人员对待解决的问题要有很深入的理解。</p><p>深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。换句话说,深度学习的目的是为了特征学习。</p><p>区别于传统的浅层学习，深度学习的不同在于：1. 强调了模型结构的深度，通常有5层、6层，甚至10多层的隐层节点；2. 明确突出了特征学习的重要性，也就是说，同过逐层特征变换，将样本在原空间的特征表示变换到一个新特征空间，使分类或预测更加容易。</p><p>与人工规则构造特征的方法相比，利用大数据来学习特征，更能刻画数据丰富的内在信息,目前来看,深度学习在搜索广告CRT预估,自然语言处理,图像识别,语音识别以及无人驾驶上有了广泛的应用.</p><h2 id="TensorFlow基础"><a href="#TensorFlow基础" class="headerlink" title="TensorFlow基础"></a>TensorFlow基础</h2><p>是Google开源的机器学习库,基于DistDelief进行研发的第二代人工智能系统,用来帮助我们快速的实现DL和CNN等各种算法公式,.其名字本身描述了它自身的执行原理:Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算.数据流图中的图就是我们所说的有向图,我们知道,在图这种数据结构中包含两种基本元素:节点和边.这两种元素在数据流图中有自己各自的作用.节点用来表示要进行的数学操作,另外,任何一种操作都有输入/输出,因此它也可以表示数据的输入的起点/输出的终点.边表示节点与节点之间的输入/输出关系,一种特殊类型的数据沿着这些边传递.这种特殊类型的数据在TensorFlow被称之为tensor,即张量,所谓的张量通俗点说就是多维数组.当我们向这种图中输入张量后,节点所代表的操作就会被分配到计算设备完成计算.</p><p>到现在,你应该对TensorFlow有了一个浅显的人是,下面我们再来看一张图,他会帮助你更好的认识TensorFlow工作过程.</p><p><img src="https://i.imgur.com/toP2XbB.gif" srcset="/img/loading.gif" alt=""></p><p>到现在,我们只是认识了TensorFlow,接下来我总结了TensorFlowd的四个特性,来说明我们为什么要使用TensorFlow:</p><ul><li>灵活性： 非严格的“神经网络”库。这意味这我们的计算只要能够表示为数据流图,就能够使用.</li><li>可移植性：底层核心采用C++便宜,可以运行在台式机、服务器、手机移动等设备上,提供对分布式的支持,能够快速构建深度学习集群.</li><li>多语言支持：前端支持Python,C/C++,Java以及Go,以及非官方支持的Scala,但是目前对Python接口支持最好.</li><li>高效：提供对线程、队列、异步操作支持，同时支持运行在CPU和GPU上,能够充分发挥硬件潜力.</li></ul><p>可以说正是由于以上四个特性,使得TensorFlow的使用逐渐流行开来.其中我认为tensorflow最关键的一点是允许我们将计算的过程描述为一张图(Graph),我将其称这张图为”计算图”,能让我们很容易的操作其中的网络结构.</p><p>现在我们对Tensor的特性有了基本的了解,但是如何利用TensorFlow呢?为了能够容易的理解,我用下水管道结构图来类比.</p><p>如果你是一名城市管道设计者,当你想要解决这个城市排水问题时,你会做点什么呢?(这个例子来自早期看到一位作者的解释)</p><p><img src="https://i.imgur.com/SJqc8BN.png" srcset="/img/loading.gif" alt=""></p><p>不出意外,你的脑海中隐约的浮现出管道图.如果能到这一步,说明什么呢?这意味着你已经开始触及TensorFlow领域,看吧,其实TensorFlow的工作过程我们天生就懂.</p><p>TensorFlow中的计算图就像此处的管道结构,我们考虑设计管道结构的过程就是在构建计算图.</p><p>现在来看管道中的阀门.阀门可以用来控制水流动的强度和方向,这和神经网络中的权重和偏移的作用一致.唯一的不同是,管道中阀门需要人为调整,而神经网络的”阀门”会根据数据自我调整/更新.</p><p>我们知道在管道中是水在流动,那么计算图流动的是什么呢?<br>计算图流动的就是我们上文说到的tensor,tensor本质上就是多维数组.(其实每一个tensor包含又一个静态类型,一个rank和一个shape,关于这点我们就不做解释了,有兴趣的同学可以查阅相关paper)</p><p>和管道不同,在计算图中,我们可以从任意一个节点处取出”液体”,也就是获得当前tensor.</p><p>现在,我们来个稍微正规点的解释:</p><blockquote><p>TensorFlow使用Graph来描述计算任务,图中的节点被称之为op.一个op可以接受0或多个tensor作为输入,也可产生0或多个tensor作为输出.任何一个Graph要想运行,都必须借助上下文Session.通过Session启动Graph,并将Graph中的op分发到CPU或GPU上,借助Session提供执行这些op.op被执行后,将产生的tensor返回.借助Session提供的feed和fetch操作,我们可以为op赋值或者获取数据.计算过程中,通过变量(Variable)来维护计算状态.</p></blockquote><p>为了方便大家理解TensorFlow中相关的概念,这里我列了一张表格:</p><table><thead><tr><th>类型</th><th>描述</th><th>用途</th></tr></thead><tbody><tr><td>Session</td><td>会话</td><td>图必须在称之为“会话”的上下文中执行。会话将图的op分发到诸如CPU或者GPU上计算</td></tr><tr><td>Graph</td><td>描述计算过程</td><td>必须在Session中启动</td></tr><tr><td>tensor</td><td>数据</td><td>数据类型之一,代表多维数组</td></tr><tr><td>op</td><td>操作</td><td>图中的节点被称之为op，一个op获得0或者多个Tensor，执行计算，产生0或者多个Tensor</td></tr><tr><td>Variable</td><td>变量</td><td>数据类型之一,运行过程中可以被改变,用于维护状态</td></tr><tr><td>feed</td><td>赋值</td><td>为op的tensor赋值</td></tr><tr><td>fetch</td><td>取值</td><td>从op的tensor中取值</td></tr><tr><td>Constant</td><td>常量</td><td>数据类型之一,不可变</td></tr></tbody></table><h2 id="TensorFlow环境"><a href="#TensorFlow环境" class="headerlink" title="TensorFlow环境"></a>TensorFlow环境</h2><p>TensorFlow目前支持三种平台:Linux系列,Mac OS以及Window.并提供了多种安装方式,目前常见的安装方式有三种:pip,docker,Anacona,和源码编译安装.TensorFlow支持CPU计算和GPU计算:</p><ul><li><strong>CPU 支持 :</strong>系统没有 NVIDIA CUDA® GPU，我们只能安装该版本。</li><li><strong>GPU 支持:</strong> TensorFlow 程序通常在 GPU 比在 CPU 上运行快得多。如果系统具有 NVIDIA CUDA GPU 那么可以安装该版本</li></ul><p>为了方便,这里只演示CPU.更多的资料你可以在<a href="https://www.tensorflow.org" target="_blank" rel="noopener">TensorFlow官网</a>官网上找到答案.</p><h3 id="window上通过安装"><a href="#window上通过安装" class="headerlink" title="window上通过安装"></a>window上通过安装</h3><p>在开始之前首先确保我们安装了python3.</p><pre><code class="hljs shell">pip3 install tensorflowpip3 install tensorflow-gpupip3 install tensorlayer //上面二选一,后安装tensorlayer,也可以不装</code></pre><p>一般来说,你会遇到以下两个错误:</p><p>错误1:</p><pre><code class="hljs plain">   return importlib.import_module(mname)                                        File &quot;C:\Users\liudongdong-iri\AppData\Local\Programs\Python\Python35\lib\impoib\__init__.py&quot;, line 126, in import_module                                       return _bootstrap._gcd_import(name[level:], package, level)                  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import                 File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load              File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked     File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked              File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec            File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module      File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed  mportError: DLL load failed: 找不到指定的模块。</code></pre><p>错误2:</p><pre><code class="hljs plain">File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removedImportError: DLL load failed: 找不到指定的模块。</code></pre><p>此时只需要下载<a href="https://www.microsoft.com/en-us/download/details.aspx?id=53587" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=53587</a> 安装后重新使用pip命令安装.</p><h3 id="Mac-OS-X-通过pi安装"><a href="#Mac-OS-X-通过pi安装" class="headerlink" title="Mac OS X 通过pi安装"></a>Mac OS X 通过pi安装</h3><p>在mac上通过pip来安装,python 2.7和python 3.3+二者选一即可</p><pre><code class="hljs plain">pip install tensorflow</code></pre><p>如果是python3使用以下命令:</p><pre><code class="hljs plain">pip3 install tensorflow</code></pre><p>注意:如果在之前安装过TensorFlow&lt;0.71的版本,首先要使用pip uninstall卸载TensorFlow以及protobuf.</p><h3 id="检测安装"><a href="#检测安装" class="headerlink" title="检测安装"></a>检测安装</h3><p>在安装成功后,先来运行个简单Hello,TensorFlow程序一睹风采:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfhello = tf.constant(<span class="hljs-string">'Hello,TensorFlow'</span>)sess = tf.Session()print(sess.run(hello))</code></pre><p>不出意外,我们将看到如下输出:</p><pre><code class="hljs plain">Hello,TensorFlow</code></pre><h2 id="TensorFlow实践"><a href="#TensorFlow实践" class="headerlink" title="TensorFlow实践"></a>TensorFlow实践</h2><p>上面我们简单的介绍了TensorFlow的工作原理以及相关的概念,接下来呢,我们从实践的角度触发,来进一步解释相关概念,在这之前先来说明构建TensorFlow程序的基本过程.,通常分为两步:构建阶段和一个执行阶段。在构建阶段，我们组织多个op,最终形成Graph。在执行阶段，使用会话执行op.</p><p>先来看个简单的示例,来大体有个了解:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-comment"># 定义‘符号’变量，也称为占位符</span>a = tf.placeholder(<span class="hljs-string">"int32"</span>)b = tf.placeholder(<span class="hljs-string">"int32"</span>)<span class="hljs-comment"># 构造一个op节点</span>y = tf.multiply(a, b)<span class="hljs-comment"># 建立会话</span>sess = tf.Session()<span class="hljs-comment"># 运行会话，输入数据，并计算节点，同时打印结果</span>print(sess.run(y, feed_dict=&#123;a: <span class="hljs-number">3</span>, b: <span class="hljs-number">3</span>&#125;))<span class="hljs-comment"># 任务完成, 关闭会话.</span>sess.close()</code></pre><h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><p>构造阶段的主要目的是为了构建一张计算图.构建图的第一步是创建源op.源op不需要任何输入,源op的输出被传递给其他op作为输入.例如常量(Constant).Python 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入..在TensorFlow中存在一个默认图(defalut graph).op构造器可以为其增加节点.很多时候我们会直接使用该图,可以通过<code>tf.Graph.as_default()</code>来获取.</p><h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>Graph:要组装的结构,由许多操作组成,其中的每个连接点代表一种操作</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>tf.Graph.as_graph_def()</td><td>返回一个图的序列化的GraphDef,表示序列化的GraphDef可以导入到另外一个图(使用<code>import_graph_def()</code>)</td></tr><tr><td>tf.Graph.get_operations()</td><td>返回图中的操作节点列表</td></tr><tr><td>tf.Operation.name</td><td>操作节点op的名称</td></tr><tr><td>tf.Operation.type</td><td>操作节点op的类型</td></tr><tr><td>tf.Operation.inputs</td><td>操作节点的输入与输出</td></tr><tr><td>tf.Operation.run(session=None,feed_dict=None)</td><td>在会话中执行该操作</td></tr><tr><td>tf.add_to_collection(name,value)</td><td>基于默认的图,其功能便为Graph.add_to_collection()</td></tr><tr><td>tf.get_collection(key,scope=None)</td><td>基于默认的图,其功能便为Graph.get_collection()</td></tr></tbody></table><h4 id="op"><a href="#op" class="headerlink" title="op"></a>op</h4><p>op:接受（流入）零个或多个输入（液体），返回（流出）零个或多个输出</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型:主要分为tensor,variable,constant.</p><p>tensor:多维array或list</p><pre><code class="hljs python"><span class="hljs-comment"># 创建</span>tensor_name=tf.placeholder(type, shape, name)</code></pre><p>variable:通常可以将一个统计模型中的参数表示为一组变量。例如，你可以将一个神经网络的权重当作一个tensor存储在变量中。在训练图的重复运行过程中去更新这个tensor</p><pre><code class="hljs python"><span class="hljs-comment"># 创建变量</span>name_variable = tf.Variable(value, name)<span class="hljs-comment"># 初始化单个变量</span>init_op=variable.initializer()<span class="hljs-comment"># 初始化所有变量</span>init_op=tf.initialize_all_variables()<span class="hljs-comment"># 更新操作</span>update_op=tf.assign(variable to be updated, new_value)</code></pre><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>这里我们来创建一个包含三个op的图,其中两个constant op,一个matmul op.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-comment"># 创建作为第一个常量op,该op会被加入到默认的图中</span><span class="hljs-comment"># 1*2的矩阵,构造器的返回值代表该常量op的返回值</span>matrix_1 = tf.constant([[<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>]])<span class="hljs-comment"># 创建第二个常量op,该op会被加入到默认的图中</span><span class="hljs-comment"># 2*1的矩阵</span>matrix_2 = tf.constant([[<span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>]])<span class="hljs-comment"># 创建第三个op,为矩阵乘法op,接受matrix_1和matrix_2作为输入,product代表乘法矩阵结果</span>product = tf.matmul(matrix_1, matrix_2)</code></pre><p>到现在我们已经创建好了包含三个op的图.下面我们要通启动该图,执行运算.</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>在实现上, TensorFlow 将图形定义转换成分布式执行的操作, 以充分利用可用的计算资源(如 CPU 或 GPU). 一般你不需要显式指定使用 CPU 还是 GPU, TensorFlow 能自动检测. 如果检测到 GPU, TensorFlow 会尽可能地利用找到的第一个 GPU 来执行操作. 但是今天我们暂时不关注该部分.</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>首先我们需要创建一个Session对象.在不传参数的情况下,该Session的构造器将启动默认的图.之后我们可以通过Session对象的<code>run(op)</code>来执行我们想要的操作.</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>tf.Session.run(fetches,feed-dict=Noe,options=Node,run_metadata=None)</td><td>运行fetches中的操作节点并求其</td></tr><tr><td>tf.Session.close()</td><td>关闭会话</td></tr><tr><td>tf.Session.graph</td><td>返回加载该会话的图()</td></tr><tr><td>tf.Session.as_default()</td><td>设置该对象为默认会话,并返回一个上下文管理器</td></tr></tbody></table><h3 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code class="hljs python"><span class="hljs-comment"># 创建会话</span>sess = tf.Session()<span class="hljs-comment"># 赋值操作</span>sess.run([output], feed_dict=&#123;input1:value1, input2:value1&#125;)<span class="hljs-comment"># 用创建的会话执行操作</span>sess.run(op)<span class="hljs-comment"># 取值操作</span><span class="hljs-comment"># 关闭会话</span>sess.close()</code></pre><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>最终结合构建阶段和执行阶段,完整代码如下:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-comment"># 创建作为第一个常量op,该op会被加入到默认的图中</span><span class="hljs-comment"># 1*2的矩阵,构造器的返回值代表该常量op的返回值</span>matrix_1 = tf.constant([[<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>]])<span class="hljs-comment"># 创建第二个常量op,该op会被加入到默认的图中</span><span class="hljs-comment"># 2*1的矩阵</span>matrix_2 = tf.constant([[<span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>]])<span class="hljs-comment"># 创建第三个op,为矩阵乘法op,接受matrix_1和matrix_2作为输入,product代表乘法矩阵结果</span>product = tf.matmul(matrix_1, matrix_2)<span class="hljs-comment"># 获取sess</span>sess = tf.Session()<span class="hljs-comment"># 来执行矩阵乘法op</span>result = sess.run(product)<span class="hljs-comment"># 输出矩阵乘法结果</span>print(<span class="hljs-string">"result:"</span>,result)<span class="hljs-comment"># 任务完毕,关闭Session</span>sess.close()</code></pre><p>除了通过Session的close()的手动关闭外,也可以使用with代码块:</p><pre><code class="hljs python"><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:result=sess.run(product)print(<span class="hljs-string">"result:"</span>,result)</code></pre><p>现在来运行该代码,不出意外我们将获得结果:</p><pre><code class="hljs plain">result: [[ 12.]]</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>通过上面的过程,我们只需要了解了tensorflow的构建过程和执行过程,进一步了解了Graph,op以及Session各自所担当的职责,但是仍然有很多点我们无法一一细聊.</p><p>为了方便起见,这里我将对一些概念再次进行解释.</p><h4 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h4><p>在TensorFlow中,用tensor来表示其所使用的数据结构,简单点理解tensor就是一个多维数组.任何一个物体,我们都可以用几个特征来描述它.每个特征可以划分成一个维度.比如:一小组图像集表示为一个四维浮点数数组, 这四个维度分别是 [batch, height,width, channels]. </p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>tf.Tensor.dtype</td><td>tensor中数据类型</td></tr><tr><td>tf.Tensor.name</td><td>tensor名称</td></tr><tr><td>tf.Tensor.op</td><td>产生该tensor的op</td></tr><tr><td>tf.Tensor.graph</td><td>该tensor所在的</td></tr></tbody></table><h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>TensorFlow使用Variables来维护图执行过程中的状态信息.下面我们演示一个计数器:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-comment"># 创建一个变量,初始化为0</span>state = tf.Variable(<span class="hljs-number">0</span>, name=<span class="hljs-string">"counter"</span>)<span class="hljs-comment"># 创建一个常量</span>one = tf.constant(<span class="hljs-number">1</span>)new_value = tf.add(state, one)update = tf.assign(state, new_value)<span class="hljs-comment"># 变量初始化</span>init_op = tf.initialize_all_variables()sess = tf.Session()<span class="hljs-comment"># 运行init_op</span>sess.run(init_op)<span class="hljs-comment"># 运行state,打印state初始值</span>print(sess.run(state))<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    sess.run(update)    print(sess.run(state))</code></pre><p>执行该程序,不出意外输出结果:</p><pre><code class="hljs plain">012345678910</code></pre><h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>为了获取操作输出的内容,可以在使用Session对象的<code>run(op)</code>时,传入一些tensor,这些tensor用来取回我们想要的结果.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfvalue_1 = tf.constant(<span class="hljs-number">3.0</span>)value_2 = tf.constant(<span class="hljs-number">2.0</span>)value_3 = tf.constant(<span class="hljs-number">5.0</span>)<span class="hljs-comment"># 2.0+5.0</span>temp_value=tf.add(value_2,value_3)<span class="hljs-comment"># 3.0+(2.0+5.0)</span>result=tf.add(value_1,temp_value)sess = tf.Session()print(sess.run([temp_value,result]))</code></pre><h4 id="Feed"><a href="#Feed" class="headerlink" title="Feed"></a>Feed</h4><p>我们可以通过TensorFlow对象的<code>placeholder()</code>为变量创建指定数据类型占位符,在执行<code>run(op)</code>时通过feed_dict来为变量赋值.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span>  tfinput_1 = tf.placeholder(tf.float32)input_2 = tf.placeholder(tf.float32)output = tf.add(input_1, input_2)<span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:    <span class="hljs-comment"># 通过feed_dict来输入,outpu表示输出</span>    print(sess.run([output],feed_dict=&#123;input_1:[<span class="hljs-number">7.</span>],input_2:[<span class="hljs-number">2.</span>]&#125;))</code></pre><h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>TensorFlow提供一种占位符操作,在执行时需要为其提供数据.这有点类似我们编写sql语句时使用?占位符一样,你可以理解为预编译.</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>tf.placeholder(dtype,shape=None,name=None)</td><td>为一个tensor插入一个占位符</td></tr></tbody></table><pre><code class="hljs plain">input_value &#x3D; tf.placeholder(tf.float32,shape&#x3D;(1024,1024))</code></pre><h4 id="模型保存于恢复"><a href="#模型保存于恢复" class="headerlink" title="模型保存于恢复"></a>模型保存于恢复</h4><p>在tensorflow中最简单的保存与加载模型的方式是通过Saver对象.</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>tf.train.Saver.save(sess,save_path,global_step=None,latest_filename=None,meta_graph_suffix=’meta’,write_meta_graph=True)</td><td>保存变量</td></tr><tr><td>tf.train.Saver.restore(sess,save_path)</td><td>恢复变量</td></tr><tr><td>tf.train.Saver.last_checkpoints()</td><td>列出最近未删除的checkpoint文件名</td></tr><tr><td>tf.train.Saver.set_last_checkpoints(last_checkpoints)</td><td>设置checkpoint文件名列表</td></tr><tr><td>tf.train.Saver.set_last_checkpoints_with_time(last_checkpoints_with_time)</td><td>设置checkpoint文件名列表和时间戳</td></tr></tbody></table><p>保存模型</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_model</span><span class="hljs-params">()</span>:</span>    v1 = tf.Variable(tf.random_normal([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]), name=<span class="hljs-string">"v1"</span>)    v2 = tf.Variable(tf.random_normal([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), name=<span class="hljs-string">"v2"</span>)    init_op = tf.global_variables_initializer()    saver = tf.train.Saver()    <span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:        sess.run(init_op)        saver_path = saver.save(sess, <span class="hljs-string">"./model.ckpt"</span>)        print(<span class="hljs-string">"model saved in file: "</span>, saver_path)</code></pre><p>加载模型</p><p>用同一个Saver对象来恢复变量，注意，当你从文件恢复变量是，不需要对它进行初始化，否则会报错。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span><span class="hljs-params">()</span>:</span>    v1 = tf.Variable(tf.random_normal([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]), name=<span class="hljs-string">"v1"</span>)    v2 = tf.Variable(tf.random_normal([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), name=<span class="hljs-string">"v2"</span>)    saver = tf.train.Saver()    <span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:        saver.restore(sess,<span class="hljs-string">"./model.ckpt"</span>)        print(<span class="hljs-string">"mode restored"</span>)</code></pre><h2 id="移植TensorFlow到移动设备"><a href="#移植TensorFlow到移动设备" class="headerlink" title="移植TensorFlow到移动设备"></a>移植TensorFlow到移动设备</h2><p>由于TensorFlow核心代码使用C++编写的,因此我们可以很容易的将其移植到移动设备中,一般需要经过以下几步:</p><ol><li>PC训练模型,并将其保存为pb格式,然后导入该模型文件到Android项目的assets目录中</li><li>导入TensorFlow的jar包以及so文件到Android项目中,jar包向我们暴露了操作接口,具体的执行引擎算法责备封装在so文件当中</li><li>定义相关变量,存储数据,并通过jar包提供的接口加载模型,执行运算即可.</li></ol><p>下面我们用个简单的示例来演示整个移植的过程.</p><h3 id="1-训练模型"><a href="#1-训练模型" class="headerlink" title="1. 训练模型"></a>1. 训练模型</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfsess = tf.Session()matrix_1 = tf.constant([<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>], name=<span class="hljs-string">'input'</span>)add = tf.add(matrix_1, matrix_1, name=<span class="hljs-string">'output'</span>)sess.run(add)output_graph_def = tf.graph_util.convert_variables_to_constants(sess, sess.graph_def, output_node_names=[<span class="hljs-string">'output'</span>])<span class="hljs-comment"># 保存模型到目录下的model文件夹中</span><span class="hljs-keyword">with</span> tf.gfile.FastGFile(<span class="hljs-string">'./model/tensorflow_matrix_graph.pb'</span>,mode=<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:    f.write(output_graph_def.SerializeToString())sess.close()</code></pre><p>唯一注意的一点是务必要保成pb格式的文件:</p><ol><li>不能使用 tf.train.write_graph()保存模型，该种方式只是保存了模型的结构，并不保存训练完毕的参数值 </li><li>不能使用 tf.train.saver()保存模型，该种方式只是保存了网络中的参数值，并不保存模型的结构。 </li></ol><p>我们需要的是既保存模型的结构，又保存模型中每个参数的值,所以上述的两种方式都不行:因此我们用一下方式保存:</p><pre><code class="hljs python"><span class="hljs-comment"># 可以把整个sesion当作常量都保存下来，通过output_node_names参数来指定输出</span>graph_util.convert_variables_to_constants<span class="hljs-comment"># 指定保存文件的路径以及读写方式</span>tf.gfile.FastGFile(<span class="hljs-string">'model/test.pb'</span>, mode=<span class="hljs-string">'wb'</span>)<span class="hljs-comment"># 将固化的模型写入到文件</span>f.write(output_graph_def.SerializeToString())</code></pre><h3 id="2-编译所需要的jar和so文件"><a href="#2-编译所需要的jar和so文件" class="headerlink" title="2.编译所需要的jar和so文件"></a>2.编译所需要的jar和so文件</h3><p>这里以Mac OS X平台为例,你可以可以在linux平台编译,目前不支持window平台编译.</p><ol><li>首先克隆 TensorFlow 仓库到本地:</li></ol><pre><code class="hljs plain">$ git clone --recurse-submodules https:&#x2F;&#x2F;github.com&#x2F;tensorflow&#x2F;tensorflow</code></pre><p><code>--recurse-submodules</code> 参数是必须得, 用于获取 TesorFlow 依赖的 protobuf 库.</p><ol start="2"><li>安装Bazel</li></ol><p>Bazel是Google开源的一款自动化构建工作,TensorFlow整个工程就是通过它进行构建.其安装过程也非常简单如果你和我一样使用macOS构建,那么我们可以通过包管理器Homebrew来安装Bazel</p><pre><code class="hljs plain">brew install bazel</code></pre><p>安装之后可以通过<code>bazel version</code>来查看其版本,比如当前我这里是:</p><pre><code class="hljs shell">Build label: 0.4.5-homebrewBuild target: bazel-out/local-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jarBuild time: Thu Mar 16 13:37:54 2017 (1489671474)Build timestamp: 1489671474Build timestamp as int: 1489671474</code></pre><p>在需要升级的时候可以通过<code>brew upgrade bazel</code>.如果你要在其他平台安装,查阅官网:<a href="https://bazel.build/versions/master/docs/install-os-x.html" target="_blank" rel="noopener">https://bazel.build/versions/master/docs/install-os-x.html</a></p><p>接下来,我们需要修改TensorFlow项目的WORKSPACE文件:</p><p><img src="https://i.imgur.com/X4v1ner.png" srcset="/img/loading.gif" alt=""></p><p>修改前:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Uncomment and update the paths <span class="hljs-keyword">in</span> these entries to build the Android demo.</span><span class="hljs-meta">#</span><span class="bash">android_sdk_repository(</span><span class="hljs-meta">#</span><span class="bash">    name = <span class="hljs-string">"androidsdk"</span>,</span><span class="hljs-meta">#</span><span class="bash">    api_level = 23,</span><span class="hljs-meta">#</span><span class="bash">    <span class="hljs-comment"># Ensure that you have the build_tools_version below installed in the </span></span><span class="hljs-meta">#</span><span class="bash">    <span class="hljs-comment"># SDK manager as it updates periodically.</span></span><span class="hljs-meta">#</span><span class="bash">    build_tools_version = <span class="hljs-string">"25.0.2"</span>,</span><span class="hljs-meta">#</span><span class="bash">    <span class="hljs-comment"># Replace with path to Android SDK on your system</span></span><span class="hljs-meta">#</span><span class="bash">    path = <span class="hljs-string">"&lt;PATH_TO_SDK&gt;"</span>,</span><span class="hljs-meta">#</span><span class="bash">)</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"> Android NDK r12b is recommended (higher may cause issues with Bazel)</span><span class="hljs-meta">#</span><span class="bash">android_ndk_repository(</span><span class="hljs-meta">#</span><span class="bash">    name=<span class="hljs-string">"androidndk"</span>,</span><span class="hljs-meta">#</span><span class="bash">    path=<span class="hljs-string">"&lt;PATH_TO_NDK&gt;"</span>,</span><span class="hljs-meta">#</span><span class="bash">    <span class="hljs-comment"># This needs to be 14 or higher to compile TensorFlow. </span></span><span class="hljs-meta">#</span><span class="bash">    <span class="hljs-comment"># Note that the NDK version is not the API level.</span></span><span class="hljs-meta">#</span><span class="bash">    api_level=14)</span></code></pre><p>根据本机情况来设置正确的SDK和NDK路径.</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Uncomment and update the paths <span class="hljs-keyword">in</span> these entries to build the Android demo.</span>android_sdk_repository(    name = "androidsdk",    api_level = 23,    # Ensure that you have the build_tools_version below installed in the     # SDK manager as it updates periodically.    build_tools_version = "25.0.2",    # 修改为自己系统SDK路径    path = "/Users/liudongdong/Library/Android/sdk/",)<span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash"> Android NDK r12b is recommended (higher may cause issues with Bazel)</span>android_ndk_repository(    name="androidndk",<span class="hljs-meta">#</span><span class="bash"> 修改为自己系统NDK路径</span>    path="/Users/liudongdong/Library/Android/ndk/",    # This needs to be 14 or higher to compile TensorFlow.     # Note that the NDK version is not the API level.    api_level=14)</code></pre><p>先编译so文件</p><pre><code class="hljs shell">bazel build -c opt //tensorflow/contrib/android:libtensorflow_inference.so --crosstool_top=//external:android/crosstool --host_crosstool_top=@bazel_tools//tools/cpp:toolchain --cpu=armeabi-v7a</code></pre><p>生成的so文件位于tensorflow目录下:</p><pre><code class="hljs plain">bazel-bin&#x2F;tensorflow&#x2F;contrib&#x2F;android&#x2F;libtensorflow_inference.so</code></pre><p>再编译jar文件</p><pre><code class="hljs plain">bazel build &#x2F;&#x2F;tensorflow&#x2F;contrib&#x2F;android:android_tensorflow_inference_java</code></pre><p>生成的jar文件位于:</p><pre><code class="hljs plain">bazel-bin&#x2F;tensorflow&#x2F;contrib&#x2F;android&#x2F;libandroid_tensorflow_inference_java.jar</code></pre><blockquote><p>需要注意一点:在编译出so文件后要及时地将其拷贝出来,因为在编译jar文件的时候会将上面编译出的so文件删除.</p></blockquote><h3 id="3-移植模型到Android设备"><a href="#3-移植模型到Android设备" class="headerlink" title="3.移植模型到Android设备"></a>3.移植模型到Android设备</h3><ol><li><p>将pb模型文件放入assets目录</p></li><li><p>添加jar包到项目的libs目录下,添加so文件到jniLibs目录下:</p></li></ol><p><img src="https://i.imgur.com/T7zFHS2.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>定义变量,然后初始化tensorflow,调用相关api.同样,我们以刚才生成的tensorflow_matrix_graph.pb为例:</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-comment">// 定义模型文件路径</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_FILE = <span class="hljs-string">"file:///android_asset/tensorflow_matrix_graph.pb"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEIGHT=<span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WIDTH =<span class="hljs-number">2</span>;    <span class="hljs-comment">// 输入</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String inputName = <span class="hljs-string">"input"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span>[] inputs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[HEIGHT * WIDTH];        <span class="hljs-comment">// 输出</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String outputName = <span class="hljs-string">"output"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span>[] outputs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[HEIGHT * WIDTH];        <span class="hljs-comment">//tensorflow接口</span>    TensorFlowInferenceInterface mTensorFlowInferenceInterface;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_number);        findViewById(R.id.btn_matrix).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                <span class="hljs-keyword">float</span>[] result = getResult();                Toast.makeText(NumberActivity.<span class="hljs-keyword">this</span>, result[<span class="hljs-number">0</span>] + <span class="hljs-string">"  "</span> + result[<span class="hljs-number">1</span>], Toast.LENGTH_SHORT).show();            &#125;        &#125;);        mTensorFlowInferenceInterface = <span class="hljs-keyword">new</span> TensorFlowInferenceInterface(getAssets(), MODE_FILE);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span>[] getResult() &#123;        inputs[<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;        inputs[<span class="hljs-number">1</span>]=<span class="hljs-number">3</span>;        Trace.beginSection(<span class="hljs-string">"feed"</span>);        <span class="hljs-comment">// 输入数据</span>        mTensorFlowInferenceInterface.feed(inputName, inputs, WIDTH, HEIGHT);        Trace.endSection();        Trace.beginSection(<span class="hljs-string">"run"</span>);        String[] outputNames = <span class="hljs-keyword">new</span> String[]&#123;outputName&#125;;        <span class="hljs-comment">// 执行数据</span>        mTensorFlowInferenceInterface.run(outputNames);        Trace.endSection();        Trace.beginSection(<span class="hljs-string">"fetch"</span>);        <span class="hljs-comment">// 取出数据</span>        mTensorFlowInferenceInterface.fetch(outputName,outputs);        Trace.endSection();        <span class="hljs-keyword">return</span> outputs;    &#125;&#125;</code></pre><p>至此已经完成.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>TensorFlow</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AsyncTask设计与实现</title>
    <link href="/2017/04/05/AsyncTask%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2017/04/05/AsyncTask%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="AsyncTask基础"><a href="#AsyncTask基础" class="headerlink" title="AsyncTask基础"></a>AsyncTask基础</h1><p>AsyncTask是Android系统提供的轻量级异步任务类.在Android 1.6之前,其内部是串行任务,Android1.6之后起修改为并行任务,由于并行任务会引入并发问题,因此 Android 3.0重新提供对串行任务提供了支持.之后,AsyncTask默认是串行任务,但可以通过方法<code>executeOnExecutor()</code>指定为并行任务.</p><p>AysncTask是个抽象的泛型类,它提供了Params,Progress和Result三个泛型参数分别用来表示输入参数类型,后台任务执行进度类型以及任务的输出结果类型,如不需要可以将参数类型指定为Void.此外AsyncTask提供以下四个方法用于通知调用者任务状态:</p><ul><li><code>onPreExecute()</code>:通知后台任务开始,工作在主线程.</li><li><code>doInBackground(Params...params)</code>:在后台线程池中执行任务.在该方法中可以通过<code>publishProgress()</code>来更新任务进度,它最终会导致onProgressUpdate()的调用.</li><li><code>onProgressUpdate(Progress...values)</code>:后台任务进度改变时被执行(即<code>publishProgress()</code>调用后),工作在主线程</li><li><code>onPostExecute(Result result)</code>:任务的执行结果通过该方法通知调用者,result是后台任务的返回结果,即<code>doInBackground()</code>的返回值.同样,该方法工作在主线程</li></ul><p>除此之外,AsyncTask也提供了用来取消任务的方法,此时会回调<code>onCancelled()</code>.在使用时我们需要继承该类,并实现其中的相关方法.需要注意AsyncTask对象需要在主线程创建,其执行方法<code>execute()</code>,<code>executeOnExecutor()</code>也需在主线程调用;同一个AsyncTask对象只能被执行一次,否则会报错.</p><h1 id="AsyncTask原理"><a href="#AsyncTask原理" class="headerlink" title="AsyncTask原理"></a>AsyncTask原理</h1><p>.AsyncTask的整体实现非常简单,其内部提供了两个线程池:SerialExecutor和自定义的Excutor分别用任务排队和真正的执行任务.除此之外,其内部实现了对任务的封装.就其设计而言,重要的是任务的封装以及SerialExecutor,整个AsyncTask建立在这两者之上.</p><h2 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h2><p>通过AsyncTask的构造过程来看其内部任务的定义.在其构造过程会首先关联主线程的Handler,用于实现线程切换,这也是方法onProgressUpdate()工作在主线程的原因.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>,<span class="hljs-title">Progress</span>,<span class="hljs-title">Result</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>((Looper) <span class="hljs-keyword">null</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>(handler != <span class="hljs-keyword">null</span> ? handler.getLooper() : <span class="hljs-keyword">null</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">(Looper callbacklooper)</span></span>&#123;       <span class="hljs-comment">//1.关联主线程的Handler</span>       mHandler = callbackLooper == <span class="hljs-keyword">null</span> || callbackLooper == Looper.getMainLooper()            ? getMainHandler()            : <span class="hljs-keyword">new</span> Handler(callbackLooper);   <span class="hljs-comment">//2.创建mWorker用于真正执行任务,为了能拿到任务的执行结果,WorkerRunnable实现自Callback接口而非</span>       <span class="hljs-comment">//Runnable</span>        mWorker = <span class="hljs-keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//2.1 标记为任务已经被执行过,mTaskInvoked为AtomicBoolean类型</span>                mTaskInvoked.set(<span class="hljs-keyword">true</span>);                Result result = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//2.2 将当前任务线程的优先级设置为THREAD_PRIORITY_BACKGROUND,以便</span>                    <span class="hljs-comment">//影响主线程的执行效率,即不抢夺主线程的cpu资源</span>                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                    <span class="hljs-comment">//2.3 调用doInBackground()执行我们自定义的后台任务,并拿到其返回结果</span>                    result = doInBackground(mParams);                    <span class="hljs-comment">//2.4 在你能确保后续操作是会阻塞很长时间时,调用该命令将会促使Kernal释放已经</span>                    <span class="hljs-comment">//挂起对象的引用,能够减少进程资源的占用</span>                    Binder.flushPendingCommands();                &#125; <span class="hljs-keyword">catch</span> (Throwable tr) &#123;                    <span class="hljs-comment">//2.5 任务执行期间出现异常,将其标记为被取消状态</span>                    mCancelled.set(<span class="hljs-keyword">true</span>);                    <span class="hljs-keyword">throw</span> tr;                &#125; <span class="hljs-keyword">finally</span> &#123;                    postResult(result);                &#125;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;;        <span class="hljs-comment">// 将mWorker封装为FutreTask对象</span>        mFuture = <span class="hljs-keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    postResultIfNotInvoked(get());                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    android.util.Log.w(LOG_TAG, e);                &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"An error occurred while executing doInBackground()"</span>,                            e.getCause());                &#125; <span class="hljs-keyword">catch</span> (CancellationException e) &#123;                    postResultIfNotInvoked(<span class="hljs-keyword">null</span>);                &#125;            &#125;        &#125;;     &#125;&#125;</code></pre><p>以上代码中最核心的两个对象是mWorker和mFuture.mWorker是WorkerRunnable的实例,是AsyncTask中真正用于工作的任务对象,为了能拿到任务的执行结构,WorkerRunnable实现了Callable接口而非Runnable接口,其定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerRunnable</span>&lt;<span class="hljs-title">Params</span>, <span class="hljs-title">Result</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Result</span>&gt; </span>&#123;    Params[] mParams;&#125;</code></pre><p>在mWorker的<code>call()</code>方法中,真正用于执行后台任务的<code>doInBackground()</code>会被调用.</p><p>mWorker对象创建完成后,会继续创建mFuture对象,mFuture是FutureTask的直接子类(匿名内部类形式)的对象,其构造方法接受mWorker作为参数.而FutureTask是java并发包中的类.其实现了RunnableFuture接口,而RunnableFuture又继承自Runnable和Future接口,因此不难猜出FutureTask既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值(当然实际上也确实如此)。最终这个mWorker会被放入到线程池中执行.</p><p>上述过程简单点说就是我们自定义的后台操作最终被封装在mFuture中.执行mFuture就是执行我们自定义的后台操作.可以说,对于AsyncTask的实现而言最重要的就是mWoker和mFuture对象的创建.关于AsyncTask中任务的实现至此已经明了,接下来需要关注AsyncTask是串行和并行的原理.</p><h2 id="串行任务"><a href="#串行任务" class="headerlink" title="串行任务"></a>串行任务</h2><p>Android 3.0之后,使用AsyncTask的execute()执行任务时,默认是串行操作,即任务一个接一个的执行,下面我们通过代码的来揭示AsyncTask是如何实现串行任务的.正常情况下,在创建AsyncTask实例后,我们会通过以下方法执行任务:</p><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">execute</span><span class="hljs-params">(Params... params)</span> </span>&#123;     <span class="hljs-keyword">return</span> executeOnExecutor(sDefaultExecutor, params); &#125;</code></pre><p>在该方法中调用<code>executeOnExecutor(Executor exec,Params... params)</code>来继续执行操作:</p><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">executeOnExecutor</span><span class="hljs-params">(Executor exec,</span></span><span class="hljs-function"><span class="hljs-params">            Params... params)</span> </span>&#123;        <span class="hljs-comment">//1. 检查任务状态</span>        <span class="hljs-keyword">if</span> (mStatus != Status.PENDING) &#123;            <span class="hljs-keyword">switch</span> (mStatus) &#123;                <span class="hljs-keyword">case</span> RUNNING:                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                            + <span class="hljs-string">" the task is already running."</span>);                <span class="hljs-keyword">case</span> FINISHED:                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                            + <span class="hljs-string">" the task has already been executed "</span>                            + <span class="hljs-string">"(a task can be executed only once)"</span>);            &#125;        &#125;        <span class="hljs-comment">//2.正常情况下,将任务状态设置为RUNNING</span>        mStatus = Status.RUNNING;<span class="hljs-comment">//3.后台任务执行前调用.由于executeOnExecutor()在主线程被调用,因此onPreExecute()也在主线程</span>        onPreExecute();<span class="hljs-comment">//4.将我们传入给的params参数赋值给mWorker的mParam成员变量.</span>        mWorker.mParams = params;        <span class="hljs-comment">//5.提交任务到线程池中开始执行</span>        exec.execute(mFuture);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;</code></pre><p>需要注意,一个AsyncTask对象执行过execute()方法后,其任务状态会被设置为RUNNING状态.当AsyncTask对象的当前状态为RUNNING或者FINISHED时,再次调用其execute()方法将会抛出异常.这也是之前我们说同一个AsyncTask实例只能执行一次的原因.</p><p>通过上述代码我们可以看到任务对象mFuture最终会被线程执行器exec执行.此时exec被赋值为sDefaultExecutor,而sDefaultExecutor的定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>,<span class="hljs-title">Progress</span>,<span class="hljs-title">Result</span>&gt;</span>&#123;    ...    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor SERIAL_EXECUTOR = <span class="hljs-keyword">new</span> SerialExecutor();    ...            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;        ...&#125;</code></pre><h3 id="SerialExecutor"><a href="#SerialExecutor" class="headerlink" title="SerialExecutor"></a>SerialExecutor</h3><p>SerialExecutor是AsyncTask中自定义的执行器,其内部引入了ArrayDeque用于保存任务队列:</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;    <span class="hljs-comment">// mTask用于保存任务</span>    <span class="hljs-keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable r)</span> </span>&#123;        <span class="hljs-comment">// 1.保存新添加进来的任务到mTasks</span>        mTasks.offer(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    r.run();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 当前任务执行完成后,通过scheduleNext()安排执行下个任务</span>                    scheduleNext();                &#125;            &#125;        &#125;);        <span class="hljs-comment">// 2.当前没有任务在执行,通过通过scheduleNext()安排执行下个任务</span>        <span class="hljs-keyword">if</span> (mActive == <span class="hljs-keyword">null</span>) &#123;            scheduleNext();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 懂ArrayDeque的队首取出新任务</span>        <span class="hljs-keyword">if</span> ((mActive = mTasks.poll()) != <span class="hljs-keyword">null</span>) &#123;            THREAD_POOL_EXECUTOR.execute(mActive);        &#125;    &#125;&#125;</code></pre><p>SerialExecutor中存在ArrayDeque类型的成员变量mTasks,其被用来保存任务队列.</p><blockquote><p>ArrayDeque是基于循环数组实现的双端队列,其<code>offer()</code>操作用来在队尾添加元素,而<code>poll()</code>用来取出并删除队首的元素.</p></blockquote><p>当SerialExecutor实例的<code>execute()</code>执行时首先会通过<code>offer()</code>保存新任务到mTasks中,保存完成后如果当前没用正在执行的任务就通过<code>scheduleNext()</code>安排执行下个任务.此外在当前任务执行完成后,也会通过<code>scheduleNext()</code>来继续执行下个任务.<code>scheduleNext()</code>中做的唯一一件事就是从mTasks中取出一个任务,然后交给THEAD_POOL_EXECUTOR线程池执行.小结</p><p>简单总结下新加入的任务首先会通过SerialExecutor保存在双端队列的队尾,然后从队首取出任务交给THREAD_POOL_EXECUTOR线程池来执行.虽然THREAD_POOL_EXECUTOR支持多个任务同时执行,但是由于SerialExecutor只会在一个任务执行完成后才会从双端队列中取出新任务并放到线程池中执行,因此此时任务的执行都是串行的.</p><h2 id="线程池定义"><a href="#线程池定义" class="headerlink" title="线程池定义"></a>线程池定义</h2><p>THREAD_POOL_EXECUTOR是AsyncTask中自定义的线程池对象,核心线程数根据实际情况设置,最少2个,最多不超过4个.最大线程数是CPU核数*2+1,默认非核心线程存活时间为30秒,其完整定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>, <span class="hljs-title">Progress</span>, <span class="hljs-title">Result</span>&gt;</span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="hljs-number">2</span>, Math.min(CPU_COUNT - <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> KEEP_ALIVE_SECONDS = <span class="hljs-number">30</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadFactory sThreadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger mCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);       <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">"AsyncTask #"</span> + mCount.getAndIncrement());       &#125;    &#125;;       <span class="hljs-keyword">static</span> &#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,                sPoolWorkQueue, sThreadFactory);        threadPoolExecutor.allowCoreThreadTimeOut(<span class="hljs-keyword">true</span>);        THREAD_POOL_EXECUTOR = threadPoolExecutor;    &#125;        ...&#125;</code></pre><h2 id="并行任务"><a href="#并行任务" class="headerlink" title="并行任务"></a>并行任务</h2><p>上面我们提到AsyncTask存在线程池THREAD_POOL_EXECUTOR,只不过由于之前每次提交一个任务到该线程池中导致任务无法并行.在此情况下要想实现任务并行操作就非常简单了,只需要将多个任务直接提交给该线程池执行即可.AsyncTask的中提供的<code>executeOnExecutor()</code>就是如此,在使用时直接调用该方法并指定参数exec为AsyncTask.THREAD_POOL_EXECUTOR任务执行器即可.(当然我们这里也可以自定义新的Executor)</p><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">executeOnExecutor</span><span class="hljs-params">(Executor exec,</span></span><span class="hljs-function"><span class="hljs-params">            Params... params)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mStatus != Status.PENDING) &#123;            <span class="hljs-keyword">switch</span> (mStatus) &#123;                <span class="hljs-keyword">case</span> RUNNING:                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                            + <span class="hljs-string">" the task is already running."</span>);                <span class="hljs-keyword">case</span> FINISHED:                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                            + <span class="hljs-string">" the task has already been executed "</span>                            + <span class="hljs-string">"(a task can be executed only once)"</span>);            &#125;        &#125;        mStatus = Status.RUNNING;             onPreExecute();        mWorker.mParams = params;        exec.execute(mFuture);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到现在关于AsyncTask的分析就结束了,从实际使用来说AsyncTask在设计上略有不错,使用起来仍然比较麻烦,且受限于一些场景.在Android发展初期,AsyncTask备受青睐,现在随着整个Android开发生态的发展,AsyncTask越来越少用了.但通过AsyncTask我们仍然能重温有关线程池设计/线程使用的哪些知识点.</p><p><img src="https://i.imgur.com/1eIGFDJ.png" srcset="/img/loading.gif" alt="image-20181010204003807"></p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>AsyncTask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从JVM内存模型到线程安全</title>
    <link href="/2017/02/28/%E4%BB%8EJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2017/02/28/%E4%BB%8EJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>对于开发者来说,存储器的层次结构应该是非常熟悉的,大体如下:<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft3yzhjyprj31c40m0n2c.jpg" srcset="/img/loading.gif" alt="mage-20180709221719"></p><p>其中寄存器,L1,L2,L3都被封装在CPU芯片中,作为应用开发者而言我们很少去注意和使用它.之所以引入L1,L2,L3高速寄存器,其根本是为了解决访问运算器和内存速度不匹配.但缓存的引入也带来两个问题:</p><ol><li>缓存命中率:缓存的数据都是主存中数据的备份,如果指令所需要的数据恰好在缓存中,我们就说缓存命中,反之,需要从主存中获取.一个好的缓存策略应该尽可能的提高命中率,如何提高却是一件非常困难的事情.</li><li>缓存一致性问题:我们知道缓存是主存数据的备份,但每个核心都有自己的缓存,当缓存中的数据和内存中的数据不一致时,应该以谁的数据为准呢,这就是所谓缓存一致性问题.</li></ol><p>上面只是展示存储器的层次结构,现在我们来更形象的来看一下CPU芯片与内存之间联系,以Intel i5双核处理器为例:<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ft3yzva43oj317u0t6n1z.jpg" srcset="/img/loading.gif" alt="mage-20180709221745"></p><p>通过上图我们能明显的看出各个缓存之间的联系,在随后的JVM内存模型剖析中,你同样会发现类似的结构.关于存储器层次结构到这里已经足够,毕竟我们不是专门做操作系统的,下面我们来聊聊主存,更确切的说抽象的虚拟内存.</p><hr><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>谈起内存的时候,每个人的脑海中都会呈现出内存条的形象,在很多时候,这种实物给我们对内存最直观的理解,对于非开发者这么理解是可以接受的,但是对于从事开发开发工作的工程师而言,我们还要加深一点.</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft3z0mhuiwj31120rg7oo.jpg" srcset="/img/loading.gif" alt="mage-20180709221829"></p><p>从硬件的角度来看,内存就是一块有固定容量的存储体,与该硬件直接打交道的是我们的操作系统.我们知道系统的进程都是共享CPU和内存资源的,现代操作系统为了更有效的管理内存,提出了内存的抽象概念,称之为虚拟内存.换言之,我们在操作系统中所提到的内存管理谈的都是虚拟内存.虚拟内存的提出带来几个好处:</p><ol><li>虚拟内存将主存看成是一个存储在磁盘上的地址空间的告诉缓存.应用在未运行之前,只是存储在磁盘上二进制文件,运行后,该应用才被复制到主存中.</li><li>它为每个进程提供了一致的地址空间,简化了内存管理机制.简单点来看就是每个进程都认为自己独占该主存.最简单的例子就是一栋楼被分成许多个房间,每个房间都是独立,是户主专有,每个户主都可以从零开始自助装修.另外,在未征得其他户主的同意之前,你是无法进入其他房间的.</li></ol><p>虚拟内存的提出也改变了内存访问的方式.之前CPU访问主存的方式如下:<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ft3z12sx74j310w0kadha.jpg" srcset="/img/loading.gif" alt="mage-20180709221855"><br>上图演示了CPU直接通过物理地址(假设是2)来访问主存的过程,但如果有了虚拟内存之后,整个访问过程如下:<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft3z1obmsej31b40mqjtl.jpg" srcset="/img/loading.gif" alt="mage-20180709221929"><br> CPU给定一个虚拟地址,然后经过MMU(内存管理单元,硬件)将虚拟地址翻译成真正的物理地址,再访问主存.比如现在虚拟地址是4200经过MMU的翻译直接变成真正的物理地址2.</p><p>这里来解释下什么是虚拟内存地址.我们知道虚拟内存为每个进程提供了一个假象:每个进程都在独占地使用主存,每个进程看到的内存都是一样的,这称之为虚拟地址空间.举个例子来说,比如我们内存条是1G的,即最大地址空间$2^{10}$,这时某个进程需要4G的内存,那么操作系统可以将其映射成更大的地址空间$2^{32}$,这个地址空间就是所谓的虚拟内存地址.关于如何映射,有兴趣的可以自行学习.用一张图来抽象的表示:</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft3z27imlyj31060w476e.jpg" srcset="/img/loading.gif" alt="mage-20180709222000">到现在我们明白原来原来我们所谈操作系统中谈的内存其实是虚拟内存,如果你是C语言开发者,那对此的感受可能更深.既然每个进程都拥有自己的虚拟地址空间,那么它的布局是如何的呢?以Linux系统为例,来看一下它的进程空间地址的布局:<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ft3z2tgcdsj319m0s6q76.jpg" srcset="/img/loading.gif" alt="mage-20180709222035"></p><p>到现在为止,我们终于走到了进程这一步.我们知道,每个JVM都运行在一个单独的进程当中,和普通应用不同,JVM相当于一个操作系统,它有着自己的内存模型.下面,就切入到JVM的内存模型中.</p><hr><h1 id="并发模型-线程"><a href="#并发模型-线程" class="headerlink" title="并发模型(线程)"></a>并发模型(线程)</h1><p>如果java没有多线程的支持,没有JIT的存在,那么也不会有现在JVM内存模型.为什么这么说呢?首先我们从JIT说起,JIT会追踪程序的运行过程,并对其中可能的地方进行优化,其中有一项优化和处理器的乱序执行类似,不过这里叫做指令重排.如果没有多线程,也就不会存在所谓的临界资源,如果这个前置条件不存在当然也就不会存在资源竞争这一说法了.这样一来,可能Java早已经被抛弃在历史的长河中.</p><p>尽管Java语言不像C语言能够直接操作内存,但是掌握JVM内存模型仍然非常重要.对于为什么要掌握JVM内存模型得先从Java的并发编程模型说起.</p><p>在并发模型中需要处理两个关键问题:线程之间如何通信以及线程之间如何同步.所谓的通信指的是线程之间如何交换消息,而同步则用于控制不同线程之间操作发生的相对顺序.</p><p>从实现的角度来说,并发模型一般有两种方式:基于共享内存和基于消息传递.两者实现的不同决定了通信和同步的行为的差异.在基于共享内存的并发模型中,同步是显示的,通信是隐式的;而在基于消息传递的并发模型中,通信是显式的,同步是隐式的.我们来具体解释一下.</p><p>在共享内存的并发模型中,任何线程都可以公共内存进行操作,如果不加以显示同步,那么执行顺序将是不可知的,也恰是因为哪个线程都可以对公共内存操作,所以通信是隐式的.而在基于消息传递的并发模型中,由于消息的发送一定是在接受之前,因此同步是隐式的,但是线程之间必须通过明确的发送消息来进行通信.</p><p>在最终并发模型选择方案上,java选择基于共享内存的并发模型,也就是显式同步,隐式通信.如果在编写程序时,不处理好这两个问题,那在多线程会出现各种奇怪的问题.因此,对任何Java程序员来说,熟悉JVM的内存模型是非常重要的.</p><hr><h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>对于JVM内存,主要包含两方面:JVM内存结构和JVM内存模型.两者之间的区别在于模型是一种协议,规定对特定内存或缓存的读写过程,千万不要弄混了.</p><p>很多人往往对JVM内存结构和进程的内存结构感到困惑,这里我将帮助你梳理一下.</p><p>JVM本质上也是一个程序,只不过它又有着类似操作系统的特性.当一个JVM实例开始运行时,此时在Linux进程中,其内存布局如下:<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft3z3l00t3j31ag0k4ael.jpg" srcset="/img/loading.gif" alt="mage-20180709222120"></p><p>JVM在进程堆空间的基础上再次进行划分,来简单看一下.此时的永生代本质上就是Java程序程序的代码区和数据区,而年轻代和老年代才是Java程序真正使用的堆区,也就是我们经常挂在嘴边的.但是此时的堆区和进程上的堆却又很大的区别:在调用C程序的malloc函数时,会引起一次系统级的调用;在使用free函数释放内存时,同样也会引起一次系统级的调用,但是JVM中堆区并非如此:JVM一次性向系统申请一块连续的内存区域,作为Java程序的堆,当Java程序使用new申请内存时,JVM会根据需要在这段内存区域中为其分配,而不需要除非一次系统级别的调用.可以看出JVM其实自行实现了一条堆内存的管理机制,这种管理方式有以下好处:</p><ol><li>减少系统级别的调用.大部分内存申请和回首不需要触发系统函数,仅仅只在Java堆大小发生变化时才会引起系统函数的调用.相比系统级别的调用,JVM实现内存管理成本更低.</li><li>减少内存泄漏情况的发生.通过JVM接管内存管理过程,可以避免大多情况下的内存泄漏问题.</li></ol><p>现在已经简单介绍了JVM内存结构,希望这样能帮助你打通上下.当然,为了好理解,我省略了其中一些相对不重要的点,如有兴趣可以自行学习.讲完了JVM内存结构,下一步该是什么呢?</p><hr><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>Java采用的是基于共享内存的并发模型,使得JVM看起来非常类似现代多核处理器:在基于共享内存的多核处理器体系架构中,每个处理器都有自己的缓存,并且定期与主内存进行协调.这里的线程同样有自己的缓存(也叫工作内存),此时,JVM内存模型呈现出如下结构:<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ft3z465r4rj31940raq6x.jpg" srcset="/img/loading.gif" alt="mage-20180709222153"></p><p>上图展示JVM的内存模型,也称之为JMM.对于JMM有以下规定:</p><ol><li>所有的变量都存储在主内存(Main Memory)</li><li>每个线程也有用自己的工作内存(Work Memory)</li><li>工作内存中的变量是主内存变量的拷贝,线程不能直接读写主内存的变量,而只能操作自己工作内存中的变量</li><li>线程间不共享工作内存,如果线程间需要通信必须借助主内存来完成</li></ol><p>共享变量所在的内存区域也就是共享内存,也称之为堆内存,该区域中的变量都可能被共享,即被多线程访问.说的再通俗点就是在java当中,堆内存是在线程间共享的,而局部变量,形参和异常程序参数不在堆内存,因此就不存在多线程共享的情况.</p><p>与JMM规定相对应,我们定义了以下四个原子性操作来实现变量从主内存拷贝到工作内存的过程:</p><blockquote><ol><li>read:读取主内存的变量,并将其传送到工作内存</li><li>load:把read操作从主内存得到的变量值放入到工作内存的拷贝中</li><li>store:把工作内存中的一个变量值传送到主内存当中,以便用于后面的write操作</li><li>write:把store操作从工作内存中得到的变量的值放入主内存的变量中.</li></ol></blockquote><p>可以看出,从主内存到工作内存的过程其实是要经过read和load两个操作的,反之需要经过store和write两个操作.</p><p>现在我们来看一段代码,并用结合上文谈谈下多线程安全问题:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        ShareVar ins = <span class="hljs-keyword">new</span> ShareVar();        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            Thread thread;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> AddThread(ins));            &#125; <span class="hljs-keyword">else</span> &#123;                thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SubThread(ins));            &#125;            thread.start();            threadList.add(thread);        &#125;        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;            thread.join();        &#125;        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">"   "</span> + ins.getCount());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareVar</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">//此处为了更好的体现多线程安全问题</span>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        count++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;        count--;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> ShareVar shareVar;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AddThread</span><span class="hljs-params">(ShareVar shareVar)</span> </span>&#123;        <span class="hljs-keyword">this</span>.shareVar = shareVar;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        shareVar.add();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> ShareVar shareVar;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SubThread</span><span class="hljs-params">(ShareVar shareVar)</span> </span>&#123;        <span class="hljs-keyword">this</span>.shareVar = shareVar;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        shareVar.sub();    &#125;&#125;</code></pre><p>理想情况下,最后应该输出0,但是多次运行你会先可能输出-1或者-2等.为什么呢?<br>在创建的这10个线程中,每个线程都有自己工作内存,而这些线程又共享了ShareVar对象的count变量,当线程启动时,会经过read-load操作从主内存中拷贝该变量至自己的工作内存中,随后每个线程会在自己的工作内存中操作该变量副本,最后会将该副本重新写会到主内存,替换原先变量的值.但在多个线程中,但由于线程间无法直接通信,这就导致变量的变化不能及时的反应在线程当中,这种细微的时间差最终导致每个线程当前操作的变量值未必是最新的,这就是所谓的内存不可见性.</p><p>现在我想你已经完全明白了多线程安全问题的由来.那该怎么解决呢?最简单的方法就是让多个线程对共享对象的读写操作编程串行,也就是同一时刻只允许一个线程对共享对象进行操作.我们将这种机制成为锁机制,java中规定每个对象都有一把锁,称之为监视器(monitor),有人也叫作对象锁,同一时刻,该对象锁只能服务一个线程.</p><p>有了锁对象之后,它是怎么生效的呢?为此JMM中又定义了两个原子操作:</p><blockquote><ol><li>lock:将主内存的变量标识为一条线程独占状态</li><li>unlock:解除主内存中变量的线程独占状态</li></ol></blockquote><p>在锁对象和这两个原子操作共同作用下而成的锁机制就可以实现同步了,体现在语言层面就是synchronized关键字.上面我们也说道Java采用的是基于共享内存的并发模型,该模型典型的特征是要显式同步,也就是说在要人为的使用synchronized关键字来做同步.现在我们来改进上面的代码,只需要为add()和sub()方法添加syhcronized关键字即可,但在这之前,先来看看这两个方法对应的字节码文件:</p><pre><code class="hljs plain">public void add();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack&#x3D;3, locals&#x3D;2, args_size&#x3D;1       0: ldc2_w        #2                  &#x2F;&#x2F; long 100l       3: invokestatic  #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.sleep:(J)V       6: goto          14       9: astore_1      10: aload_1      11: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;InterruptedException.printStackTrace:()V      14: aload_0      15: dup      16: getfield      #7                  &#x2F;&#x2F; Field count:I      19: iconst_1      20: iadd      21: putfield      #7                  &#x2F;&#x2F; Field count:I      24: returnpublic void sub();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1       0: aload_0       1: dup       2: getfield      #7                  &#x2F;&#x2F; Field count:I       5: iconst_1       6: isub       7: putfield      #7                  &#x2F;&#x2F; Field count:I      10: return    LineNumberTable:      line 18: 0      line 19: 10</code></pre><p>现在我们使用synchronized来让着两个方法变得安全起来:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareVar</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">100</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        count++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;        count--;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><p>此时这段代码在多线程中就会表现良好.再来看看它的字节码文件发生了什么变化:</p><pre><code class="hljs plain">public synchronized void add();  descriptor: ()V  flags: ACC_PUBLIC, ACC_SYNCHRONIZED  Code:    stack&#x3D;3, locals&#x3D;2, args_size&#x3D;1       0: ldc2_w        #2                  &#x2F;&#x2F; long 100l       3: invokestatic  #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.sleep:(J)V       6: goto          14       9: astore_1      10: aload_1      11: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;InterruptedException.printStackTrace:()V      14: aload_0      15: dup      16: getfield      #7                  &#x2F;&#x2F; Field count:I      19: iconst_1      20: iadd      21: putfield      #7                  &#x2F;&#x2F; Field count:I      24: return public synchronized void sub();  descriptor: ()V  flags: ACC_PUBLIC, ACC_SYNCHRONIZED  Code:    stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1       0: aload_0       1: dup       2: getfield      #7                  &#x2F;&#x2F; Field count:I       5: iconst_1       6: isub       7: putfield      #7                  &#x2F;&#x2F; Field count:I      10: return    LineNumberTable:      line 18: 0      line 19: 10</code></pre><p>通过字节码不难看出最大的变化在于方法的flags中增加了ACC_SYNCHRONIZED标识,虚拟机在遇到该标识时,会隐式的为方法添加monitorenter和monitorexit指令,这两个指令就是在JMM的lock和unlock操作上实现的.</p><p>其中monitorenter指令会获取对象的占有权,此时有以下三种可能:</p><blockquote><ol><li>如果该对象的monitor的值0,则该线程进入该monitor,并将其值标为1,表明对象被该线程独占.</li><li>同一个线程,如果之前已经占有该对象了,当再次进入时,需将该对象的monitor的值加1.</li><li>如果该对象的monitor值不为0,表明该对象被其他线程独占了,此时该线程进入阻塞状态,等到该对象的monitor的值为0时,在尝试获取该对象.</li></ol></blockquote><p>而monitorexit的指令则是已占有该对象的线程在离开时,将monitor的值减1,表明该线程已经不再独占该对象.</p><p>用synchronized修饰的方法叫做同步方法,除了这种方式之外,还可以使用同步代码块的形式:</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cd.app;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareVar</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">100</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            count++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            count--;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><p>接下来同样是看一下他的字节码,主要看add()和sub()方法:</p><pre><code class="hljs plain"> public void add();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack&#x3D;3, locals&#x3D;3, args_size&#x3D;1         0: aload_0         1: dup         2: astore_1         3: monitorenter         4: aload_0         5: dup         6: getfield      #2                  &#x2F;&#x2F; Field count:I         9: iconst_1        10: iadd        11: putfield      #2                  &#x2F;&#x2F; Field count:I        14: aload_1        15: monitorexit        16: goto          24        19: astore_2        20: aload_1        21: monitorexit        22: aload_2        23: athrow        24: returnpublic void sub();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack&#x3D;3, locals&#x3D;3, args_size&#x3D;1         0: aload_0         1: dup         2: astore_1         3: monitorenter         4: aload_0         5: dup         6: getfield      #2                  &#x2F;&#x2F; Field count:I         9: iconst_1        10: isub        11: putfield      #2                  &#x2F;&#x2F; Field count:I        14: aload_1        15: monitorexit        16: goto          24        19: astore_2        20: aload_1        21: monitorexit        22: aload_2        23: athrow        24: return</code></pre><p>同步代码块和同步方法的实现原理是一致的,都是通过monitorenter/monitorexit指令,唯一的区别在于同步代码块中monitorenter/monitorexit是显式的加载字节码文件当中的.</p><p>上面我们通过synchronized解决了内存可见性问题,另外也可以认为凡是被synchronized修饰的方法或代码块都是原子性的,即一个变量从主内存到工作内存,再从工作内存到主内存这个过程是不可分割的.</p><p>正如我们在<a href="http://blog.csdn.net/dd864140130/article/details/56494925" target="_blank" rel="noopener"> 谈乱序执行和内存屏障</a>所提到的,javac编译器和JVM为了提高性能会通过指令重排的方式来企图提高性能,但是在某些情况下我们同样需要阻止这过程,由于synchronized关键字保证了持有同一个锁的的两个同步方法/同步块只能串行进入,因此无形之中也就相当阻止了指令重排.</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望这么从下往上,再从上往下的解释能让各位同学对JVM内存模型以及多线程安全问题有个更通透的理解.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>JMM</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乱序执行与内存屏障</title>
    <link href="/2017/02/22/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
    <url>/2017/02/22/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>今天准备来聊聊乱序执行技术和内存屏障.为了能让大多数人理解,这里省略了很多不影响理解的旁枝末节,但由于我个人水平有限,如果不妥之处,希望各位指正.</p><h1 id="顺执行技术"><a href="#顺执行技术" class="headerlink" title="顺执行技术"></a>顺执行技术</h1><p>在开始说乱序执行之前,得先把按序执行说一遍.在早期处理器中,处理器执行指令的顺序就是按照我们编写汇编代码的顺序执行的,换句话说此时处理器指令执行顺序和我们代码顺序一致,我们称之为按序执行(In Order Execution).我们以烧水泡茶为例来说明按序执行的过程(熟悉的同学会想起华罗庚的统筹学):</p><ol><li>洗水壶</li><li>烧开水</li><li>洗茶壶</li><li>洗茶杯</li><li>拿茶叶</li><li>泡茶</li></ol><p>我们假设每一步代表一条指令的执行,此时从指令1到指令6执行的过程就是我们所说的按序执行.整个过程可以表示为:<br><img src="http://pbj0kpudr.bkt.clouddn.com/blog/2018-07-08-2018-07-08-image-201807081214167.png" srcset="/img/loading.gif" alt="mage-20180708121416"></p><p>按序执行对于早期处理器而言是一种行之有效的方案,但随着对时间的要求,我们希望上述过程能够在最短的时间内执行完成,这就促使人们迫切希望找到一种优化指令执行过程的方案.考虑上述执行过程,我们发现洗茶壶这步完全没有必要等待烧开水完成,也就是说洗茶壶和洗水杯完全可以和烧开水同时进行,这么一来,优化过的流程如图:<br><img src="http://pbj0kpudr.bkt.clouddn.com/blog/2018-07-08-image-201807081215033.png" srcset="/img/loading.gif" alt="mage-20180708121503"></p><p>这种通过改变原有执行顺序而减少时间的执行过程我们被称之为乱序执行,也称为重排.到现在为止,我们已经弄明白了什么是按序执行,什么是乱序.那接下来就看看处理器中的乱序执行技术.</p><hr><h1 id="乱序执行技术"><a href="#乱序执行技术" class="headerlink" title="乱序执行技术"></a>乱序执行技术</h1><h2 id="处理器乱序执行"><a href="#处理器乱序执行" class="headerlink" title="处理器乱序执行"></a>处理器乱序执行</h2><p>随着处理器流水线技术和多核技术的发展,目前的高级处理器通过提高内部逻辑元件的利用率来提高运行速度,通常会采用乱序执行技术.这里的乱序和上面谈到烧水煮茶的道理是一样的.</p><p>先来看一张处理器的简要结构图:<br><img src="http://pbj0kpudr.bkt.clouddn.com/blog/2018-07-08-image-201807081215425.png" srcset="/img/loading.gif" alt="mage-20180708121542"></p><p>处理器从L1 Cache中取出一批指令,分析找出那些不存在相互依赖的指令,同时将其发射到多个逻辑单元执行,比如现在有以下几条指令:</p><pre><code class="hljs plain">LDR   R1, [R0]；ADD   R2, R1, R1；ADD   R4，R3，R3;</code></pre><p>通过分析发现第二条指令和第一条指令存在依赖关系,但是和第3条指令无关,那么处理器就可能将其发送到两个逻辑单元去执行,因此上述的指令执行流程可能如下:<br><img src="https://i.imgur.com/do7onYV.jpg" srcset="/img/loading.gif" alt="mage-20180708121620"></p><p>可以说乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化.在单核时代,处理器保证做出的优化不会导致执行结果远离预期目标,但在多核环境下却并非如此.</p><p>首先多核时代,同时会有多个核执行指令,每个核的指令都可能被乱序;另外,处理器还引入了L1,L2等缓存机制,每个核都有自己的缓存,这就导致逻辑次序上后写入内存的数据未必真的最后写入.最终带来了这么一个问题:如果我们不做任何防护措施,处理器最终得出的结果和我们逻辑得出的结果大不相同.比如我们在一个核上执行数据的写入操作,并在最后写一个标记用来表示之前的数据已经准备好,然后从另一个核上通过判断这个标志来判定所需要的数据已经就绪,这种做法存在风险:标记位先被写入,但是之前的数据操作却并未完成(可能是未计算完成,也可能是数据没有从处理器缓存刷新到主存当中),最终导致另一个核中使用了错误的数据.</p><h2 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h2><p>除了上述由处理器和缓存引起的乱序之外,现代编译器同样提供了乱序优化.之所以出现编译器乱序优化其根本原因在于处理器每次只能分析一小块指令,但编译器却能在很大范围内进行代码分析,从而做出更优的策略,充分利用处理器的乱序执行功能.</p><h2 id="乱序的分类"><a href="#乱序的分类" class="headerlink" title="乱序的分类"></a>乱序的分类</h2><p>现在来总结下所有可能发生乱序执行的情况:</p><ul><li>现代处理器采用指令并行技术,在不存在数据依赖性的前提下,处理器可以改变语句对应的机器指令的执行顺序来提高处理器执行速度</li><li>现代处理器采用内部缓存技术,导致数据的变化不能及时反映在主存所带来的乱序.</li><li>现代编译器为优化而重新安排语句的执行顺序</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>尽管我们看到乱序执行初始目的是为了提高效率,但是它看来其好像在这多核时代不尽人意,其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外.因此有必要存在一种机制来消除乱序执行带来的坏影响,也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行.这种机制就是所谓内存屏障.不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障,对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令.</p><hr><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><h2 id="处理器乱序规则"><a href="#处理器乱序规则" class="headerlink" title="处理器乱序规则"></a>处理器乱序规则</h2><p>上面我们说了处理器会发生指令重排,现在来简单的看看常见处理器允许的重排规则,换言之就是处理器可以对那些指令进行顺序调整:</p><table><thead><tr><th>处理器</th><th>Load-Load</th><th>Load-Store</th><th>Store-Store</th><th>Store-Load</th><th>数据依赖</th></tr></thead><tbody><tr><td>x86</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><p>表格中的Y表示前后两个操作允许重排,N则表示不允许重排.与这些规则对应是的禁止重排的内存屏障.</p><p>注意:处理器和编译都会遵循数据依赖性,不会改变存在数据依赖关系的两个操作的顺序.所谓的数据依赖性就是如果两个操作访问同一个变量,且这两个操作中有一个是写操作,那么久可以称这两个操作存在数据依赖性.举个简单例子:</p><pre><code class="hljs plain">a&#x3D;100;&#x2F;&#x2F;writeb&#x3D;a;&#x2F;&#x2F;read或者a&#x3D;100;&#x2F;&#x2F;writea&#x3D;2000;&#x2F;&#x2F;write或者a&#x3D;b;&#x2F;&#x2F;readb&#x3D;12;&#x2F;&#x2F;write</code></pre><p>以上所示的,两个操作之间不能发生重排,这是处理器和编译所必须遵循的.当然这里指的是发生在单个处理器或单个线程中.</p><h2 id="内存屏障的分类"><a href="#内存屏障的分类" class="headerlink" title="内存屏障的分类"></a>内存屏障的分类</h2><p>在开始看一下表格之前,务必确保自己了解Store和Load指令的含义.简单来说,Store就是将处理器缓存中的数据刷新到内存中,而Load则是从内存拷贝数据到缓存当中.</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load1</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><p>StoreLoad Barriers同时具备其他三个屏障的效果,因此也称之为全能屏障,是目前大多数处理器所支持的,但是相对其他屏障,该屏障的开销相对昂贵.在x86架构的处理器的指令集中,lock指令可以触发StoreLoad Barriers.</p><p>现在我们综合重排规则和内存屏障类型来说明一下.比如x86架构的处理器中允许处理器对Store-Load操作进行重排,与之对应有StoreLoad Barriers禁止其重排.</p><hr><h1 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h1><p>无论是处理器还是编译器,不管怎么重排都要保证(单线程)程序的执行结果不能被改变,这就是as-if-serial语义.比如烧水煮茶的最终结果永远是煮茶,而不能变成烧水.为了遵循这种语义,处理器和编译器不能对存在数据依赖性的操作进行重排,因为这种重排会改变操作结果,比如对:</p><pre><code class="hljs plain">a&#x3D;100;&#x2F;&#x2F;writeb&#x3D;a;&#x2F;&#x2F;read</code></pre><p>重排为:</p><pre><code class="hljs plain">b&#x3D;a;a&#x3D;100;</code></pre><p>此时b的值就是不正确的.如果不存在操作之间不存在数据依赖,那么这些操作就可能被处理器或编译器进行重排,比如:</p><pre><code class="hljs plain">a&#x3D;10;b&#x3D;200;result&#x3D;a*b;</code></pre><p>它们之间的依赖关系如图:<br><img src="https://i.imgur.com/6pAc8j5.jpg" srcset="/img/loading.gif" alt="mage-20180708121658"></p><p>由于<code>a=10</code>和<code>b=200</code>之间不存在依赖关系,因此编译器或处理可以这两两个操作进行重排,因此最终执行顺序可能有以下两种情况:</p><p><img src="https://i.imgur.com/26BprKT.jpg" srcset="/img/loading.gif" alt="mage-20180708121731"><br>但无论哪种执行顺序,最终的结果都是对的.</p><p>正是因为as-if-serial的存在,我们在编写单线程程序时会觉得好像它就是按代码的顺序执行的,这让我们可以不必关心重排的影响.换句话说,如果你从来没有编写多线程程序的需求,那就不需要关注今天我所说的一切.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>as-if-serial</tag>
      
      <tag>Java</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个程序员的日常书单(2018)</title>
    <link href="/2017/02/11/%E6%97%A5%E5%B8%B8%E4%B9%A6%E5%8D%95/"/>
    <url>/2017/02/11/%E6%97%A5%E5%B8%B8%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>今日元宵节,祝各位节日快乐.本想谈谈读书这个话题,想来想起觉得无从下手,就此作罢.毕业这几年,一直不敢放松,在现代这个互联网时代更加认同萧抡谓的”一日不读书,胸臆无佳想;一月不读书,耳目失清爽”.如果非要给自己找个读书的理由的话,这句诗就是最好的理由:”胸藏文墨虚若骨,腹有诗书气自华”.</p><p>与书结缘应该要感谢我的父亲和母亲.小时候,母亲嫌我捣蛋就有意的培养我读书.刚上小学时,父亲便从他战友哪里弄来几千本书,小学,初中,高中都是在期间度过.后来上大学,母亲担心我读书读傻了就全当废纸给卖了.现在母亲甚是后悔,毕竟里边有不少孤本.恰好近几日有朋友问我平时的都看什么书,便有将书单列出的想法,在原来书单基础上稍微做了一点分类,后面会不定时的更新.目前主要列出2015年,2016年的书单以及2017年想要读的书,至于前几年的记录则后面慢慢补充.</p><h1 id="2018书单"><a href="#2018书单" class="headerlink" title="2018书单"></a>2018书单</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ] 编写可读代码的艺术</td><td>多读几遍,看看代码过程中犯了哪些错?</td></tr><tr><td>- [ X ] TensorFlow实战</td><td>这是人人深度学习的时代,用来入门TensorFlow勉强还可以</td></tr><tr><td>- [ X ] 程序员的英语</td><td>从黑客到安全,从云计算到物联网,提高英语与掌握新概念两不误</td></tr><tr><td>- [ X ] 虚拟货币革命</td><td>区块链技术将是未来,虚拟货币本质上与金银财宝并无区别</td></tr><tr><td>- [ X ] 疯狂Kotlin讲义</td><td>开发者头条送的书,大概浏览了一遍,不推荐</td></tr><tr><td>- [ X ] TensorFlow技术解析与实战</td><td>和TensorFlow实战差不多,可以看一看,但是建议直接对着官方文档看</td></tr><tr><td>- [ X ] 程序员修炼之道-从小工到专家</td><td>包含开发过程中很多道理,任何工程师都应该去读几本</td></tr><tr><td>- [ X ] 高效程序员的45个习惯-敏捷开发修炼之道</td><td></td></tr></tbody></table><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ] 活着</td><td>现在依然不错,活着就要努力追求未来</td></tr></tbody></table><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ] 刻意练习</td><td>相比&lt;&lt;异类&gt;&gt;而言,更科学系统的阐述了学习的本质</td></tr></tbody></table><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ]从零开始学炒股</td><td>只是为了学看K线图</td></tr></tbody></table><h1 id="2017书单"><a href="#2017书单" class="headerlink" title="2017书单"></a>2017书单</h1><h2 id="技术类书单"><a href="#技术类书单" class="headerlink" title="技术类书单"></a>技术类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ]C和指针</td><td>C语言入门,进阶都可以读</td></tr><tr><td>- [      ]  Python绝技</td><td></td></tr><tr><td>- [ X ]  C专家编程</td><td>作为C和指针的补充</td></tr><tr><td>- [      ]  程序员的自我修养:链接,装载与库</td><td></td></tr><tr><td>- [ X ]  Linux/Unix设计思想</td><td>为什么Linux/Unix是这个样子?通俗易懂的科普</td></tr><tr><td>- [ X ]  Linux Shell脚本攻略</td><td>Shell入门进阶必备,一本足够</td></tr><tr><td>-  [       ]  图解密码技术</td><td></td></tr><tr><td>-  [       ]  Java 加密与解密的艺术</td><td>全面讲解加密解密的知识,很实用</td></tr><tr><td>-  [       ]  第一步Docker书</td><td></td></tr><tr><td>-  [       ]  Linux内核设计与实现</td><td></td></tr><tr><td>-  [       ]  全景探秘游戏设计艺术</td><td></td></tr><tr><td>- [ X ] 大型网站与Java中间件实践</td><td>配合和大型网站技术架构看起来很不错</td></tr><tr><td>- [ X ] App后台开发运维和架构实践</td><td>一本挺全面的书,涉及App后端相关技术</td></tr><tr><td>- [ X ] Android第一行代码(第2版)</td><td>小伙伴的书,虽然很久不做应用开发,但趁假期期间重新梳理了一遍体系,没什么难点,推荐初学者入门</td></tr></tbody></table><h2 id="思维类书单"><a href="#思维类书单" class="headerlink" title="思维类书单"></a>思维类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>-[ X ]第五项修炼</td><td>学习系统化思考,更好的解决问题</td></tr><tr><td>- [ X ]  DOOM启示录</td><td>卡马克和罗梅洛的传记,两个玩家如何走向游戏之路,制作出影响力最大的DOOM和Quake游戏.好吧,我喜欢这句”在如今的世界上没有人能阻止你成功,你只需要一台电脑和一冰箱的可乐和披萨,和为之献身的决心”</td></tr><tr><td>- [    ]  社会工程学</td><td></td></tr><tr><td>- [    ]  大银行家</td><td></td></tr><tr><td>- [    ]  逻辑与人生</td><td></td></tr><tr><td>- [ X ]  你的灯亮了吗?</td><td>看待问题的新思路</td></tr><tr><td>- [    ]  战略与竞争分析</td><td></td></tr><tr><td>- [    ]  布局天下</td><td></td></tr><tr><td>- [    ]  安全边际</td><td></td></tr><tr><td>- [ X ] 未来简史</td><td>继&lt;&lt;人类简史&gt;&gt;之后的又一经典之作,未来世界变化,人意识形态的变化,社会结构的变革等到.</td></tr><tr><td>- [    ]  改变,问题形 成和解决的原则</td><td></td></tr><tr><td>- [ X ]  软技能-代码之外的生存指南</td><td>代码之外我们还需要做点什么?职业发展,主动学习,自我营销,理财以及健身应该是每个技术人员都要去关注的</td></tr><tr><td>- [ X ] 睡眠革命</td><td>从昼夜规律到R90睡眠方案,再到寝具,帮助我们获得更好的睡眠质量</td></tr></tbody></table><h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><table><thead><tr><th>数目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ] 小狗钱钱</td><td>通俗易懂,老少皆宜的理财入门书</td></tr><tr><td>- [ X ] 富爸爸,穷爸爸</td><td>为钱而工作,还是让钱为自己工作?每个程序员都应该去了解金钱的真正意义</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ X ]大败局</td><td>从秦池到亚细亚,作者细致分析了改革开放30年中私营企业的高歌猛进及失败之根源.现在回顾这两年中许多互联网企业失败的原因其实和之前并无本质区别.</td></tr><tr><td>- [    ]  硅谷之火</td><td></td></tr><tr><td>- [    ]  中国底层访谈录</td><td></td></tr><tr><td>- [    ]  牛鬼蛇神录</td><td></td></tr><tr><td>- [    ]  疯狂养生</td><td></td></tr><tr><td>- [    ]  中国房地产，之厄</td><td></td></tr><tr><td>- [    ]  十亿消费者</td><td></td></tr><tr><td>- [    ]  古今骗术大观</td><td></td></tr><tr><td>- [    ]  我挑战了麦当劳</td><td></td></tr><tr><td>- [    ]  世界伟人成功秘诀值之分析</td><td></td></tr><tr><td>- [ X ] 解忧杂货店</td><td>每个人心里都有答案.才想明白,自己的心破了个洞,</td></tr><tr><td>- [ X ] 你的知识需要管理</td><td>掌握知识管理的方法,才能更如鱼得水.</td></tr></tbody></table><h1 id="2016书单"><a href="#2016书单" class="headerlink" title="2016书单"></a>2016书单</h1><h2 id="技术类书单-1"><a href="#技术类书单-1" class="headerlink" title="技术类书单"></a>技术类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  Android设计模式</td><td>结合Android系统源码来解释设计模式,很不错</td></tr><tr><td>- [ x ]  设计模式:可复用面向对象软件的基础</td><td>设计模式理论篇,没有比这本更好的了</td></tr><tr><td>- [ x ]  七周七语言模型</td><td>了解多种编程范型,原理语言之争</td></tr><tr><td>- [ x ]  深入理解现代计算机操作系统(第三版)</td><td>必备神书</td></tr><tr><td>- [ x ]  算法(第四版)</td><td>java同学深入算法神书,这一本足够了</td></tr><tr><td>- [ x ]  NodeJs实战</td><td>讲nodejs难得好书</td></tr><tr><td>- [ x ]  Android安全技术揭秘与防范</td><td>非虫写的书,做Android逆向的小伙伴人手一本吧</td></tr><tr><td>- [ x ]  Android软件安全与逆向分析</td><td>和上一本可以互补</td></tr><tr><td>- [ x ]  Git版本控制管理</td><td>想深入Git背后原理的可以多读读</td></tr><tr><td>- [ x ]  Gradle for Android中文版</td><td>介绍了一些gradle在android上常用的做法</td></tr><tr><td>- [ x ]  软件随想录</td><td>关于软件管理,软件技术,人才和创业的文集,和&lt;&lt;黑客与画家&gt;&gt;一样值得一读</td></tr><tr><td>- [  x  ]  程序员之禅</td><td>16年离职创业失败后读到,谈内心,生活,管理的一本文集</td></tr><tr><td>- [  x  ]  Java程序员面试笔试宝典</td><td>像我一样不善于笔试的人,这本书当做锻炼还行</td></tr></tbody></table><h2 id="数学类书单"><a href="#数学类书单" class="headerlink" title="数学类书单"></a>数学类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  初等数论</td><td>对毕达哥拉斯感兴趣,好奇数字的发展,让我对数字有了新的认识</td></tr><tr><td>- [ x ]  数学沉思录</td><td>解释了什么是数学以及从数论开始延伸出的其他数学分支,结合&lt;&lt;什么是数字&gt;&gt;读更好</td></tr><tr><td>- [ x ]  数学之美</td><td>用最简单的比喻解释高深的数学概念及应用,最早是在12年读过</td></tr></tbody></table><h2 id="思维类书单-1"><a href="#思维类书单-1" class="headerlink" title="思维类书单"></a>思维类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  专注力</td><td>或许对你提高自己的专注力有所帮助</td></tr><tr><td>- [ x ]  重塑大脑</td><td>重新认识下自己的大脑</td></tr><tr><td>- [ x ]  意识与脑</td><td>意识是怎么产生的?你能意识到自己的意识么?帮助自己理解自己大脑</td></tr><tr><td>- [ x ]  批判性思维</td><td>重树自己的思维方式,这是本很棒的书</td></tr><tr><td>- [ x ]  判断与决策</td><td>值得反复读,成体系的讲述决策与判断的心理学基础</td></tr><tr><td>- [ x ]  别做正常的傻瓜</td><td>洞察自己思维漏洞,非常有意思</td></tr><tr><td>- [ x ]  怪诞心理学</td><td>统计了人类一些其他的行为和心理活动</td></tr><tr><td>- [ x ]  改变心理学的四十项研究</td><td>非常有趣的书,讲述了40个经典的实验以及背后的研究</td></tr><tr><td>- [ x ]  进化心理学</td><td>讲进化生物学难的好书</td></tr><tr><td>- [ x ]  学会提问</td><td>同样是讲批判性思维的好书</td></tr><tr><td>- [ x ]  本能</td><td>从生物进化论的角度讲了人类社会一些现象,很多都是你觉察不到的基因在作怪,和&lt;&lt;欲望之源&gt;&gt;类似</td></tr><tr><td>- [ x ] 粘住,为什么我们会记住这些</td><td>建议英文版,讲记忆相关</td></tr><tr><td>- [ x ]  自卑与超越</td><td>解决我的自卑,好书</td></tr><tr><td>- [ x ]  乌合之众</td><td>人多不一定力量大,群体往往表现出愚蠢,这本书告诉你为什么</td></tr><tr><td>- [ x ]  让大脑自由:释放天赋的12条定律</td><td>几条更好用脑的定理</td></tr><tr><td>- [ x ]  拆掉思维的墙</td><td>古典写的,讲心智成熟,可以和&lt;&lt;巨婴国&gt;&gt;一起读</td></tr><tr><td>- [ x ]  自控力</td><td>怎么样增强自己的控制力,更好的管理自己,解决自己的拖延症呢?背后的一些原理需要学一学</td></tr><tr><td>- [ x ]  性学三理论与爱情心理学</td><td>性是促进人行为的动机啊,读的我一愣一愣的</td></tr><tr><td>- [ x ]  我的互联网方法论</td><td>周总的一些思想,看起来普通,但对公司/个人理解这个时代都有帮助</td></tr><tr><td>- [ x ]  奇点临近</td><td>一本预测未来科技的书,现在看来好像挺准,比如现在人工智能的发展.</td></tr><tr><td>- [ x ]  人类简史</td><td>大作,从历史的角度讲人类发展,我们都是智人的后代,尼安德特人为什么消失了?</td></tr><tr><td>- [ x ]  当我们阅读的时候,我们看到了什么</td><td>不言而喻,多读几遍</td></tr><tr><td>- [ x ]  如何高效学习</td><td>斯科特讲学习方法,很实用,很系统</td></tr><tr><td>- [ x ]  语言本能:探索人类语言进化的奥秘</td><td>语言是很神奇的,看看吧</td></tr></tbody></table><h2 id="时间管理类书单"><a href="#时间管理类书单" class="headerlink" title="时间管理类书单"></a>时间管理类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  奇特的一生</td><td>跟柳比歇夫学时间统计</td></tr><tr><td>- [ x ]  一年的8760个小时</td><td>艾力的传记和时间管理</td></tr><tr><td>- [ x ]  和时间做朋友</td><td>李笑来讲心智和时间管理,不错</td></tr><tr><td>- [ x ]  时间管理:如何充分利用24小时</td><td>同样是讲时间管理的</td></tr></tbody></table><h2 id="其他类书单"><a href="#其他类书单" class="headerlink" title="其他类书单"></a>其他类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  此生未完</td><td>复旦大学教师于娟病中最后一年的日记,珍爱自己身体吧,死了就什么都没了</td></tr><tr><td>- [ x ]  有一种幸福叫做感恩</td><td>恩,忘了讲什么了</td></tr><tr><td>- [ x ]  了不起的盖茨比</td><td>很有趣味的一本小说,读完之后却令人深思</td></tr><tr><td>- [ x ]  激荡三十年</td><td>了解改革三十年来企业的发展和变革</td></tr><tr><td>- [ x ]  迷茫时代的明白人</td><td>逻辑思维集合</td></tr><tr><td>- [ x ]  10秒钟让自己不同凡响</td><td>好吧,我忘了这本书,不推荐读了</td></tr><tr><td>- [ x ]  人生的智慧</td><td>学妹推荐的,恩,我也算是个悲观主义者.叔本华的生活态度</td></tr></tbody></table><p>附注:2016年一共读了122本书,有点不务正业的感觉.后面再把其他书单补充上来.</p><h1 id="2015书单"><a href="#2015书单" class="headerlink" title="2015书单"></a>2015书单</h1><h2 id="技术类书单-2"><a href="#技术类书单-2" class="headerlink" title="技术类书单"></a>技术类书单</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  深入理解Java虚拟机(第二版)</td><td>java程序员进阶必备,另外java虚拟机规范也值得一读</td></tr><tr><td>- [ x ]  Effective Java</td><td>手边必备,java编程中一些有效的技巧和注意点,另一本&lt;&lt;java解惑&gt;&gt;同样很棒</td></tr><tr><td>- [ x ]  Android开发艺术探索</td><td>Android进阶不错的一本书</td></tr><tr><td>- [ x ]  Android研发录</td><td>创业期间读得,值得一读,很多点给了我帮助</td></tr><tr><td>- [ x ]  Java并发编程实战</td><td>看了5,6边的书,仍然不时重读,搞定并发编程这一本足够</td></tr><tr><td>- [ x ]  白帽子讲Web安全</td><td>阿里道哥写的,讲WEB安全挺系统的</td></tr><tr><td>- [ x ]  RxJava Essentials CN</td><td>RxJava在15年对Android开发者而耳熟能详,这本书从头到尾带你认识RxJava</td></tr><tr><td>- [ x ]  深入理解Java内存模型</td><td>了解JMM必备书籍,帮助你认识多线程安全问题</td></tr><tr><td>- [ x ]  大型网站技术架构</td><td>介绍了网站架构的演进和发展史,并给出较为通用的解决方案</td></tr><tr><td>- [ x ]  Python学习手册</td><td>学习Python的小手册</td></tr><tr><td>- [ x ]  图解HTTP</td><td>通俗易懂的带你认识HTTP,结合&lt;&lt;TCP/UDP详解卷一&gt;&gt;一起读更好</td></tr><tr><td>- [ x ]  测试驱动开发</td><td>一种新的开发方式,15年创业时实践过</td></tr><tr><td>- [ x ]  Groovy经典入门</td><td>玩转Gradle之前先来入门Groovy更好</td></tr><tr><td>- [ x ]  EffectiveMySql之SQL语句最优化</td><td>一些编写SQL语句的技巧</td></tr><tr><td>- [ x ]  程序员面试笔试宝典</td><td>想要面试外企么?这本书非常适合,其中的一些面试题也不错</td></tr></tbody></table><h2 id="思维类"><a href="#思维类" class="headerlink" title="思维类"></a>思维类</h2><table><thead><tr><th>书目</th><th>简评</th></tr></thead><tbody><tr><td>- [ x ]  暗时间</td><td>刘伟鹏的书,很不错的一本小文集合,值得一看</td></tr><tr><td>- [ x ]  危险人格识别术</td><td>几种常见的危险人格,看完之后感觉自己处在水深火热之中</td></tr><tr><td>- [ x ]  影响力</td><td>你是怎么被别人忽悠的?或者你想知道怎么忽悠别人么,看这本书应该有帮助</td></tr><tr><td>- [ x ]  高效能人士的七个习惯</td><td>几个高效做事的习惯,值得一看</td></tr><tr><td>- [ x ]  创业维艰</td><td>15年离开创业公司后看的书,感同身受</td></tr><tr><td>- [ x ]  什么是数学</td><td>我一直觉得自己是个数学渣渣,所以重新来认识了数学</td></tr><tr><td>- [ x ]  怎样解题</td><td>跟波利亚一起学解题,非常好</td></tr><tr><td>- [ x ]  如何阅读一本书</td><td>将读书方法的一本老书,其思想永恒</td></tr><tr><td>- [ x ]  给你一个团队,你能怎么管?</td><td>创业时候管理团队看的一本书,关于团队管理</td></tr><tr><td>- [ x ]  异类</td><td>分析一些成功人士,1万个小时定律来于此</td></tr><tr><td>- [ x ]  人月神话</td><td>所有搞软件工程的人都值得一看</td></tr><tr><td>- [ x ]  欲望之愿</td><td>人的一些本能在无形之中影响着我们,入门级读物,后面可以读&lt;&lt;进化心理学&gt;&gt;</td></tr><tr><td>- [ x ]  贪婪的大脑</td><td>侧重于大脑功能和结构讲解,比如说意识是什么,工作记忆等</td></tr></tbody></table><h1 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h1><p>每个人都有自己的读书方法和特点,这里简单的写一下我自己有关读书方面的一些做法.</p><h2 id="什么时候读书"><a href="#什么时候读书" class="headerlink" title="什么时候读书?"></a>什么时候读书?</h2><ol><li>创造大块的时间读重要的书,利用好琐碎的时间.</li><li>每天稳定在3-6小时的阅读时间，早晚1–2一小时左右，中午半小时左右</li></ol><p>建议看完书后快速笔记,这样会理解更深,记得更久.我通常选择逻辑图和思维导图,有时候也会直接白纸列大纲.一个简单的思维导图可以是这样的:<br><img src="https://i.imgur.com/7aOJ8yS.jpg" srcset="/img/loading.gif" alt="mage-20180712220846"></p><h2 id="读什么样的书"><a href="#读什么样的书" class="headerlink" title="读什么样的书?"></a>读什么样的书?</h2><p>为了避免浪费精力在一些”垃圾书”,读书之前需要对书籍进行筛选,最终目标就是:读好书.这就要求你在读书之前获得对该书的大致评估.如何评估一本书事关重要,有以下几个方法可供参考:</p><ol><li>看作者.牛的作者的书一般不错.比如Joshua Bloch写的Effective Java不错,那么他写的Java Puzzlers同样值得一看:</li><li>看豆瓣或者Amazon的评分,除了关注整体打分,也需要关注最低评分.就我个人经验而言,最低评分更可能是对这本书有深入理解的人打出来的.</li><li>看目录和简介.目录是否清晰,是否直白,一本好书在目录上给你很大的引导,而非胡说八道.</li></ol><p>另外,一定要确定好你需要读什么类别的书,这样可以保证你始终把精力放在主题上,关注自己该关注的才会提升自己的效率.比如我通常会读以下几类书:</p><ul><li>心理学类</li><li>学习方法类</li><li>技术类(开发+安全)</li></ul><h2 id="如何搜寻好书"><a href="#如何搜寻好书" class="headerlink" title="如何搜寻好书"></a>如何搜寻好书</h2><p>有些朋友问我如何搜寻好书?在我看来,现在互联网时代找一本好书确实变得更难了,我们永远无法得知一本”好书”的背后是否有一堆窃笑的营销人员.这里同样有几条建议值得一看:</p><ul><li>同作者的著作.如果一个作者很牛,那么他写的其他书也不会很差.</li><li>Amazon相关推荐和豆瓣上的豆列.</li><li>一本好书或者博客中所重点提到的其他著作.一本书中提到的其他著作往往也不错.比如我在<a href="http://mindhacks.cn" target="_blank" rel="noopener">刘未鹏的博客</a>中就看到很多好书推荐.</li><li>不知道你注意到没有,有些大牛也会偶尔推荐一些好书,前提是你要关注他的日常.比如余弦推荐的几本<a href="https://zhuanlan.zhihu.com/p/20780317" target="_blank" rel="noopener">黑客方面的书籍</a>很不错</li></ul><h2 id="如何建立书籍等级"><a href="#如何建立书籍等级" class="headerlink" title="如何建立书籍等级?"></a>如何建立书籍等级?</h2><p>给自己建立一套书籍评分制度是个非常不错的做法,能够有效的帮助我们制定读书策略.我将书籍定为4分制,不同的分值含义如下:</p><ul><li>5分:对自己目前帮助很大，能帮助建立新的知识体系或者改进现有知识体系,多次、需要持续阅读和精读.比如像Effective Java之类就是5分.</li><li>4分:用来扩展阅读,对自己现有的知识体系进行补充和扩展,一般我会定时阅读这类书籍.</li><li>3分:书中的某部分需要学习或精读,比如像&lt;&lt;程序员面试金典&gt;&gt;,再比如CSDN杂志中的部分章节.</li><li>2分:速度一遍即可,通常是杂谈/消遣之类的文章,比如&lt;&lt;将来的你,一定会感谢现在拼命的自己&gt;&gt;</li></ul><h2 id="用什么来读"><a href="#用什么来读" class="headerlink" title="用什么来读?"></a>用什么来读?</h2><p>互联网时代有了更多的选择,除了传统的书籍外,还有很多电子阅读设备来选择.我日常的阅读工具是ipad mini2,kindle以及pc.</p><p>一些技术类的书籍我通常选择纸质.在我看来,除了体积较大这个缺点外,没有比书籍更方面的阅读工具了:可以随便翻页,用笔在上面在批注等等.</p><p>kindle于我而言是在地铁上不可或缺的,每次上班地铁上40多分钟,在我看来这就是kindle最佳的使用场所.通常我会用它阅读一些文学,思维类书籍.</p><p>iPad mini2上我主要装了多看阅读器,实在是太好用了.通常我会用它阅读一些pdf格式的书籍:有些书籍并不值得买,但却值得一读,所以从网上获取这种开放性的资源就是非常好的途径了.</p><p>不动笔墨不读书.我有做注释的习惯,但有些pdf格式的书无法用多看来做注释,那么选择pc上专业的阅读工具就是很好的做法了</p><h2 id="复习计划"><a href="#复习计划" class="headerlink" title="复习计划"></a>复习计划</h2><p>所谓书读百遍其义自见,好书更是如此.一本书读过之后若不加以重读,往往会产生两个方面的问题:其一理解不深,不透;其二就是遗忘太快.因此给自己一个合理的复习计划就显得很重要.有一条很简单却实用的准则可以参考:书无一遍书,好书更翻倍.通俗点就是一本书读了一遍那不叫读书,应该多读几遍.</p><h1 id="如何进行快读阅读"><a href="#如何进行快读阅读" class="headerlink" title="如何进行快读阅读"></a>如何进行快读阅读</h1><p>上面谈了一些关于读书方面很实际的问题,下面来谈快速阅读,我想这个也许是很多人感兴趣的.以下并非夸夸其谈,而是我多年实践所得,其中有些也是受别人启发,最终才形成了这一套阅读方式.需要说明的一点快速阅读相对较累,请保证自己有个好身体,不然谈快速阅读就没啥意义了,这就好比你骑着自行车和法拉利比赛跑一样,你的自行车再好也不会比法拉利更快.</p><p>很多谈快速阅读,教快速阅读的文章都将其写的太过于理论化,抽象化,以至于让很多人觉得这是一项高深的技能.但其实人人天生都会快速阅读,只不过通过适当的训练快速阅读之后的效果更好而已.</p><p>读书都一样,分为三个过程:之前,之中,之后.快速阅读虽如此,但稍微有所不同.现在我将这几个阶段做什么告诉你.</p><h2 id="之前"><a href="#之前" class="headerlink" title="之前"></a>之前</h2><p>在速读之前,请务必做到以下几点:</p><p> 1.早期练习的时候给自己创造一个无干扰的环境.否则在你快速阅读的过程中来自周围的干扰信息将会导致你的注意力分散,导致对文章的理解中断.当你熟悉之后,无论再大的干扰也不会影响你了</p><p> 2.速读之前放松你的大脑.速读的时候,只有在大脑处在放松并且集中的状态下才会取得非常好的效果,因此有必要在开始速读之前清空你的杂念,放松你的大脑.另外如果在速读过程中让大脑过程紧张,会导致你在速读过程感到非常疲惫.</p><p> 3.阅读之前一定要有明确的目的,否则容易造成阅读没有中心,理解不够.因此阅读之前,有必要问自己:阅读这篇文章想获得什么知识.</p><h2 id="进行"><a href="#进行" class="headerlink" title="进行"></a>进行</h2><p>在读书时要做什么?我来告诉你我是怎么做的:</p><ol><li><p>阅读过程中,快读有效的跳动眼睛视野,并要求你的大脑跟的上你的视野.只有你的大脑跟上了你的视野,大脑才将你看到的信息纳入到意识的层次上,才有可能对当前看到的信息进行处理</p></li><li><p>阅读过程中要不断进行阅读总结.在阅读过程中,眼睛看到文字,然后心中总结这段文字的意思.我们知道重复是记忆之母,根据我的实践,我认为重复也是理解之母.</p></li><li><p>阅读过程中要不断的提出问题.通过不断的提问题,你的大脑会自动的寻找答案.而不断的提问能够保证你的大脑在阅读过程中保持和书本的联系.</p></li></ol><h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2><p>读完之后要做点什么呢?有些人会深吸一口气,然后觉得该放松了,应该躺在床上休息一会或者听会歌,总之,他们觉得刚才那么累了,现在是该放松下了.但是经过我多年的实践,我发现读完之后立刻做笔记/总结对我们更有帮助.</p><p>因此,我的建议是:一定要做阅读后的笔记.无论读完什么书,都要去做一点的笔记,笔记越短越好,并且最好是丰富多彩的,优先选择图文的方法,这样可以让记忆”视觉化”,它作能够促使我们的大脑进行回忆,并对其中内容进行逻辑整理.</p><h2 id="终结"><a href="#终结" class="headerlink" title="终结"></a>终结</h2><p>关于读书就暂时说这么些.最后说句很实在的话来解释为什么读书:人脑的学习是非主动的,而是在外接的信息的刺激下被动性的学习.因此,通过读书来获取源源不断的信息来促进自己的学习就是一件理所应当的事情了.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来自Unix/Linux的编程启示录</title>
    <link href="/2017/02/08/%E6%9D%A5%E8%87%AAUnix:Linux%E7%9A%84%E7%BC%96%E7%A8%8B%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <url>/2017/02/08/%E6%9D%A5%E8%87%AAUnix:Linux%E7%9A%84%E7%BC%96%E7%A8%8B%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在整个探究过程中,那些经典的著作再次让我获益匪浅:<a href="https://book.douban.com/subject/3012360/" target="_blank" rel="noopener">C和指针</a>,<a href="https://book.douban.com/subject/2377310/" target="_blank" rel="noopener">C专家编程</a>,<a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">深入理解计算机系统(原书第3版)</a>,<a href="https://book.douban.com/subject/7564417/" target="_blank" rel="noopener">Linux/Unix设计思想</a>,<a href="https://book.douban.com/subject/6889456/" target="_blank" rel="noopener">Linux Shell脚本攻略</a>.前两本书购于13年,断断续续的读了许久,这一次重读令人豁然开朗,其中许多不解之处在深入理解计算机系统一书得到答案,而后两本则是年前有幸读到.其中Linux/Unix设计思想不谈技术细节,却揭示了Linux/Unix隐含的指导思想,最后一本则是从Shell出发,以实践的角度教你如何利用Shell(Bash)在Linux/Unix平台上构建有效的解决方案,实乃入门进阶必备啊.</p><h1 id="从女娲造人说起"><a href="#从女娲造人说起" class="headerlink" title="从女娲造人说起"></a>从女娲造人说起</h1><p>俗说天地开辟,未有人民,女娲抟黄土作人.剧务,力不暇供,乃引绳于泥中,举以为人.故富贵者,黄土人；贫贱人,引绳人也…</p><h2 id="神一样的程序员"><a href="#神一样的程序员" class="headerlink" title="神一样的程序员"></a>神一样的程序员</h2><p>“女娲造人”可谓人人皆知,女娲是神,而程序员是能力上最接近女娲的存在.如果说女娲创造的是真实的世界,那么程序员是创造数字的世界,我们所写下的每行代码,所构建每个程序,都在让这个数字世界变得丰富多彩.</p><p>没有哪个职业可以像程序员:赋予代码以生命,创造数字世界中的花花草草!尽管我们拥有近乎神的能力,本身却也受着NIH综合征的困扰.</p><h2 id="程序员之殇"><a href="#程序员之殇" class="headerlink" title="程序员之殇"></a>程序员之殇</h2><p>NIH综合征是什么?</p><blockquote><p>Not invented here (NIH) is a stance adopted by social, corporate, or institutional cultures that avoid using or buying already existing products, research, standards, or knowledge because of their external origins and costs.</p></blockquote><p>我们经常为NIH所困:在求解解决方案时,经常自认为可以做得更好或者在看到别人的解决方案会提出各种质疑.这大都是我们缺乏对当时问题解决者所面临限制的认识所造成:可能迫于时间或者预算的限制,也可能受限于当时物理资源的限制.</p><h2 id="穿着衣服的猴子"><a href="#穿着衣服的猴子" class="headerlink" title="穿着衣服的猴子"></a>穿着衣服的猴子</h2><p>NIH综合征的特点就是人们会为了证明自己能够提供更加卓越的解决方案而放弃其他开发人员已经完成的工作.这种狂妄自大的行径说明此人并无兴趣去维护他人竭尽全力提供的最佳成果,也不想以此为基础去挑战新的高度.NIH综合征本质上是动物天性—“嘿,我更好”的体现,就像所有的公猴都会向母猴证明”我更好”一样.</p><p>放弃已有工作成果而另起炉灶的做法无形之间浪费了大量时间.有一些技术人员在入职新公司后,往往有想推倒一切重来的欲望.我曾经有位朋友连续跳槽很多家公司,每次入职之前都信心满满,不就后就黯然离开.朋友能力很不错,但每次入职后总是急于通过推倒重来来证明自己的能力.</p><p>更糟的是,新的解决方案往往只是做了一些改进,和之前并无本质区别,再加上现代的应用往往动辄十几万行,远超出每个人所能注意的极限,这也会让程序员产生疏漏,从而使得这个问题变得更糟糕.</p><p>当然,少数情况下,新的解决方案更好,这只是因为技术人员早已了解做过的工作,从而针对问题可以提出更高的解决方案.站在现在的角度看历史,还看不出对错的话,除非你对历史一无所知.</p><p><img src="https://i.imgur.com/wKCDiEp.png" srcset="/img/loading.gif" alt="mage-20180708123207"></p><h2 id="为什么Linux会成功"><a href="#为什么Linux会成功" class="headerlink" title="为什么Linux会成功"></a>为什么Linux会成功</h2><p>Linux为什么会成功有很多的的因素,除却当时环境因素外,其成功之处在于开源的世界让每个人都能得到Linux源码,从而使得经验可以被借鉴.事实上,在原有软件基础上进行扩展是Unix的核心概念之一.当然,在Linux出现之前,借鉴他人编写的软件已成为相当普遍的做法,这也是GUN宣言中的GPL下所阐释的思想.</p><hr><h1 id="来自Unix-Linux的编程启示录"><a href="#来自Unix-Linux的编程启示录" class="headerlink" title="来自Unix/Linux的编程启示录"></a>来自Unix/Linux的编程启示录</h1><p>现在我们来看看Unix/Linux中那些隐藏的编程哲学,需要说明的是Unix/Linux中的编程哲学非常通俗易懂,他们大多是你已知的,更多的时候是我们不曾注意到.</p><p>无论你现在负责的系统多么复杂,这总有可以帮助你的地方.(要说复杂,还有什么比Unix/Linux更为复杂的应用?)</p><h2 id="小既是美"><a href="#小既是美" class="headerlink" title="小既是美"></a>小既是美</h2><p>我猜当你看到”小既是美”一词时会首先想到一句谚语”麻雀虽小,五脏俱全”.那就用麻雀做引子来说说为什么小即是美.</p><p>大凡生物,无论形体如何,愈小愈稳定.麻雀相对人而言,出现脑残鸟的几率要小的多,而单细胞生物相对多细胞生物产生显著变异体的概率也要小的多…在软件工程中,同样如此.Unix中的程序大凡遵循这条准则,小带来的显著优点如下:</p><blockquote><ol start="2"><li>易于编写</li><li>易于理解</li><li>易于维护</li><li>消耗更少的系统资源</li><li>容易与其他工具组合</li></ol></blockquote><p>尽管我知道你已经对其有过了解,我还是例行的啰嗦一下.</p><p>每个程序员心中都有编写一个万能软件的想法,渴望像上帝一样创世,能够名垂青史,但这实在是太难了.越是复杂的问题越令人畏缩不前,想想在上学期间,你是更乐于立刻开始做一道题还是一套题呢?不出意外,我们大都喜欢从一道题开始.编写小程序同样如此:我们能够尽快的动手去做,并且针对某个点找出更合理的解决方案.另外,由于大脑的结构,我们无法同时关注超过四个以上的点,而复杂的程序需要被关注的点却远大于四个,这就意味着我们可能会犯更多的错误.</p><p>小程序带来的另一个好处就是容易理解,一个100行的程序比一个1000行的程序要容易理解的多(复杂度相同的情况下).</p><p>当程序足够小的时候它就是函数,还有什么比函数更灵活地自由组合呢?当然大多数小程序不能够小到只有一个函数,但尽可能的减小程序大小仍然很重要,unix/linux中的命令便是最佳的示例:cp用来拷贝,rm用来删除,组合起来就可以实现移动,简直棒呆了.</p><p>我想,没人会认为麻雀每天摄入的能量会比人多吧?换到程序当中就是越小的程序消耗的系统资源会更少,大多数情况下如此.</p><h2 id="让每个程序只做好一件事情"><a href="#让每个程序只做好一件事情" class="headerlink" title="让每个程序只做好一件事情"></a>让每个程序只做好一件事情</h2><p>程序员也许只想编写一个简单的应用程序,但是随着他的创新精神占据上风,促使他在会在这里添加一个功能,在那里添加一个选项,很快你就发现本来你只想要一个文本编辑器,但是他却给你一个IDE,最终他给你的往往不是惊喜而是大杂烩.这个问题不但在程序员身上体现出来,同样也会出现在产品经理上:想要一个计算器对么,我这里有个超级计算机可以给你用?现在你只能面对这这么一个庞然大物了<br><img src="https://i.imgur.com/0YDZFRi.png" srcset="/img/loading.gif" alt="mage-20180708123241"></p><p>该思想和”小即是美”相辅相成,”专注一件事”的应用最终会产生一个较小的程序,而小程序往往只有单一的功能,单一功能的程序往往也会很小.另外,每个程序只做一件事情也意味着我们可以集中精力去解决当前任务,全新全意做好本职工作.</p><h2 id="建立原型"><a href="#建立原型" class="headerlink" title="建立原型"></a>建立原型</h2><p>原型的建立是学习的过程:在该过程中可以知道哪些想法可行,哪些不可行.每一个正确设计的背后都有数百个错误的设计方案,通过建立原型,我们可以在早期剔除掉不良的设计方案,以此来降低风险.换句话说,越早的建立原型,离你的软件发布的时间越近.</p><h3 id="你的软件发布了吗"><a href="#你的软件发布了吗" class="headerlink" title="你的软件发布了吗?"></a>你的软件发布了吗?</h3><p>从开始接触软件工程开始起,我们的前辈就告诉我们:”软件永远不会有开发完的时候,记住,是永远!”.</p><p>“怎么会完不成呢,我只要不做了不就行了么?”,现在想想,这比让一个沉迷在购物中的女人停下脚步更难(如果钱是无尽的话).编写软件亦如此,你永远都会想要加入的更多的功能.想加入的更多功能的可能不是你,或者是你的产品经理,当然你的boss也会掺一脚.</p><p>我一直在向周围的朋友传递这么一种观点”<strong>世界上唯有不变的事物那就是变</strong>“,对于软件工程同样如此.既然变化无可避免,那软件是怎么完成的?尽管我们做事都希望看到最后的结局,但是对于软件而言并非如此.可以说,没有做完的软件,只有发布的软件.</p><p>我曾犯过类似的错误.16年我在负责一款移动端产品的开发,希望在一个月内上线第一个版本.由于个人疏忽,当我着手原型工作时离发布时间只有20天的时间了,在这期间发现原有的一些方案无法奏效,我不得不临时更改一些既有的设计.最终导致第一个版本正式发布的时间超出15天.我也曾因此被认为是个糟糕的工程师.在团队没有任何移动应用产品开发的经验下,及早的开始建立原型或许不会导致如此后果.在离开这家公司之后,我仍倍感惭愧.</p><h2 id="舍弃高效率而取可移植性"><a href="#舍弃高效率而取可移植性" class="headerlink" title="舍弃高效率而取可移植性"></a>舍弃高效率而取可移植性</h2><p>偏向高效率往往会导致代码不可移植,而选择可移植性往往会让软件的的性能不那么尽如人意.每当有为了追求高效率而放弃移植性的想法的时候,请在心中默念以下两句话:</p><ol><li>速度欠佳的缺点会被明天的机器克服</li><li>好程序不会消失,而被移植到新平台.</li></ol><h3 id="关于优化的两点建议"><a href="#关于优化的两点建议" class="headerlink" title="关于优化的两点建议"></a>关于优化的两点建议</h3><p>在unix环境中,可移植性的含义通常意味着人们要转而采用shell脚本来编写软件.抛开平台不谈,关于优化,我有以下两点建议:</p><ul><li>不要立刻优化:如无必要,无须优化.换句话说,不要想当然的优化,尤其是在用户无感觉的情况下.</li><li>关注微优化:影响性能的往往只有几处,在需要优化的时候只要解决这几处就好,切莫以优化的名义重构全部.</li></ul><h2 id="使用纯文本来存储数据"><a href="#使用纯文本来存储数据" class="headerlink" title="使用纯文本来存储数据"></a>使用纯文本来存储数据</h2><p>文本不一定是性能最好的格式,但却是最通用的.另外,文本文件易于阅读和编辑:在任何平台上我们可以轻松的阅读文本数据,或使用标准文本编辑器对其进行编辑.</p><p>你可能会考虑到使用纯文本文件拖慢了系统的处理速度,并会找出一系列的证据来证明处理字符串的性能更低.我们承认文本文件确实拖累了系统的性能,但是记住明天系统的机器的性能必将有大幅度的提高.</p><h2 id="利用软件的杠杆效应"><a href="#利用软件的杠杆效应" class="headerlink" title="利用软件的杠杆效应"></a>利用软件的杠杆效应</h2><p>给你一个杠杆,在不考虑杠杆质量的前提下,你真的可以撬动地球.一个人精力只有这么多,如果想要取得非凡的成就,你就必须放大自己对这个世界的影响力,这就需要你找到其中的”杠杆点”,也就是关键点.</p><p><img src="https://i.imgur.com/ec39f5c.png" srcset="/img/loading.gif" alt="mage-20180708123321"></p><h3 id="君子性非异也-善假于物也"><a href="#君子性非异也-善假于物也" class="headerlink" title="君子性非异也,善假于物也"></a>君子性非异也,善假于物也</h3><p>软件中的杠杆效应就是要善于利用他人已有成果,具体点就是学会利用他人写的代码.在早期,我希望每一行代码都是从自己手中出来,并以为为傲,并认为这就是所谓的优秀的程序员.多年之后,我才明白成为一个优秀程序员的关键却和手敲每行代码并无必要联系.</p><p>善于利用他人的代码会给程序员自身增加砝码.这可能和很多人的认知相违背.查看别人工作并夸口说自己做的更好,不代表你能力更强;推导现有的方案在重来,那只是模仿不是创造.想要解决掉你手中的任务,编写更多软件的最好方法就是善于借用别人的成果.和大多程序员一样,我曾认为亲自编写代码能带来”就业保障”,并将这种做法视为核心竞争力.但实际工作中却是相反,在实现功能的前提下,企业往往认为花费时间更少的程序员更具有高效的生产了,你可能对此感到委屈和不解.这里,我想要说的是:认识企业对你的认识和你对自己认识之间的差异是非常重要的.</p><p>如果有可能,请尽量让你的工作自动化.通过加强自动化工作来利用软件的杠杆效应能产生巨大的生产力,并且能够更充分的利用好时间.如果你是个linux开发者,shell脚本便是你在寻找的杠杆点.</p><h3 id="化作春泥更护花"><a href="#化作春泥更护花" class="headerlink" title="化作春泥更护花"></a>化作春泥更护花</h3><p>从另外一个角度来说,允许他人使用你的代码来发挥杠杆作用.大部分工程师喜欢私藏自己的源代码,并视为独一无二,举世珍宝,仿佛自己的”核武器”.他们认为公开自己的源代码,自己就失去地位,会被公司所抛弃.</p><p>哪些你以为是”核武器”的代码真的就有如此威力么?要记住:任何一个有着合理思维的正常人都可以编写出像样的代码.更何况,一个有耐心的程序员完全可以将程序反汇编出来,通过一步一的分析,最终发现其中的蛛丝马迹.</p><p>Linux的开发人员认为执意保留源码的控制权并无太大必要.现在你发现,尽管你拥有全部的源码,但却仍然不能创造出比Linux更成功的操作系统.我想这足打消你心中哪点忧虑了.</p><h3 id="重新认识自豪感"><a href="#重新认识自豪感" class="headerlink" title="重新认识自豪感"></a>重新认识自豪感</h3><p>现在重新认识所谓的自豪感.很多程序员将写出优秀的代码,使用先进的技术视为自豪感,但我们最终的产出是用来服务用户的,如果用户不能满意,那么我们所谓的自豪感不过是”孤芳自赏”.</p><h2 id="使用shell脚本来提高杠杆效应和可移植性"><a href="#使用shell脚本来提高杠杆效应和可移植性" class="headerlink" title="使用shell脚本来提高杠杆效应和可移植性"></a>使用shell脚本来提高杠杆效应和可移植性</h2><p>谈起脚本语言,很多工程师觉得脚本太弱了,只能用来编写简单的应用无法工程化,并且不少程序员更乐于哪些看起来宏大的java或者net应用,甚至有些程序员认为脚本语言算不上一门语言.现实给了我们一巴掌:我们从来没有想象过javascript会有如此发展,以node为代表的新型开发平台,让整个JavaScript语言变得非常有活力.</p><p>那么我们是否也小觑了shell这种简单的脚本语言呢?有很长一段时间我不能正确的认识shell是什么,甚至觉得”嗨,这东西好像对我没什么用,它能用来干什么”.让我改变想法的恰好是15年的工作经历.</p><p>和其他脚本语言(如:python,JavaScript)一样,shell脚本同样由一个或者多个语句组成,通过调用本地程序,解释程序和其他脚本来执行任务.shell脚本将每条指令加载到内存执行.大部分情况下,这些指令是由无数的unix/linux开发者事先编写完成,我们要做的就是用shell来间接的利用这些高效,安全的代码.比如在shell中使用wget命令来下载文件时,我们实际书写的不过几行语句,背后支撑我们的确有数万行的代码,如果让你来用java写一个下载器会需要多少工程量呢,又需要耗费多少时间?现在有些程序员会反驳我:我用python写起来也很快,代码也不多?那问题来了,python的运行环境可不是先天就存在unix/linux中的,但是大部分unix/linux却都是支持shell的.如果编写的脚本程序要运行在不同的系统中或者运行在许多设备中,shell无疑具有更好的移植性,不是么?</p><h3 id="如你所想-及时运行"><a href="#如你所想-及时运行" class="headerlink" title="如你所想,及时运行"></a>如你所想,及时运行</h3><p>脚本语言有一个先天的优势就是他们是解释型的语言,运行前不需要事先编译.先来看看以C语言为代表的编译型语言,要构建一个程序的基本流程如下:<br><code>思考-&gt;编辑代码-&gt;编译-&gt;测试</code><br>而在shell当中,整个过程更短:<br><code>思考-&gt;编辑-&gt;测试</code></p><p>相比C语言,shell不存在编译过程,这带来的优势就是:无论shell的应用规模多大多复杂,只要你想你就可以运行它观察它,而无需像C语言一样等待编译过程结束后再运行.</p><h3 id="shell真的慢吗"><a href="#shell真的慢吗" class="headerlink" title="shell真的慢吗?"></a>shell真的慢吗?</h3><p>一些程序员对shell执行效率过于担忧,认为其效率太低,这就导致了他们为了更高的效率企图采用C语言来重写脚本.shell脚本的执行效率相对较慢,一旦C程序被装载到内存中运行,纯C程序与那些从脚本中调用C程序相比,并没有太大的性能优势.另外,由于Unix/Linux中大部分的命令做过相关的优化,反而会比由你编写的纯C程序更快.这也引出我想说的另外一点:为了追求更高的性能而更换语言这一做法有待商榷.如果真是为了追求性能,那么改变通过改良实现方法更有效,比如有序数列中查找指定数字采用二分查找比传统的遍历查找的时间复杂度更低,而不是将原来实现遍历查找的java代码改成C代码实现.</p><h2 id="避免强制性的用户界面"><a href="#避免强制性的用户界面" class="headerlink" title="避免强制性的用户界面"></a>避免强制性的用户界面</h2><p>我最早接触计算机系统是Windows 2000,应该是在上小学期间,尽管我不知道这个大个”计算器”能够做什么,但是却可以在没人教的情况下琢磨去做,并学会玩编辑文字,利用文本编辑器和共享来相互交流,当然,少不了的纸牌和扫雷.</p><h3 id="window和unix-linux理念差异"><a href="#window和unix-linux理念差异" class="headerlink" title="window和unix/linux理念差异"></a>window和unix/linux理念差异</h3><p>用户界面能够让任何一个小白在不需要专业知识的前提迈出操作的第一步.window系列产品和unix/linux系列产品的不同之一在于对于他们对用户的看法上:window下的设计者认为用户是畏惧和计算机打交道的,因而提供足够的用户界面来消除用户的恐惧心理,而unix的设计理念则不同,它认为一个接触unix/linux的用户已经具备了基本的计算机素养,并力求更全面的掌握它,从这个角度而言,unix/linux是选择用户的,而window是服务用户的.</p><p>这也是早期window比unix/linux更为大众所接受的关键因素之一.但随着unix/linux的逐渐发展以及大众计算机素养的提升,越来越多的人开始接受unix/linux产品,并热衷与此.</p><h3 id="像搭积木一样编程"><a href="#像搭积木一样编程" class="headerlink" title="像搭积木一样编程"></a>像搭积木一样编程</h3><p>对于程序员而言,我们希望编程应该像搭积木一样,通过不同的组合来实现多样的产品,未来的产品也应该是如此:一些程序员负责开发基础的小模块,另外一些程序员则负责将这些小模块对接成客户所需要的产品.对Unix/Linux开发者而言的确如此,我们可以利用系统中提供的众多非界面性小程序来组合成我们所需要的.但是对于提供用户界面的小程序而言我们却很难做到这点:用户界面渴望与用户沟通而非另一个程序,而模拟人在用户界面上的沟通并非易事,你需要花费更多的精力放在非核心需求上.</p><p>即使我们能够模拟,从操作效率来看也不容乐观.毕竟用户界面相对命令程序而言本身意味着更多的资源消耗,我想没人愿意在服务器上装一个KDE吧?这就是window下同样拥有众多的小程序但却很难将其组合成新产品的原因之一,换言之我们很难利用前人已产生的成果来发挥杠杆作用.</p><h3 id="嗨-我们需要再加个按钮"><a href="#嗨-我们需要再加个按钮" class="headerlink" title="嗨,我们需要再加个按钮"></a>嗨,我们需要再加个按钮</h3><p>程序员和产品之间总有一个矛盾点,来看看下面这个对话.</p><blockquote><p>PM:”这里加个按钮”<br>RD:”又没有人用,不加不行么?”<br>PM:”听我的,加上吧!加了按钮之后就会有人点击…”<br>RD:”好吧…”<br>PM:”你看这个地方空白好大,能再加一个按钮么?”<br>RD:”我….”</p></blockquote><p>好吧,这是个笑话,我并非想挑起程序员和产品之间的战争.如果你在设计/开发一个界面化的产品,你经常会不由自主的为他加上更多的按钮,企图让他提供更丰富的功能:你总觉得有人会需要它.最终导致项目更加复杂,但用户满意度却未见提升.</p><p>有这么一件事到现在对我影响甚大.我想把Kindle中的笔记导出到印象笔记,这件事情本来很简单,只需要导出指定的文本文件,解析后导入到印象笔记就可以.来看看当时我想了什么:我应该做一个界面,可以方便的我操作,别人也可能需要一个保存笔记成html格式的功能,所以我要添加个转换按钮,当然,保存,导出按钮也不能忘了,等等…要不要编辑功能?…</p><p>这非常好笑,不是么?由于我第一时间想到了图形界面,接下来不由自主地想在界面上添加更多的功能,更重要的是我明明是自己使用的,却站在别人的角度上去给自己提了需求?</p><p>如果最终呈现出的是图形化的产品,会发生很有意思的事情.来想一下,我希望它能在每天十二点自动完成导出任务?难道我要再写一个程序来模拟点击操作么?既然这样,为什么不能让两个程序有能够直接交流的能力么?(感谢unix/linux中的管道机制)</p><p>现在来看到底发生了什么?当我们想提供界面的时候,就假设是人在操作.这个隐形的假设最终让这个程序失去了自由,好比送给孩子一个用胶水粘合积木而成的城堡而非一盒积木.</p><h2 id="让每个程序都成为过滤器"><a href="#让每个程序都成为过滤器" class="headerlink" title="让每个程序都成为过滤器"></a>让每个程序都成为过滤器</h2><p>程序是什么?早期认为<code>程序=算法+数据</code>.但从功能的角度来说,程序即过滤器.</p><p>先不要着急骂我或者反驳我.你不觉得在你编写的每个程序中,无论是复杂还是简单,都是以某种形式接受数据,并产生一些数据作为输出么?这些要输出的数据不就是取决于程序中的算法么?有一些人为过滤器就该是过滤掉不符合期望的东西,而非转换,比如存在一个程序用于过滤掉集合中元素值为0的元素,这对于大部分人而言是最直观的有关过滤的理解.但要记住过滤器同样也包含转换的概念.</p><p>对于计算器而言,我们输入错误会产生错误提示,而决定产生什么样错误信息的算法就是错误状态输入的过滤器.可以说算法是人根据需求定义的规则,即算法由人定义.那数据又是怎么来的?一个没有数据输入/输出的程序就像一个不会进食和排泄的人,这种程序没有存在的价值,现实世界也不存在这种人.</p><h2 id="并行思考"><a href="#并行思考" class="headerlink" title="并行思考"></a>并行思考</h2><p>计算机界有个经典的笑话:如果一个女人要花是十个月生下一个婴儿,是否意味着能让十个女人在一个月内生出一个婴儿呢?笑话中透出的含义非常明显:自然特性导致某些任务必须被串行,任何试图让其并行运行的举动都无法加快它的进程.</p><p>在数字计算机的整个历史中,有两个需求不断的驱动我们:一是我们想计算机做的更多,令一个是我们想要计算机运行的更快.而并发则是实现这两个需求有效途径.对程序设计而言,并行思考意味着我们应该尽可能利用CPU运算性能,这也要求我们要对任务进行细致有效的分解,寻找其串行路径和并行路径.</p><p>现代操作系统通过提供进程,线程及I/O多路复用作为并行思考的实现手段,这里我们对这三者做个简单的说明:</p><blockquote><ul><li>进程:每个逻辑控制流都是一个进程,由内核来调度和维护.因为进程有独立的虚拟地址空间,想要和其他控制流通信必须依靠显示的进程间通信,即我们所说的IPC机制</li><li>I/O多路复用:应用程序在一个进程的上下文中显式地调度他们自己的逻辑流.逻辑流被模型化为状态机,数据到达文件描述符之后,主程序显式地从一个状态转换为另一个状态.因为程序都是以一个单独的进程,所以所有的流都共享同一个地址空间.基本的思路就是使用select函数要求内核挂起进程,只有一个或多个I/O事件发生后,才将控制权返回给应用程序</li><li>线程:线程应该是我们最为熟知的.它本质是运行在一个单一进程上下文中的逻辑流,由内核进行调度.</li></ul></blockquote><p>现代程序设计语言大都提供对这三种开发方式的支持,比如C,Node,Python中常用多进程/线程技术,java中的多线程及NIO技术等等.除此之外,协程也是一种不错的技术方案,比如Lua,Python中也提供了对协程的支持.关于这几种实现并发编程的技术方案,我将在随后的文章中去解析.</p><p>最后补充一点,无论机器速度快慢,我们都可以将多个机器串联在一起,从而得到一个运行速度更快的集群,这就是现代服务器技术核心之一:大凡高性能的服务器应用背后都有集群的身影,而这些集群大都依托于高性能,廉价的Unix/Linux平台.</p><h2 id="各部分之和大于整体"><a href="#各部分之和大于整体" class="headerlink" title="各部分之和大于整体"></a>各部分之和大于整体</h2><p>水泥、沙子、石子和水个各自的硬度不高,但是混合起来去能得到高硬度的混凝土.这个现实展示了一个很普通的道理就是对不同特性的物质进行组合往往能产出令人意外的结果,这种不遵循数学上”1+1=2”的规律却和化合反应非常类似.</p><p>放在软件工程中同样如此:通过组合小程序来构建集成性的应用程序.这就和我在上文中提到像搭积木一样编程.深究下来,无论是搭积木还是编程,其中共性就是<strong>组合的思想</strong>.从原子到分子,从树木到高楼大厦,从函数到程序,看似不相关的东西经组合产生出意想不到的结果,在某种意义上,组合的思想是我们人类大脑最重要的能力之一.</p><h2 id="寻找90-的解决方案"><a href="#寻找90-的解决方案" class="headerlink" title="寻找90%的解决方案"></a>寻找90%的解决方案</h2><p>“金无足赤,人无完人”这朗朗上口的话放在软件领域却代表一个不争的事实:没有一个软件能百分百的满足用户.说的更直白点,你的软件在用户看来总缺少点什么,无论你做出什么努力,这也从另一个角度说明”只有已发布的软件而没有完成的软件”.</p><h3 id="中国邮政-vs-顺丰"><a href="#中国邮政-vs-顺丰" class="headerlink" title="中国邮政 vs 顺丰"></a>中国邮政 vs 顺丰</h3><p>既然没有完美的软件,那对于软件开发者而言,有一个非常艰难的决定:”我们该向用户提供什么”.这是个非常有意思的问题,其答案取决你所开发软件的性质以及面向的用户群体.</p><p>说到这,就不得不谈起中国邮政和顺丰速递.在中国的每个地方,你都可以用中国邮政来收发快递,而顺丰却只见于经济发展不错的地区.很多人像我一样曾抱怨过邮政的效率太低,接下来感叹一句要是有顺丰该多好.现在我们客观的来谈谈同为快递这两者本质差异:邮政作为一家国企,在政府的要求下,邮政必须服务所有的人,必须提供100%的解决方案,而顺丰作为一家独立的商业公司,却可以选择性服务,通过专注于高利润且容易做到的90%.最终的结果就是我们普遍觉得顺丰具有更高的效率.</p><p>这其中的关键在于我们需要故意忽略哪些代价昂贵,费时费力或难以解决的问题.从商业的角度来说,这是一种”低投入,高回报”的解决方案.现在我们可以来谈谈软件开发了.无论你是个人开发者还是商业软件公司负责人,都应该考虑这个问题”向用户提供什么才最有价值”,然后去解决这其中的90%.这可能令很多人不适,但现在互联公司最不应该做的就是企图提供向邮政一样的100%的服务.提供90%的方案除了能获得更高的效益之外,还可以帮助聚集你的用户群体,这也是15年创业期间最大的感触之一.</p><h2 id="层次化思考"><a href="#层次化思考" class="headerlink" title="层次化思考"></a>层次化思考</h2><p>层次化思想是什么?说起来很抽象,不如直接的问自己一个问题”金字塔是如何建成的?”如果你的回答是一层一层建成的,那么你可以直接略过本章节了.</p><p><img src="https://i.imgur.com/hwkVSzg.png" srcset="/img/loading.gif" alt="mage-20180708123408"></p><p>层次化思考并并非新名词,对大部分程序员而言,”分层”是所有解决方案的指导思想,这里的分层便是层次化思考的结果.与层次化思考相关的一种分析方法是AHP(Analytic hierarchy process),即层次分析法.(关于AHP更多的信息就不多讲了),它是思考和构造复杂系统的一个基本方法,按照该方法设计出的系统具有明显的层次体系.</p><p>现实世界充斥着层次化结构,小到细胞结构大到宇宙,从小团队到跨国公司,其都呈现出层次化结构,对计算机软件而言亦如此.在层次体系中,下层构件为上层构件提供服务支撑,上层和下层之间的关系就像是方法的”调用-返回”.采用层次化设计的应用就像金字塔,先有底层构件,然后在之上构建高层构件,相对低层构件而言,高层构件更容易理解.</p><p>可以说,一个系统无论最初采用什么样的组织方式,最终都会走向分层体系.<br>我经常说的一句话是:<strong>无分层不架构</strong>,通俗点就是没有分层的应用是没有架构可言的.分层结构在计算机世界中无处不在,来看几个最典型的例子:</p><h3 id="ISO-OSI七层网络模型"><a href="#ISO-OSI七层网络模型" class="headerlink" title="ISO/OSI七层网络模型"></a>ISO/OSI七层网络模型</h3><p><img src="https://i.imgur.com/5brqCvK.png" srcset="/img/loading.gif" alt="mage-20180708123451"></p><h3 id="WEB应用分层结构"><a href="#WEB应用分层结构" class="headerlink" title="WEB应用分层结构"></a>WEB应用分层结构</h3><p><img src="https://i.imgur.com/ZAy1xwo.png" srcset="/img/loading.gif" alt="mage-20180708123512"></p><h3 id="Unix-Linux系统分层结构"><a href="#Unix-Linux系统分层结构" class="headerlink" title="Unix/Linux系统分层结构"></a>Unix/Linux系统分层结构</h3><p><img src="https://i.imgur.com/UoTUfJd.png" srcset="/img/loading.gif" alt="mage-20180708123557"></p><h3 id="Android-系统分层结构"><a href="#Android-系统分层结构" class="headerlink" title="Android 系统分层结构"></a>Android 系统分层结构</h3><p><img src="https://i.imgur.com/wFFdoJt.png" srcset="/img/loading.gif" alt="mage-20180708123632"></p><h3 id="MVC-amp-MVP"><a href="#MVC-amp-MVP" class="headerlink" title="MVC &amp; MVP"></a>MVC &amp; MVP</h3><p>除了上述几个典型示例外,两种典型的开发方式MVC 和MVP也都是典型的分层结构:<br><img src="https://i.imgur.com/ahtYCc6.png" srcset="/img/loading.gif" alt="mage-20180708123700"></p><p>无论是MVC还是MVP,亦或是MVVM,还是将来出现的什么M*P,只要记住所有的开发方式本质都是层次思考的结果,最终呈现分层体系,这就是所谓的万变不离其中.如果将分层体系和小程序结合起来,我们可以得到一个更为通用的程序结构设计图:<br><img src="https://i.imgur.com/zIFORFn.png" srcset="/img/loading.gif" alt="mage-20180708123723"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>也许你会像我当初一样纳闷这么优秀的操作系统就靠这些看起来无比简单理念引导?事实确是如此,这有点像我们所说的”大道至简”,<strong>复杂的东西简单做</strong>,也是我们解决问题的最重要的一步.</p><p>关于Unix/Linux中的编程哲学,我想以上十三条已经足够.其中最有启发的应属”小既是美”,这也是我决定以后不写长文的原因.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年轻人谈独处和自律</title>
    <link href="/2017/01/05/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%B0%88%E7%8B%AC%E5%A4%84%E5%92%8C%E8%87%AA%E5%BE%8B/"/>
    <url>/2017/01/05/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%B0%88%E7%8B%AC%E5%A4%84%E5%92%8C%E8%87%AA%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="独处与自律"><a href="#独处与自律" class="headerlink" title="独处与自律"></a>独处与自律</h1><h2 id="独处"><a href="#独处" class="headerlink" title="独处"></a>独处</h2><p>所谓独处是自己与自己相处的过程,独处不是孤僻.它是一个自己妥协,堕落,进而思考求真,最终接受喜欢自己的过程.它并非我们传统认知中的与世隔绝,更偏重于内心与周围世界的相互独立,这种感觉就像是你看电影,但电影的主角又是你.</p><p>独处可能是被动的,也可能是主动的.像我喜欢独自看书,学习,生活,很少主动与外界沟通,这就是主动独处.而同样作为北漂一族,下班之后,人生地不熟并没有太多的交际,因此而成的生活状态就是被动独处.</p><p>主动也好,被动也好,独处都是避不开的.在15年年底以及16年年底,我有两次长时间的独处,这两个阶段的独处不仅仅有与世隔绝的状态,更是内心觉悟和自我拯救的过程.</p><p>15年底我已经是一家创业公司的技术总监,在16新年来临之际,我选择了先走一步,随后便是一段长时间的独处:我在那间出租来的小房间中一个人呆着,反思一年来的得与失,几乎和外界断了联系,偶尔一好友会过来看看我.这个阶段,从开始的自己每天严格要求自己看那些书,学那些知识到中途的随心所欲,最后从麻木中醒来,历时两个月,这是我第一次能够完全拥有自己.在这个我能控制自己的时候却遇到完全不受控的自我,这段时间的经历让我开始意识到人这个独特个体为什么会不受控,转而在16年花了近乎一年的时间来学习,整理和分析”自我”,也就引出今天的话题–”自律”.</p><p><img src="https://i.imgur.com/XcaV1gX.jpg" srcset="/img/loading.gif" alt="image-20180815113405933"></p><h2 id="关于自律"><a href="#关于自律" class="headerlink" title="关于自律"></a>关于自律</h2><p>相对于自律这个词,我更喜欢用自控一次,在某种意义上,后者是包容前者并具有更深的含义.而所谓的自控则指的是自己控制自己的能力,更确切的说是自我管理自己我的能力:管理自己的心理和管理自己的行为.</p><h1 id="天使与恶魔"><a href="#天使与恶魔" class="headerlink" title="天使与恶魔"></a>天使与恶魔</h1><p>为什么我会说是自己管理自己的能力呢?在心理动力论中,人分为三种状态:本我,超我和自我.</p><p>其中”本我”指的是最原始,本能的部分,受舒适和愉悦感驱动.比如原始人饿了看到面包就吃,看见美女就想抱回家…这所有的行为都是不假思索,完完全全是为了舒适和愉悦感.而”超我”是我们在成长过程中所接受的当时社会的道德要求和行为准则,其目的是让我们的行为处在受约束的状态.比如你饿了看商店的面包不能直接拿来吃;你看到美女不能直接抱回家…这就是所谓的”超我”.可以说本我和超我就恶魔和天使之间的关系:恶魔会不断的告诉你喜欢什么便做什么好了,而天使则会告诉你怎么做才符合道德规范和行为准则.当我们饿了的时候,本我告诉你要吃能量高的汉堡,而超我告诉你吃苹果更健康.</p><p><img src="https://i.imgur.com/BUcVxLF.jpg" srcset="/img/loading.gif" alt="image-20181120154412702"></p><p>我们到底怎么做?听天使的还是恶魔的?这时候就交给”自我”来决定了.自我会根据当前社会道德和行为准备,尽可能同时满足”本我”和”超我”,或者在两者之间做出选择.</p><p>比如当你非常饿而又没有减肥的想法时,你就会听从恶魔的话吃掉那个汉堡.如果你正在减肥,那你就会听从天使的话去吃掉那个苹果.</p><p>刚出生的小孩子只有”本我”,所以在任何情况下,他饿了就会哭着要吃奶,饱了就想睡,醒了就想玩…随着他慢慢长大,周围的环境不断的告诉它:不能随便大小便,作业写完了才能玩…正是在这种在这种社会道德和行为准则的监督下,小孩子的行为逐渐变得懂事,这就是”超我”壮大的过程.在”本我”和”超我”之间要做出选择,”自我”由此而出.</p><p>在天使和恶魔,本能和道德之间,”自我”愈加强大越能做出正确的选择.比如你的boss在你生病的时候要求你出差,恶魔会说”你需要休息,你得先去医院,别管什么工作不工作”,而天使会说”认真负责,工作最重要”,而最终你做出合理”向老板请说明并请假”,即照顾了身体也保证了工作;当然你也可能选择痛骂老板一顿,然后离职走人.这种”自我”做出选择的过程就是我所说的”自我管理自我的过程”.</p><h1 id="意识和潜意识"><a href="#意识和潜意识" class="headerlink" title="意识和潜意识"></a>意识和潜意识</h1><p>“本我”和”超我”也像是潜意识和意识之间的联系,一个意识下的行为形成习惯之后就工作在潜意识领域.我们都知道跑步对身体有好处(超我),潜意识中我们并不想跑步(本我),在我们可以将其养成习惯之后(自我),我们就不会觉得每天跑步累了.这种情况下的下自我就是”初等的自我管理”,即我们能做出正确的选择,比如这里就是你刻意将跑步养成习惯的过程.</p><p>上面的例子都是在谈管理自己的行为,那现在就说说在心理状态上的自我管理.像女性每月会见亲戚一样,大部分男性每月也有心理郁闷期:做什么都兴趣,没价值,唯一想的就是什么也不想.当然,这个阶段会在”本我”的调节下会自然地消失,只是时间长短问题.如果你稍微懂些心理方面的知识,那么你就可以在”自我”的帮助下缩短这段时间,然后比别人更快的调整好状态进入新一轮的学习和工作中.再比如,人人都经历过考试,成绩差的时候我们会感觉的伤心和低落,很可能这个学期都沉浸在这种失落当中.但是”自我”可以让你更快的转变心态,更快的投入到战场上厮杀.难得你不觉得这就像是百米赛跑中,你先人一步么?</p><p><img src="https://i.imgur.com/mMxJ59m.jpg" srcset="/img/loading.gif" alt="image-20181120154456167"></p><h1 id="谁是泰格·伍兹"><a href="#谁是泰格·伍兹" class="headerlink" title="谁是泰格·伍兹"></a>谁是泰格·伍兹</h1><p>那什么是高等的自我管理.传言<a href="http://baike.baidu.com/link?url=BTZWegErbYazSNPHYwzAIroYeK22XDN5YERi_xwByVHYNUr3Dalj3YNGkieDDGy8E3_GJwwkAIklKrzPSHBnzK_10wYEn_wI3QBUDGsRwNtUaCI-P1VIpGYvQ6_hMGnVvnOJlo7LXVzQR5Y5cRLw4wpI9eeVK2IR30bO2pFS__g1u9DdtAzF-s6tmIKwhJBVF5Skzh_co-CYz94Cu2kOSqLyCTeJYWLR0IgclQLLz_u" target="_blank" rel="noopener">泰格·伍兹</a>最牛之处在于击球的一瞬间,如果他觉得状态或动作不好,他能够停止自己击球的动作.要知道成千上万次的击球练习早已让他的肌肉深深地记住击球这个动作.像这种能够意识到潜意识中的东西,并且做出控制,我称之为最高等级的”自我”,也就是”高等的自我管理”.</p><p><img src="https://i.imgur.com/MMoEpkQ.jpg" srcset="/img/loading.gif" alt="image-20180815113453461"></p><p>还以我们跑步为例,在养成跑步的习惯之后,我们能够找出目前跑步的问题所在,并且训练自己用更科学有效的手段来锻炼,这就是高等的自我管理过程.</p><p>啰里啰嗦了这么多,好像小学生写作文.但是不管怎么样,要想自律无非就是壮大”自我”的过程.</p><h1 id="拥有强大的自我"><a href="#拥有强大的自我" class="headerlink" title="拥有强大的自我"></a>拥有强大的自我</h1><p>要自律,要强大的”自我”并非立竿见影之事,不是说,我今天决定了,明天就可以做到.</p><p>在刚离职的时候,我为了自己做了非常详细的计划:每天几点写作,几点读书,几点做饭等等,仿佛我只要按照这个计划去做,那么我就是下一个”泰格·伍兹”.但现实却是:办了健身卡之后基本不去,拿起书之后基本不看,提起笔基本不写.愧疚之余,反而花了更多的时间躺在床上看电影,看小说,也自欺欺人的熬夜,说是晚上安静效率更高.</p><p>别逗了好不,晚上又是重复白天的哪些事情.你压根没法叫醒一个装睡的人.<br>循环往复,实在内疚了就起来再做个计划来聊以自慰.直到有一天,你连计划也懒得做了…雪球效应来了:你的”本我”越来越壮大,中途顺带着干死了你的”自我”,”自我”没了,”本我”继续壮大,直到Game Over.</p><p>有些书告诉我们说要养成好习惯,在我看来这简直就是匪夷所思:一个无法自律的人,你却要求用他自律来养成习惯?这比要求一个人用自己的手提着自己的头发把自己提起来一样不靠谱.</p><p>没认识到”自我”,没从根本发现问题,怎么可能解决问题,这样怎么可能咸鱼翻身?除非你被别人用铲子翻个个.</p><p>在这种与”懒惰”的斗争着,你最后死无葬身之地,已经习惯了这样的生活,咸鱼怎么可能翻身呢.</p><p><img src="https://i.imgur.com/KigFVl4.jpg" srcset="/img/loading.gif" alt="image-20180815113705031"></p><p>怎么拥有强大的”自我”,说实在,这没有人能教给你.虽然在这两年来我做了一些努力也产生了一些思考,但仍然有很多的困惑一样.正如人生的意义就是为了追求”人生的意义”一样.</p><p>尽管如此,我仍然写下一些行之有效的方法.</p><h2 id="不要做繁琐的计划"><a href="#不要做繁琐的计划" class="headerlink" title="不要做繁琐的计划"></a>不要做繁琐的计划</h2><p>你没法确定明天会发生什么,你没法用昨天的计划类规定今天的每一步.从现在开始扔掉哪些繁琐的计划表.更详细的计划表意味着更少的耐心和更多的精力去关注时间条,你能想象一个人读着秒针变认真读书是什么样的么?</p><p>我们都有一种经验:过度尝试控制时间往往适得其反.比如你今天头痛脑热,想去医院看一下,走之前你下意识的看了一下时间表却发现下一秒应该开始读书了…是先去看病还是坐下来读书?再或者,你原本计划8:00开始读书,但是因为找书错过了8:00,你心理觉得反正都错过了,要不今天就算了吧?</p><p>不做繁琐的计划不是说不做计划,精力毕竟有限,生活毕竟多变,不是么?完成取经大业的不是玄奘每天决定要走多少里地,而是追从内心,确定方向,走下去.</p><h2 id="远离魔鬼-躲避诱惑"><a href="#远离魔鬼-躲避诱惑" class="headerlink" title="远离魔鬼,躲避诱惑"></a>远离魔鬼,躲避诱惑</h2><p>你要明白自己在哪些事情面前是没有抵抗力的,然后选择避开他.很多时候,我们高估自己的意志力,实则在诱惑面前不堪一击,很少有人能在诱惑面前坚持不动摇,也不要尝试去考验自己的意志力,而是远远避开.知道毒品会上瘾就要远离它,而不是试一把;知道杀人犯法,就不要触犯它…聪明人,不是什么都选择自己尝试的人.<br>​<br>很多人告诉我们要直面诱惑,直到你对他感到习以为常.对于我们大部分的普通人来说,直面诱惑,结果就是被诱惑所诱惑.因此这句话比瘾君子碰到毒品不吸毒,酒鬼碰到美酒不喝酒一样还不靠谱.</p><p><img src="https://i.imgur.com/neG7CCU.jpg" srcset="/img/loading.gif" alt="image-20180815113649478"></p><p>尤其是独处的时候,不被魔鬼诱惑的最佳方法就是不让魔鬼找到你。</p><h2 id="保持早睡早起的习惯"><a href="#保持早睡早起的习惯" class="headerlink" title="保持早睡早起的习惯"></a>保持早睡早起的习惯</h2><p>我从08年开始就有熬夜的习惯,几乎每天晚上都在2,3点左右睡觉,到现在我明显的感觉出现了两点问题:</p><ol><li>越来越糟糕的身体状态,注意力不能像以前一样长久而专注,另外开始发胖,并且坐一会就会觉得背部酸痛,想要躺下.</li><li>越来越缓慢的思考,甚至你逃避思考,不再像以前一样可以天马行空的幻想,并且工作效率越来越低,会有意无意的逃避应该做事.</li></ol><p>这是衰老的前兆,原本发生在了中老年人身上,而今年我才25.早在大学期间我就开始意识到这个问题,但却不以为然.我假设熬夜等于努力学习,在这种自以为是在学习的状态中麻醉自己,沾沾自喜,岂不知,学习同样的知识,你耗费的时间是2倍以上,所谓事倍功半,不经意间浪费了生命.<br>​<br>在14年初,我决定要rebuild myself.我试过很多方案,有效的,无效的,直到最近我发现最简单有效的方案就是:早睡早起.<br>​<br>早睡早起是我们作为灵长类动物的本能,是我们保持健康身体和良好精神状态的根本,已经深深的内化在我们的基因当中.随着现代社会诱惑的增加,越来越多的人正在走出这道安全线,更多的数据表明现在人类的身体状态不容乐观,几乎都是处在亚健康状态,在地铁,公交上,我们看到很多年轻人昏昏欲睡,面色憔悴,精气神全无.</p><p><img src="https://i.imgur.com/5EwlmhX.jpg" srcset="/img/loading.gif" alt="image-20180815113723909"><br>​<br>最早促使我做出改变的是在16年伊始,一本讲心理学的书中谈到”每天早起的人一天可安排时间更长”,大意是,从进化的角度来看,所有的生物都认为中午12点是一天的分割线,如果说每天6点起床,那么上午就有6个小时可供你安排,如果是11点起床,那么很不好意思,我们就没什么时间可以安排了,这意味着我们的白天就只有下午的那6个小时了.<br>​<br>我给自己算了一笔账:将自己的作息习惯从凌晨2:00-10:00调整到23:00-6:00,我能获得什么?首先说明这很难算,但直觉告诉我这会让我每天多出1个小时的时间,我决定每天7点出发去公司:它可以让我再上班高峰还没来的时候提前出发去公司,于是在路上的时间从1个小时减少到40分钟.减少的这20分钟让我保持更好的体力,并且到大公司后,我可以用来阅读,然后开始全身心的投入到工作当中.另外由于上班较早,意味着我更有可能再6点左右的时候下班回家,在夏天,天还未黑,你会感觉到前所未有的放松,这意味到晚上的时间完全是你的了,你可以选择去公园散散步而不是午夜的时候匆匆的回到家里,你可以做一顿晚餐而不是吃着外卖…总之,这时候你会比晚上9点下班回家体会到更多的幸福感,有更多的时间去思考,提高自己….<br>​<br>后面也基本养成了这个习惯,每天在6:00起床,随后在6:30-8:00这个时间段内我通常会做三件事情:读书,听英语,在就是花几分钟的时间”乱想”.中午在公司会休息30分钟左右,醒来之后先发呆几分钟,然后用冷水洗个脸,继续下午的工作.大部分情况下,可以在8:00到家.从8:00-23:00,又是三个自由安排的时间,你可以选择学习你想学习的,比如我在这个阶段看了很多的技术文章,尝试了很多新技术来满足自己我,当然在16年也看了80多本有意思的书…当然,在偶尔也选择不学习,不工作,比如去找部有意思的电影来看,或者和自己的好友谈谈,和自己喜欢的姑娘聊聊天也是棒的体验.</p><p>当然,现在的时间安排更为灵活,比如在6:00-6:30之间起床都可.</p><h2 id="记录自己的成长轨迹"><a href="#记录自己的成长轨迹" class="headerlink" title="记录自己的成长轨迹"></a>记录自己的成长轨迹</h2><p>想想小学时候老师要求我们每天写日记,当时特别反感:每天哪有那么多事情可以写?又浪费玩耍的时间.现在看来,这是最能帮助我们自律的做法之一了.当前,现在可不能像以前一样通过大量的文字来记录自己,时间有限,精力有限,要采取了更简洁快速的方式.</p><p>我是怎么记录自己呢?说起来还是在大二的生活的某一天,突然有个想法蹦出来:当我老了会是什么样?高,矮,胖,瘦,美,丑,白?我决定每个周给自己留一张照片.作为一个从小就不上相的孩纸,天知道我是怎么有勇气做出这种决定.中途尽管有遗漏,但是总体的还是做得不错.</p><p>每当有所犹豫,迷茫的时候,便掏出手机看看,从12年到16年,我看到自己的成长和进步,也能回忆起当时做错了哪些事情.没有人见证你自己的时候,要学会自己见证自己,不然,怎么知道是进步了还是后退.</p><p><img src="https://i.imgur.com/BLCW6If.jpg" srcset="/img/loading.gif" alt="image-20180815113609142"></p><p>除了图片之外,在每年的开始我会给自己录一段文字,偶尔翻出来听听,都有莫名的欣喜.作为一个现在的听众,听听以前自己的声音,感受不一样的自己.</p><p>其实,记录自己的成长轨迹是引导自己反思最好的方式.这就是我们的自己的记事本,不至于当你回顾昨天却一无所获.</p><h2 id="选择性离开网络世界"><a href="#选择性离开网络世界" class="headerlink" title="选择性离开网络世界"></a>选择性离开网络世界</h2><p>在看这篇文章的时候,关掉手机通知了么?是否还在听着音乐,是不是一遍聊着天?晚上睡觉的时候是不是要抱着手机玩到入睡?每天好像从网上看到了很多信息,好像学到了知识,但是几年下来却仍然没有提高很多?</p><p>喧闹的互联网上不是今天这个明星曝绯闻,明天就是这个八卦,而这些信息真的有价值吗?十年之后,他还重要吗?互联网时代,巨多的信息对我们的判断能力提出了前所未有的挑战,想想我们在”谣言”之前脆弱的判断力就知道了.<br><img src="https://i.imgur.com/L9FOQi1.jpg" srcset="/img/loading.gif" alt="image-20180815113739626"></p><p>每天半个小时看八卦新闻,在确定看不看之前浪费5分钟,一年算下来浪费395个小时,十年下来就是3950小时,足够你在一个领域成为半个专家.</p><p>这两年来,我很少看各种八卦新闻,像今日头条,UC浏览器之类的软件统统卸掉,一来避开魔鬼二来减少自己判断的时间.另外关闭QQ空间,朋友圈,关注自己的成长和生活远比旁观别人的心情要有价值.</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>人生就是道场,活着便要修行.修行无难易,关键是沉下心去做,有句话说的不错:”Done is better than perfect”.</p><p>也不能像无头苍蝇,到处乱飞,一会参佛,一会悟道,一会礼乐…得有个小目标,无论是提高技术还是赚钱,王健林先生的”挣它一个亿”,看起来无厘头,但也道出了根本.</p><p>最后用中外两句话来致敬新年:</p><blockquote><ol><li>古人学问无遗力,少壮工夫老始成.纸上得来终觉浅,绝知此事要躬行.</li><li>Stay Hungry,Stay Foolish</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转注解之进阶篇</title>
    <link href="/2016/12/31/%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <url>/2016/12/31/%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h1><h2 id="什么是Android-apt"><a href="#什么是Android-apt" class="headerlink" title="什么是Android-apt"></a>什么是Android-apt</h2><p>我们知道APT是集成在javac当中的工具,这个Android-apt又是什么鬼呢? 对于从事Android开发的同学来说,ButterKnife这个开源工具可是非常熟悉.在使用该工具之前,你需要进行配置：</p><pre><code class="hljs groovy">compile <span class="hljs-string">'com.jakewharton:butterknife:8.4.0'</span>apt <span class="hljs-string">'com.jakewharton:butterknife-compiler:8.4.0'</span></code></pre><p>这里的有什么用?我们在上一节中没有配置apt插件照样可以用,这是怎么一回事？Anroid-apt是用在Android Studio中处理注解处理的插件,它有两方面的作用：</p><ul><li>只允许配置编译时注解处理器依赖,但在最终APK或者Library中不包含注解处理器的代码</li><li>设置源路径,以便由注解处理器生成的代码能被Android Studio识别</li></ul><p>另外,一些注解处理器可以接受外部的参数,这些参数在IDEA当中我们可以直接配置.但是基于IDEA而来的Android Studio反而无法直接配置,借助Android-apt插件我们可以实现该功能,其用法如下：</p><pre><code class="hljs groovy">apt&#123;    arguments&#123;        配置参数名称 参数值    &#125;&#125;</code></pre><p> 对与在一个jar包中的注解处理器(API和处理器)而言,我们不需要进行特殊的配置它照样可以工作,但如果我们需要在项目当中引用注解处理器生成的代码,那么就需要使用Android-apt插件来帮助解决。</p><p>对于<code>Butter Knife/EventBus 3.0</code>这类工具,由于需要引用注解处理器生成的代码,因此使用Android-apt.以EventBus配置为例:</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy641emq6mj30q50i2abe.jpg" srcset="/img/loading.gif" alt="b1"></p><p>到现在我们恍然大悟,原来Android-apt是这么用的啊.知其然更知其所以然啊,现在无论你遇到什么样的配置问题,那都是小菜一碟.现在你正在为自己明白了Android-apt的用途的时候而感到兴奋的时候,噩耗传来:android-apt插件作者近期已经发表声明表示后续不会再继续维护该插件.what fuck?</p><h2 id="什么是annotationProcessor"><a href="#什么是annotationProcessor" class="headerlink" title="什么是annotationProcessor"></a>什么是annotationProcessor</h2><p>Gradle从2.2版本开始支持annotationProcessor功能来代替Android-apt.和android-apt只支持javac编译器相比,annotationProcessor同时支持javac和jack编译器.和Android-apt使用相比,annotationProcessor使用更为简单,还是以EventBus的配置为例：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy642bexrlj30qj0ndtat.jpg" srcset="/img/loading.gif" alt="b2"></p><p>不难看出,使用annotationProcessor更为简单.如果你现在的Gradle版本是2.2.X以上,可以考虑替换掉Android-apt了.</p><h1 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h1><h2 id="项目结构划分"><a href="#项目结构划分" class="headerlink" title="项目结构划分"></a>项目结构划分</h2><p>由于编译时注解处理器只在编译过程中使用,因此我们不希望注解处理器相关的代码在最终的APK中存在,这样能够有效的较少方法数.比如我通常在编写注解Annotation Processor的时候会引用javapoet和Guava,如果将这些代码也打进最终的APK中会造成方法数的暴增,因此建议将注解处理器相关代码单独成为一个模块.另外为了方面注解被其他工程引用,通常我也建议将注解的定义单独划分成一个模块.综上，我们最终的项目结构如下：</p><ul><li>xxx/xxx-api: 主工程/提供api,Android Library类型</li><li>xxx-compiler: 注解处理器模块,Java Library类型</li><li>xxx-annotations: 自定义注解,Java Library类型</li></ul><p>xxx/xxx-api依赖xxx-annotations,xxx-compiler依赖xxx-annotations。这点<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butter Knife</a>给我们一个非常好的示范：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy643094qjj306r09vglm.jpg" srcset="/img/loading.gif" alt="b3"></p><hr><h2 id="替换jar为moudle依赖"><a href="#替换jar为moudle依赖" class="headerlink" title="替换jar为moudle依赖"></a>替换jar为moudle依赖</h2><p> 在<a href="http://blog.csdn.net/dd864140130/article/details/53875814" target="_blank" rel="noopener">基础篇</a>中我们说道,最终要将注解处理器打成jar包,这样太麻烦了,总不能每次修改都要重新打个jar包吧,然后拷贝吧？在Android Studio当中我们同样可以采用moudle依赖的形式,这和我们以前依赖其他模块并没有太大的区别,比如我们在需要使用注解处理器的地方依赖apt即可：</p><pre><code class="hljs groovy">compile project(<span class="hljs-string">":apt"</span>)</code></pre><p>但要在注解处理器moudle中的build.gradle文件中配置：</p><pre><code class="hljs groovy">sourceCompatibility = <span class="hljs-string">"1.7"</span>targetCompatibility = <span class="hljs-string">"1.7"</span></code></pre><p> 问题是moudle依赖的方式最终会导致注解处理器的代码被打包到apk中,此时我们就可以借助之前提到的Android-apt插件来避免该问题.</p><h2 id="使用-AutoService注解简化配置"><a href="#使用-AutoService注解简化配置" class="headerlink" title="使用@AutoService注解简化配置"></a>使用@AutoService注解简化配置</h2><p>在<a href="http://blog.csdn.net/dd864140130/article/details/53875814" target="_blank" rel="noopener">基础篇</a>中,我们说道需要注册处理器,该过程稍显麻烦,弄不好一个粗心就写错了,有没有什么更好的方式呢?所幸Google为我们提供的@AutoService,该注解可以快速的生成META-INF/services/中注解的配置信息.</p><p>首先添加依赖：</p><pre><code class="hljs groovy">compile <span class="hljs-string">'com.google.auto.service:auto-service:1.0-rc2'</span></code></pre><p>接下来在你的注解处理器类上使用@AutoService注解即可,如：</p><pre><code class="hljs groovy"><span class="hljs-meta">@AutoService</span>(PrintProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">PrintProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> &#123;</span><span class="hljs-comment">//...省略相关代码</span>&#125;</code></pre><p>和之前相比,整个配置注册处理的器的过程要简单多了,无需再关注 META-INF/services/的创建以手动配置注解处理器.关于该注解更多的信息请查看<a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener">这里</a>.</p><h1 id="注解处理器调试"><a href="#注解处理器调试" class="headerlink" title="注解处理器调试"></a>注解处理器调试</h1><p>对于编译时注解处理器的调试显得略微麻烦些,不同构建方式(Maven，Ant，Gradle等)会稍微有些区别,但本质上还是离不开JPDA.编译时注解处理器运行在一个单独的JVM当中,因此想要对它进行调试可以使用Remote Debug.无论是Eclipse中还是IDEA,这两个IDE工具对Remote Debug功能都提供了良好的支持.作为IDEA二次开发出的Android Studio同样也不例外.</p><p>先来看一下如何开启JVM的远程调试功能,只需要在启动JVM的时候加上以下参数即可：</p><pre><code class="hljs shell">//jdk 1.5以前写法，当然该命令是先后兼容的-J-Xdebug -J-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005//jdk 1.5及以后版本写法-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code></pre><p>这些参数的含义这里不做细说,你唯一要做的就是修改address指定一个端口号.以Android Studio中调试注解处理器为例,首先在gradle.properties中配置一下参数：</p><pre><code class="hljs shell">org.gradle.daemon=trueorg.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code></pre><p>接下来在控制台当中使用<code>gradle --daemon</code>命令来启动守护线程.</p><p>到现在为止在注解处理器工程中的配置已经完成了.接下来就需要在Android Studio中建立Remote Debugger,操作步骤如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy644mej2rg30vq0lidlr.gif" srcset="/img/loading.gif" alt="b5"></p><p>配置完之后是这样子的:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy645391cfj31c60u0tdm.jpg" srcset="/img/loading.gif" alt="b6">这里的端口号要保持一致,不然Remote Debugger是连不上gradle的守护线程的.设置完成后该Remote Debugger就可以成功的链接到deamon线程了.准备工作完成,下面就可以来调试了(别忘记加断点).具体怎么做呢?很简单,重新编译即可.这里为了方便演示,直接图形化操作:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy645pyhajg30oy0ggnhi.gif" srcset="/img/loading.gif" alt="b7"></p><p>在构建过程中,Remote Debugger将会触发断点并挂起构建过程,接下来就可以像往常一样调试了.关于注解处理的调试就到这里,其他工具大同小议,在这里就不做说明了.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有关注解开发/调试方面的问题我们已经说的差不多了.在这2016年的最后一天,我们来年再见.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>apt</tag>
      
      <tag>annotationProcessor</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转注解之基础篇</title>
    <link href="/2016/12/25/%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2016/12/25/%E7%8E%A9%E8%BD%AC%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h1><h2 id="什么是元数据-metadata"><a href="#什么是元数据-metadata" class="headerlink" title="什么是元数据(metadata)"></a>什么是元数据(metadata)</h2><p>元数据由metadata译来，所谓的元数据就是“关于数据的数据”,更通俗的说就是描述数据的数据，对数据及信息资源的描述性信息.比如说一个文本文件,有创建时间,创建人,文件大小等数据,这都可以理解为是元数据.</p><p>在java中,元数据以标签的形式存在java代码中,它的存在并不影响程序代码的编译和执行，通常它被用来生成其它的文件或运行时知道被运行代码的描述信息。java当中的javadoc和注解都属于元数据.</p><h2 id="什么是注解-Annotation"><a href="#什么是注解-Annotation" class="headerlink" title="什么是注解(Annotation)?"></a>什么是注解(Annotation)?</h2><p>注解是从java 5.0开始加入,可以用于标注包,类,方法,变量等.比如我们常见的@Override,再或者Android源码中的@hide,@systemApi,@privateApi等以@Override为例,很多人往往都是知其然而不知其所以然,今天我就来聊聊Annotation背后的秘密.</p><hr><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是定义注解的注解,是java提供给我们用于定义注解的基本注解.在java.lang.annotation包中我们可以看到目前元注解共有以下几个:</p><ol><li>@Retention</li><li>@Target</li><li>@Inherited</li><li>@Documented</li><li>@interface</li></ol><p>下面我们将集合@Override注解来解释着5个基本注解的用法.</p><h4 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h4><p>@interface是java中用于声明注解类的关键字.使用该注解表示将自动继承java.lang.annotation.Annotation类,该过程交给编译器完成.</p><p>因此我们想要定义一个注解只需要如下做即可,以@Override注解为例</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;</code></pre><blockquote><p>需要注意:在定义注解时,不能继承其他注解或接口.</p></blockquote><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention:该注解用于定义注解保留策略,即定义的注解类在什么时候存在(源码阶段 or 编译后 or 运行阶段).该注解接受以下几个参数:<code>RetentionPolicy.SOURCE,RetentionPolicy.CLASS,RetentionPolicy.RUNTIME</code>,其具体使用及含义如下:</p><table><thead><tr><th>注解保留策略</th><th>含义</th></tr></thead><tbody><tr><td>@Retention(RetentionPolicy.SOURCE)</td><td>注解仅在源码中保留,class文件中不存在</td></tr><tr><td>@Retention(RetentionPolicy.CLASS)</td><td>注解在源码和class文件中都存在,但运行时不存在,即运行时无法获得,该策略也是默认的保留策略</td></tr><tr><td>@Retention(RetentionPolicy.RUNTIME)</td><td>注解在源码,class文件中存在且运行时可以通过反射机制获取到</td></tr></tbody></table><p>来看一下@Override注解的保留策略:</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;</code></pre><p>这表明@Override注解只在源码阶段存在,javac在编译过程中去去掉该注解.</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>该注解用于定义注解的作用目标,即注解可以用在什么地方,比如是用于方法上还是用于字段上,该注解接受以下参数:</p><table><thead><tr><th>作用目标</th><th>含义</th></tr></thead><tbody><tr><td>@Target(ElementType.TYPE)</td><td>用于接口(注解本质上也是接口),类,枚举</td></tr><tr><td>@Target(ElementType.FIELD)</td><td>用于字段,枚举常量</td></tr><tr><td>@Target(ElementType.METHOD)</td><td>用于方法</td></tr><tr><td>@Target(ElementType.PARAMETER)</td><td>用于方法参数</td></tr><tr><td>@Target(ElementType.CONSTRUCTOR)</td><td>用于构造参数</td></tr><tr><td>@Target(ElementType.LOCAL_VARIABLE)</td><td>用于局部变量</td></tr><tr><td>@Target(ElementType.ANNOTATION_TYPE)</td><td>用于注解</td></tr><tr><td>@Target(ElementType.PACKAGE)</td><td>用于包</td></tr></tbody></table><p>以@Override为例,不难看出其作用目标为方法:</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;</code></pre><p>到现在,通过@interface,@Retention,@Target已经可以完整的定义一个注解,来看@Override完整定义:</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;&#125;</code></pre><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>默认情况下,我们自定义的注解用在父类上不会被子类所继承.如果想让子类也继承父类的注解,即注解在子类也生效,需要在自定义注解时设置@Inherited.一般情况下该注解用的比较少.</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>该注解用于描述其它类型的annotation应该被javadoc文档化,出现在api doc中.<br>比如使用该注解的@Target会出出现在api说明中.</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;    ElementType[] value();&#125;</code></pre><p><img src="https://i.imgur.com/IPLLZpQ.jpg" srcset="/img/loading.gif" alt="image-20181213174252458"></p><p>借助@Interface,@Target,@Retention,@Inherited,@Documented这五个元注解,我们就可以自定义注解了,其中前三个注解是任何一个注解都必备具备的.</p><p>你以为下面会直接来将如何自定义注解嘛?不,你错了,我们还是来聊聊java自带的几个注解.</p><h3 id="系统注解"><a href="#系统注解" class="headerlink" title="系统注解"></a>系统注解</h3><p>java设计者已经为我们自定义了几个常用的注解,我们称之为系统注解,主要是这三个:</p><table><thead><tr><th>系统注解</th><th>含义</th></tr></thead><tbody><tr><td>@Override</td><td>用于修饰方法,表示此方法重写了父类方法</td></tr><tr><td>@Deprecated</td><td>用于修饰方法,表示此方法已经过时</td></tr><tr><td>@SuppressWarnnings</td><td>该注解用于告诉编译器忽视某类编译警告</td></tr></tbody></table><p>如果你已经完全知道这三者的用途,跳过这一小节,直接往下看.</p><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><p>它用作标注方法,说明被标注的方法重写了父类的方法,其功能类似断言.如果在一个没有重写父类方法的方法上使用该注解,java编译器将会以一个编译错误提示:</p><p><img src="https://i.imgur.com/diMTPVu.jpg" srcset="/img/loading.gif" alt="image-20181213174408019"></p><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><p>当某个类型或者成员使用该注解时意味着<br>编译器不推荐开发者使用被标记的元素.另外,该注解具有”传递性”,子类中重写该注解标记的方法,尽管子类中的该方法未使用该注解,但编译器仍然报警.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCalculator</span> </span>&#123;        <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x+y;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplCalculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleCalculator</span> </span>&#123;    <span class="hljs-comment">// 重写SimpleCalculator中方法,但不使用@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span>  Math.abs(x)+Math.abs(y);    &#125;&#125;<span class="hljs-comment">//test code</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> SimpleCalculator().add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);        <span class="hljs-keyword">new</span> MultiplCalculator().add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);    &#125;&#125;</code></pre><p>对于像new SimpleCalculator().add(3,4)这种直接调用的,Idea会直接提示,而像第二种则不是直接提示:</p><p><img src="https://i.imgur.com/GeYF2Lz.jpg" srcset="/img/loading.gif" alt="image-20181214004922381"></p><p>但是在编译过程中,编译器都会警告:</p><p><img src="https://i.imgur.com/FHTTH8v.jpg" srcset="/img/loading.gif" alt="image-20181213174508565"></p><p>需要注意@Deprecated和@deprecated这两者的区别,前者被javac识别和处理,而后者则是被javadoc工具识别和处理.因此当我们需要在源码标记某个方法已经过时应该使用@Deprecated,如果需要在文档中说明则使用@deprecated,因此可以这么:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCalculator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@deprecated</span> deprecated As of version 1.1,</span><span class="hljs-comment">     * replace by &lt;code&gt;SimpleCalculator.add(double x,double y)&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x+y;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x+y;    &#125;      &#125;</code></pre><h4 id="SuppressWarnning"><a href="#SuppressWarnning" class="headerlink" title="@SuppressWarnning"></a>@SuppressWarnning</h4><p>该注解被用于有选择的关闭编译器对类,方法,成员变量即变量初始化的警告.该注解可接受以下参数:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>deprecated</td><td>使用已过时类,方法,变量</td></tr><tr><td>unchecked</td><td>执行了未检查的转告时的警告,如使用集合是为使用泛型来制定集合保存时的类型</td></tr><tr><td>fallthrough</td><td>使用switch,但是没有break时</td></tr><tr><td>path</td><td>类路径,源文件路径等有不存在的路径</td></tr><tr><td>serial</td><td>可序列化的类上缺少serialVersionUID定义时的警告</td></tr><tr><td>finally</td><td>任何finally字句不能正常完成时的警告</td></tr><tr><td>all</td><td>以上所有情况的警告</td></tr></tbody></table><h1 id="实战注解"><a href="#实战注解" class="headerlink" title="实战注解"></a>实战注解</h1><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>了解完系统注解之后,现在我们就可以自己来定义注解了,通过上面@Override的实例,不难看出定义注解的格式如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名 &#123;定义体&#125;</code></pre><p>定义体就是方法的集合,每个方法实则是声明了一个配置参数.方法的名称作为配置参数的名称,方法的返回值类型就是配置参数的类型.和普通的方法不一样,可以通过default关键字来声明配置参数的默认值.</p><p>需要注意:</p><ol><li>此处只能使用public或者默认的defalt两个权限修饰符</li><li>配置参数的类型只能使用基本类型(byte,boolean,char,short,int,long,float,double)和String,Enum,Class,annotation</li><li>对于只含有一个配置参数的注解,参数名建议设置中value,即方法名为value</li><li>配置参数一旦设置,其参数值必须有确定的值,要不在使用注解的时候指定,要不在定义注解的时候使用default为其设置默认值,对于非基本类型的参数值来说,其不能为null.</li></ol><p>像@Override这样,没有成员定义的注解称之为标记注解.现在我们来自定义个注解@UserMeta,这个注解目前并没啥用,就是为了演示一番:</p><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Target</span>(ElementType.CONSTRUCTOR)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UserMeta &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> </span>;&#125;</code></pre><p>有了米饭,没有筷子没法吃啊(手抓饭的走开),下面来看看如何处理注解.</p><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>上面我们已经学会了如何定义注解,要想注解发挥实际作用,需要我们为注解编写相应的注解处理器.根据注解的特性,注解处理器可以分为运行时注解处理和编译时注解处理器.运行时处理器需要借助反射机制实现,而编译时处理器则需要借助APT来实现.</p><p>无论是运行时注解处理器还是编译时注解处理器,主要工作都是读取注解及处理特定注解,从这个角度来看注解处理器还是非常容易理解的.</p><h3 id="运行时注解处理器"><a href="#运行时注解处理器" class="headerlink" title="运行时注解处理器"></a>运行时注解处理器</h3><p>熟悉java反射机制的同学一定对java.lang.reflect包非常熟悉,该包中的所有api都支持读取运行时Annotation的能力,即属性为@Retention(RetentionPolicy.RUNTIME)的注解.</p><p>在java.lang.reflect中的AnnotatedElement接口是所有程序元素的(Class,Method)父接口,我们可以通过反射获取到某个类的AnnotatedElement对象,进而可以通过该对象提供的方法访问Annotation信息,常用的方法如下:</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></td><td>返回该元素上存在的制定类型的注解</td></tr><tr><td><code>Annotation[] getAnnotations()</code></td><td>返回该元素上存在的所有注解</td></tr><tr><td><code>default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></td><td>返回该元素指定类型的注解</td></tr><tr><td><code>default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></td><td>返回直接存在与该元素上的所有注释</td></tr><tr><td><code>default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></td><td>返回直接存在该元素岸上某类型的注释</td></tr><tr><td><code>Annotation[] getDeclaredAnnotations()</code></td><td>返回直接存在与该元素上的所有注释</td></tr></tbody></table><p>编写运行时注解大体就需要了解以上知识点,下面来做个小实验.</p><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>首先我们用一个简单的实例来介绍如何编写运行时注解处理器:我们的系统中存在一个User实体类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@UserMeta</span>(id=<span class="hljs-number">1</span>,name=<span class="hljs-string">"dong"</span>,age = <span class="hljs-number">10</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.age = age;        <span class="hljs-keyword">this</span>.name = name;    &#125;  <span class="hljs-comment">//...省略setter和getter方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", age="</span> + age +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>我们希望可以通过<code>@UserMeta(id=1,name=&quot;dong&quot;,age = 10)</code>(这个注解我们在上面提到了)来为设置User实例的默认值。</p><p>自定义注解类如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.CONSTRUCTOR)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UserMeta &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;&#125;</code></pre><p>该注解类作用于构造方法，并在运行时存在，这样我们就可以在运行时通过反射获取注解进而为User实例设值,看看如何处理该注解吧.</p><p>运行时注解处理器：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(object <span class="hljs-keyword">instanceof</span> User)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"["</span> + object.getClass().getSimpleName() + <span class="hljs-string">"] isn't type of User"</span>);        &#125;        Constructor[] constructors = object.getClass().getDeclaredConstructors();        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;            <span class="hljs-keyword">if</span> (constructor.isAnnotationPresent(UserMeta<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;                UserMeta userFill = (UserMeta) constructor.getAnnotation(UserMeta<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                <span class="hljs-keyword">int</span> age = userFill.age();                <span class="hljs-keyword">int</span> id = userFill.id();                String name = userFill.name();                ((User) object).setAge(age);                ((User) object).setId(id);                ((User) object).setName(name);            &#125;        &#125;    &#125;&#125;</code></pre><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        AnnotationProcessor.init(user);        System.out.println(user.toString());    &#125;&#125;</code></pre><p>运行测试代码，便得到我们想要的结果：</p><blockquote><p>User{id=1, age=10, name=’dong’}</p></blockquote><p>这里通过反射获取User类声明的构造方法，并检测是否使用了@UserMeta注解。然后从注解中获取参数值并将其赋值给User对象。</p><p>正如上面提到，运行时注解处理器的编写本质上就是通过反射获取注解信息，随后进行其他操作。编译一个运行时注解处理器就是这么简单。运行时注解通常多用于参数配置类模块。</p><h4 id="自己动手编写ButterKnife"><a href="#自己动手编写ButterKnife" class="headerlink" title="自己动手编写ButterKnife"></a>自己动手编写ButterKnife</h4><p>对从事Android开发的小伙伴而言，ButterKnife可谓是神兵利器，能极大的减少我们书写<code>findViewById(XXX)</code>.现在，我们就利用刚才所学的运行时注解处理器来编写一个简化版的ButterKnife。</p><p>自定义注解：</p><pre><code class="hljs java"><span class="hljs-comment">//该注解用于配置layout资源</span><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ContentView &#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//只有一个返回时,可用value做名称,这样在使用的时候就不需要使用的名称进行标志</span>&#125;<span class="hljs-comment">//该注解用于配置控件ID</span><span class="hljs-meta">@Target</span>(ElementType.FIELD)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ViewInject &#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">clickable</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span>  <span class="hljs-keyword">false</span></span>;&#125;</code></pre><p>自定义运行时注解：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButterKnife</span> </span>&#123;    <span class="hljs-comment">//view控件</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViews</span><span class="hljs-params">(Object object, View sourceView)</span></span>&#123;        <span class="hljs-comment">//获取该类声明的成员变量</span>        Field[] fields = object.getClass().getDeclaredFields();        <span class="hljs-keyword">for</span> (Field field : fields)&#123;            <span class="hljs-comment">//获取该成员变量上使用的ViewInject注解</span>            ViewInject viewInject = field.getAnnotation(ViewInject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-keyword">if</span>(viewInject != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">int</span> viewId = viewInject.id();<span class="hljs-comment">//获取id参数值</span>                <span class="hljs-keyword">boolean</span> clickable = viewInject.clickable();<span class="hljs-comment">//获取clickable参数值</span>                <span class="hljs-keyword">if</span>(viewId != -<span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">try</span> &#123;                        field.setAccessible(<span class="hljs-keyword">true</span>);                        field.set(object, sourceView.findViewById(viewId));                        <span class="hljs-keyword">if</span>(clickable == <span class="hljs-keyword">true</span>)&#123;                            sourceView.findViewById(viewId).setOnClickListener((View.OnClickListener) (object));                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//布局资源</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLayout</span><span class="hljs-params">(Activity activity)</span></span>&#123;        Class&lt;? extends Activity&gt; activityClass =  activity.getClass();        ContentView contentView = activityClass.getAnnotation(ContentView<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">if</span>(contentView != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> layoutId = contentView.value();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//反射执行setContentView（）方法</span>                Method method = activityClass.getMethod(<span class="hljs-string">"setContentView"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                method.invoke(activity, layoutId);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Activity activity)</span> </span>&#123;        initLayout(activity);        initViews(activity,activity.getWindow().getDecorView());    &#125;&#125;</code></pre><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-meta">@ContentView</span>(id=R.layout.activity_main)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span>.<span class="hljs-title">OnClickListener</span> </span>&#123;    <span class="hljs-meta">@ViewInject</span>(id=R.id.tvDis,clickable = <span class="hljs-keyword">true</span>)    <span class="hljs-keyword">private</span> TextView tvDis;    <span class="hljs-meta">@ViewInject</span>(id=R.id.btnNew,clickable =<span class="hljs-keyword">true</span>)    <span class="hljs-keyword">private</span> Button btnNew;    <span class="hljs-meta">@ViewInject</span>(id =R.id.btnScreenShot,clickable = <span class="hljs-keyword">true</span>)    <span class="hljs-keyword">private</span> Button btnScreenShot;    <span class="hljs-meta">@ViewInject</span>(id =R.id.imgContainer)    <span class="hljs-keyword">private</span> ImageView imgContainer;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        AnnotationUtil.inJect(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (v.getId()) &#123;            <span class="hljs-keyword">case</span> R.id.tvDis:                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> R.id.btnNew:                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> R.id.btnScreenShot:                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>一个简单的ButterKnife就实现了，是不是非常简单。下面我们就进入本文的最重要的一点：编译时注解处理器。</p><h3 id="编译时注解处理器"><a href="#编译时注解处理器" class="headerlink" title="编译时注解处理器"></a>编译时注解处理器</h3><p>不同于运行时注解处理器，编写编译时注解处理器（Annotation Processor Tool）.</p><p>APT用于在编译时期扫描和处理注解信息.一个特定的注解处理器可以以java源码文件或编译后的class文件作为输入,然后输出另一些文件,可以是.java文件,也可以是.class文件,但通常我们输出的是.java文件.(注意:并不是对源文件修改).如果输出的是.java文件,这些.java文件回合其他源码文件一起被javac编译.</p><p>你可能很纳闷,注解处理器是到底是在什么阶段介入的呢?好吧,其实是在javac开始编译之前,这也就是通常我们为什么愿意输出.java文件的原因.</p><blockquote><p>注解最早是在java 5引入，主要包含apt和com.sum.mirror包中相关mirror api，此时apt和javac是各自独立的。从java 6开始，注解处理器正式标准化，apt工具也被直接集成在javac当中。</p></blockquote><p>我们还是回到如何编写编译时注解处理器这个话题上,编译一个编译时注解处理主要分两步：</p><ol><li>继承AbstractProcessor，实现自己的注解处理器</li><li>注册处理器,并打成jar包</li></ol><p>看起来很简单不是么?来慢慢的看看相关的知识点吧.</p><h4 id="自定义注解处理器"><a href="#自定义注解处理器" class="headerlink" title="自定义注解处理器"></a>自定义注解处理器</h4><p>首先来看一下一个标准的注解处理器的格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSupportedAnnotationTypes();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSupportedSourceVersion();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> </span>&#123;        <span class="hljs-keyword">super</span>.init(processingEnv);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>来简单的了解下其中5个方法的作用</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>init(ProcessingEnvironment processingEnv)</td><td>该方法有注解处理器自动调用，其中ProcessingEnvironment类提供了很多有用的工具类：Filter，Types，Elements，Messager等</td></tr><tr><td>getSupportedAnnotationTypes()</td><td>该方法返回字符串的集合表示该处理器用于处理那些注解</td></tr><tr><td>getSupportedSourceVersion()</td><td>该方法用来指定支持的java版本，一般来说我们都是支持到最新版本，因此直接返回<code>SourceVersion.latestSupported(）</code>即可</td></tr><tr><td>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</td><td>该方法是注解处理器处理注解的主要地方，我们需要在这里写扫描和处理注解的代码，以及最终生成的java文件。其中需要深入的是RoundEnvironment类，该用于查找出程序元素上使用的注解</td></tr></tbody></table><p>编写一个注解处理器首先要对ProcessingEnvironment和RoundEnvironment非常熟悉。接下来我们一览这两个类的风采.首先来看一下ProcessingEnvironment类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProcessingEnvironment</span> </span>&#123;    <span class="hljs-function">Map&lt;String,String&gt; <span class="hljs-title">getOptions</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//Messager用来报告错误，警告和其他提示信息</span>    <span class="hljs-function">Messager <span class="hljs-title">getMessager</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//Filter用来创建新的源文件，class文件以及辅助文件</span>    <span class="hljs-function">Filer <span class="hljs-title">getFiler</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//Elements中包含用于操作Element的工具方法</span>    <span class="hljs-function">Elements <span class="hljs-title">getElementUtils</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//Types中包含用于操作TypeMirror的工具方法</span>    <span class="hljs-function">Types <span class="hljs-title">getTypeUtils</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">SourceVersion <span class="hljs-title">getSourceVersion</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>重点来认识一下Element，Types和Filer。Element（元素）是什么呢？</p><h5 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h5><p>element表示一个静态的，语言级别的构件。而任何一个结构化文档都可以看作是由不同的element组成的结构体，比如XML，JSON等。这里我们用XML来示例：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">subchild</span>&gt;</span>.....<span class="hljs-tag">&lt;/<span class="hljs-name">subchild</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></code></pre><p>这段xml中包含了三个元素：<code>&lt;root&gt;,&lt;child&gt;,&lt;subchild&gt;</code>,到现在你已经明白元素是什么。对于java源文件来说，他同样是一种结构化文档：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.closedevice;             <span class="hljs-comment">//PackageElement</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;                  <span class="hljs-comment">//TypeElement</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;                  <span class="hljs-comment">//VariableElement</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span>&#123;                 <span class="hljs-comment">//ExecuteableElement</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String msg)</span></span>&#123; <span class="hljs-comment">//其中的参数部分String msg为TypeElement</span>        &#125;&#125;</code></pre><p>对于java源文件来说，Element代表程序元素：包，类，方法都是一种程序元素。另外如果你对网页解析工具jsoup熟悉，你会觉得操作此处的element是非常容易，关于jsoup不在本文讲解之内。</p><p>接下来看看看各种Element之间的关系图图,以便有个大概的了解：</p><p><img src="https://i.imgur.com/uWN6nCD.jpg" srcset="/img/loading.gif" alt="image-20181213174606408"></p><table><thead><tr><th>元素</th><th>含义</th></tr></thead><tbody><tr><td>VariableElement</td><td>代表一个 字段, 枚举常量, 方法或者构造方法的参数, 局部变量及 异常参数等元素</td></tr><tr><td>PackageElement</td><td>代表包元素</td></tr><tr><td>TypeElement</td><td>代表类或接口元素</td></tr><tr><td>ExecutableElement</td><td>代码方法，构造函数，类或接口的初始化代码块等元素，也包括注解类型元素</td></tr></tbody></table><h5 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a>TypeMirror</h5><p>这三个类也需要我们重点掌握：<br><strong>DeclaredType</strong>代表声明类型：类类型还是接口类型，当然也包括参数化类型，比如<code>Set&lt;String&gt;</code>，也包括原始类型</p><p><strong>TypeElement</strong>代表类或接口元素，而DeclaredType代表类类型或接口类型。</p><p><strong>TypeMirror</strong>代表java语言中的类型.Types包括基本类型，声明类型（类类型和接口类型），数组，类型变量和空类型。也代表通配类型参数，可执行文件的签名和返回类型等。TypeMirror类中最重要的是<code>getKind()</code>方法，该方法返回TypeKind类型，为了方便大家理解，这里附上其源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> TypeKind &#123;    BOOLEAN,BYTE,SHORT,INT,LONG,CHAR,FLOAT,DOUBLE,VOID,NONE,NULL,ARRAY,DECLARED,ERROR,  TYPEVAR,WILDCARD,PACKAGE,EXECUTABLE,OTHER,UNION,INTERSECTION;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimitive</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-keyword">case</span> BOOLEAN:        <span class="hljs-keyword">case</span> BYTE:        <span class="hljs-keyword">case</span> SHORT:        <span class="hljs-keyword">case</span> INT:        <span class="hljs-keyword">case</span> LONG:        <span class="hljs-keyword">case</span> CHAR:        <span class="hljs-keyword">case</span> FLOAT:        <span class="hljs-keyword">case</span> DOUBLE:            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre><p>简单来说，Element代表源代码，TypeElement代表的是源码中的类型元素，比如类。虽然我们可以从TypeElement中获取类名，TypeElement中不包含类本身的信息，比如它的父类，要想获取这信息需要借助TypeMirror，可以通过Element中的<code>asType()</code>获取元素对应的TypeMirror。</p><p>然后来看一下RoundEnvironment,这个类比较简单,一笔带过:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RoundEnvironment</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">processingOver</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//上一轮注解处理器是否产生错误</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">errorRaised</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//返回上一轮注解处理器生成的根元素</span>    Set&lt;? extends Element&gt; getRootElements();   <span class="hljs-comment">//返回包含指定注解类型的元素的集合</span>    Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a);    <span class="hljs-comment">//返回包含指定注解类型的元素的集合</span>    Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a);&#125;</code></pre><h5 id="Filer"><a href="#Filer" class="headerlink" title="Filer"></a>Filer</h5><p>Filer用于注解处理器中创建新文件。具体用法在下面示例会做演示.另外由于Filer用起来实在比较麻烦,后面我们会使用<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>简化我们的操作.</p><p>好了,关于AbstractProcessor中一些重要的知识点我们已经看完了.假设你现在已经编写完一个注解处理器了,下面,要做什么呢?</p><h4 id="打包并注册"><a href="#打包并注册" class="headerlink" title="打包并注册."></a>打包并注册.</h4><p>自定义的处理器如何才能生效呢?为了让java编译器或能够找到自定义的注解处理器我们需要对其进行注册和打包：自定义的处理器需要被打成一个jar，并且需要在jar包的META-INF/services路径下中创建一个固定的文件javax.annotation.processing.Processor,在javax.annotation.processing.Processor文件中需要填写自定义处理器的完整路径名，有几个处理器就需要填写几个。</p><p>从java 6之后，我们只需要将打出的jar防止到项目的buildpath下即可，javac在运行的过程会自动检查javax.annotation.processing.Processor注册的注解处理器，并将其注册上。而java 5需要单独使用apt工具,java 5想必用的比较少了,就略过吧.</p><p>到现在为止,已经大体的介绍了与注解处理器相关的一些概念,最终我们需要获得是一个包含注解处理器代码的jar包,接下来,来实践一把.</p><h4 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h4><p>用个简单的示例,来演示如何在Gradle来创建一个编译时注解处理器,为了方便起见,这里就直接借助Android studio.当然你也可以采用maven构建.</p><p>首先创建AnnotationTest工程,在该工程内创建apt moudle.需要注意,AbstractProcessor是在javax包中,而android 核心库中不存在该包,因此在选择创建moudle时需要选择java Library:</p><p><img src="https://i.imgur.com/U9CywNv.jpg" srcset="/img/loading.gif" alt="image-20181213180827227"></p><p>此时项目结构如下:</p><p><img src="https://i.imgur.com/zVBka0J.jpg" srcset="/img/loading.gif" alt="image-20181213181840673"></p><p>接下在我们在apt下创建annotation和processor子包,其中annotation用于存放我们自定义的注解,而processor则用于存放我们自定义的注解处理器.</p><p>先来个简单的,自定义@Print注解:该注解最终的作用是输出被注解的元素:</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)  <span class="hljs-meta">@Retention</span>(RetentionPolicy.CLASS)                                  <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Print &#123;                                     &#125;</code></pre><p>接下来为其编写注解处理器:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> Messager mMessager;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;        <span class="hljs-keyword">super</span>.init(processingEnvironment);        mMessager = processingEnvironment.getMessager();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;        <span class="hljs-keyword">for</span> (TypeElement te : annotations) &#123;            <span class="hljs-keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(te)) &#123;<span class="hljs-comment">//find special annotationed element</span>                print(e.toString());<span class="hljs-comment">//print element</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SourceVersion.latestSupported();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;        LinkedHashSet&lt;String&gt; annotations = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();        annotations.add(Print<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getCanonicalName</span>())</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSupportedAnnotationTypes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String msg)</span> </span>&#123;        mMessager.printMessage(Diagnostic.Kind.NOTE, msg);    &#125;&#125;</code></pre><p>现在我们完成了一个简单的注解.在编译阶段,编译器将会输出被注解元素的信息.由于我们是在Gradle环境下,因此该信息将在Gradle Console下输出.</p><p>接下来我们编写一个稍微难点的注解@Code,该注解会生成一个指定格式的类,先看看该注解的定义:</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(CLASS)<span class="hljs-meta">@Target</span>(METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Code &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">author</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">date</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre><p>接下来,我们需要为其编写注解处理器,代码比较简单,直接来看:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String SUFFIX = <span class="hljs-string">"$WrmRequestInfo"</span>;    <span class="hljs-keyword">private</span> Messager mMessager;    <span class="hljs-keyword">private</span> Filer mFiler;    <span class="hljs-keyword">private</span> Types mTypeUtils;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;        <span class="hljs-keyword">super</span>.init(processingEnvironment);        mMessager = processingEnvironment.getMessager();        mFiler = processingEnvironment.getFiler();        mTypeUtils = processingEnvironment.getTypeUtils();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SourceVersion.latestSupported();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;        LinkedHashSet&lt;String&gt; annotations = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();        annotations.add(Code<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getCanonicalName</span>())</span>;        <span class="hljs-keyword">return</span> annotations;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Element e : roundEnvironment.getElementsAnnotatedWith(Code<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;<span class="hljs-comment">//find special annotationed element</span>            Code ca = e.getAnnotation(Code<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            TypeElement clazz = (TypeElement) e.getEnclosingElement();            <span class="hljs-keyword">try</span> &#123;                generateCode(e, ca, clazz);            &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,                        x.toString());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//generate </span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateCode</span><span class="hljs-params">(Element e, Code ca, TypeElement clazz)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        JavaFileObject f = mFiler.createSourceFile(clazz.getQualifiedName() + SUFFIX);        mMessager.printMessage(Diagnostic.Kind.NOTE, <span class="hljs-string">"Creating "</span> + f.toUri());        Writer w = f.openWriter();        <span class="hljs-keyword">try</span> &#123;            String pack = clazz.getQualifiedName().toString();            PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(w);            pw.println(<span class="hljs-string">"package "</span> + pack.substring(<span class="hljs-number">0</span>, pack.lastIndexOf(<span class="hljs-string">'.'</span>)) + <span class="hljs-string">";"</span>); <span class="hljs-comment">//create package element</span>            pw.println(<span class="hljs-string">"\n class "</span> + clazz.getSimpleName() + <span class="hljs-string">"Autogenerate &#123;"</span>);<span class="hljs-comment">//create class element</span>            pw.println(<span class="hljs-string">"\n    protected "</span> + clazz.getSimpleName() + <span class="hljs-string">"Autogenerate() &#123;&#125;"</span>);<span class="hljs-comment">//create class construction</span>            pw.println(<span class="hljs-string">"    protected final void message() &#123;"</span>);<span class="hljs-comment">//create method</span>            pw.println(<span class="hljs-string">"\n//"</span> + e);            pw.println(<span class="hljs-string">"//"</span> + ca);            pw.println(<span class="hljs-string">"\n        System.out.println(\"author:"</span> + ca.author() + <span class="hljs-string">"\");"</span>);            pw.println(<span class="hljs-string">"\n        System.out.println(\"date:"</span> + ca.date() + <span class="hljs-string">"\");"</span>);            pw.println(<span class="hljs-string">"    &#125;"</span>);            pw.println(<span class="hljs-string">"&#125;"</span>);            pw.flush();        &#125; <span class="hljs-keyword">finally</span> &#123;            w.close();        &#125;    &#125;&#125;</code></pre><p>核心内容在<code>generateCode()</code>方法中,该方法利用上面我们提到的Filer来写出源文件.你会发现,这里主要就是字符创拼接类的过程嘛,真是太麻烦了.</p><p>到现在为止,我们已经编写好了两个注解及其对应的处理器.现在我们仅需要对其进行配置.</p><p>在resources资源文件夹下创建META-INF.services,然后在该路径下创建名为javax.annotation.processing.Processor的文件,在该文件中配置需要启用的注解处理器,即写上处理器的完整路径,有几个处理器就写几个,分行写幺,比如我们这里是:</p><pre><code class="hljs plain">com.closedevice.processor.PrintProcessorcom.closedevice.processor.CodeProcessor</code></pre><p>到现在我们已经做好打包之前的准备了,此时项目结构如下:</p><p><img src="https://i.imgur.com/cPoQ3Tm.jpg" srcset="/img/loading.gif" alt="1"></p><p>下面就需要将apt moudle打成jar包.无论你是在什么平台上,最终打出jar包就算成功一半了.为了方便演示,直接可视化操作:</p><p><img src="https://i.imgur.com/IYYI7N6.jpg" srcset="/img/loading.gif" alt="2"></p><p>来看一下apt.jar的结构:</p><p><img src="https://i.imgur.com/7gXIi2V.jpg" srcset="/img/loading.gif" alt="a3"></p><p>接下来将apt.jar文件复制到主moudle app下的libs文件夹中,开始使用它.我们简单的在MainActivity.java中使用一下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Print</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        process();    &#125;    <span class="hljs-meta">@Code</span>(author = <span class="hljs-string">"closedevice"</span>,date=<span class="hljs-string">"20161225"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;            &#125;&#125;</code></pre><p>分别在onCreate()和process()方法中使用我们的注解,现在编译app模块,在编译过程中你可以在Gradle Console看到输出的信息,不出意外的话,你讲看到一下信息:</p><p><img src="https://i.imgur.com/EkUOK9s.jpg" srcset="/img/loading.gif" alt="a5"></p><p>另外在app moudle的<code>build/intermediates/classes/debug/com/closedevice/annotationtest</code>就可以看到自动生成的MainActivityAutogenerate.class了.当然你也可以直接查看编译阶段生成的源码文件:</p><p><img src="https://i.imgur.com/sRKS1Ps.jpg" srcset="/img/loading.gif" alt="a6"></p><p>再来看看自动生成的源代码:</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.closedevice.annotationtest; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivityAutogenerate</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MainActivityAutogenerate</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//process()</span><span class="hljs-comment">//@com.closedevice.annotation.Code(date=20161225, author=closedevice)</span>        System.out.println(<span class="hljs-string">"author:closedevice"</span>);        System.out.println(<span class="hljs-string">"date:20161225"</span>);    &#125;&#125;</code></pre><p>将该工程部署到我们的模拟器上,不出意外,会看到以下日志信息:</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy5cmcox25j30c401s3yn.jpg" srcset="/img/loading.gif" alt="a7"></p><p>就这样,一个简单的编译时注解处理器就实现了.上面我们利用运行时注解处理器来做了个简单的ButterKnife,但真正ButterKnife是利用编译是利用APT来实现的,限于篇幅,这一小节就不做演示了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文初步介绍了运行时注解处理器和编译时注解处理器,但是有关APT的内容绝非一文可以说明白的,我将在后面逐步介绍有关APT的相关知识.<a href="https://github.com/closedevice/MagicAnnotation" target="_blank" rel="noopener">完整示例</a></p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNI开发之RegisterNatives</title>
    <link href="/2016/12/20/RegisterNatives%E4%BD%BF%E7%94%A8/"/>
    <url>/2016/12/20/RegisterNatives%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>JNI开发流程相对比较固定,一般需要经过以下几步:</p><ol><li>定义Native方法</li><li>生成.h头文件</li><li>编写C/C++文件</li><li>生成本地链接库</li></ol><p>这里简单的写一个例子来演示上述流程.</p><h1 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h1><h2 id="定义Native方法"><a href="#定义Native方法" class="headerlink" title="定义Native方法"></a>定义Native方法</h2><p>为了说明流程,我们直接在根目录中创建Hello.java:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.loadLibrary(<span class="hljs-string">"hi"</span>);        Hello hello = <span class="hljs-keyword">new</span> Hello();        hello.say();    &#125;&#125;</code></pre><p>需要注意如果链接库中有多个native方法,只需要一次<code>System.loadLibrary()</code>.链接库在不同的平台中后缀不同:</p><ul><li><p>window以.dll结尾</p></li><li><p>macOS以.jnilib结尾</p></li><li><p>linux中以.so结尾</p><p>不要弄错,否则会导致UnsatisfiedLinkError.</p></li></ul><h2 id="javah生成-h头文件"><a href="#javah生成-h头文件" class="headerlink" title="javah生成.h头文件"></a>javah生成.h头文件</h2><p>Java中提供javah命令用于生成.h头文件.这里我们执行<code>javah Hello</code>命令即可生成对应的Hello.h.</p><pre><code class="hljs c"><span class="hljs-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><span class="hljs-comment">/* Header for class Hello */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _Included_Hello</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _Included_Hello</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Class:     Hello</span><span class="hljs-comment"> * Method:    say</span><span class="hljs-comment"> * Signature: ()V</span><span class="hljs-comment"> */</span><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_Hello_say</span> <span class="hljs-params">(JNIEnv *, jobject)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>.h头文件名</strong>遵循格式:<code>Package_ClassName</code>,由于此处我们未创建包结构,因此Hello.java生成的.h文件名中省略了Package部分,即<code>Hello.h</code></p><p><strong>.h头文件方法名</strong>遵循格式<code>Java_{Package_ClassName}_{FunctionName}(JNI arguments)</code>比如<code>JNIEXPORT void JNICALL Java_Hello_say (JNIEnv *, jobject)</code>,</p><p><strong>jni.h</strong>是jdk中C语言库的头文件，在编译.c的时候需要指定jni.h的所在位置,否则会编译失败,在macOS中,其所在位置:<code>System/Library/Frameworks/JavaVM.framework/Headers</code>.</p><h2 id="编写C-C-文件"><a href="#编写C-C-文件" class="headerlink" title="编写C/C++文件"></a>编写C/C++文件</h2><p>有了.h头文件后,就可以为真正编写对应实现,这里创建了Hello.cpp,在方法输出Hello world.</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Hello.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">/* 方法名需要和.h中声明的保持一致,不要弄错,否则会UnsatisfiedLinkError */</span>JNIEXPORT <span class="hljs-keyword">void</span> JNICALL Java_Hello_say  (JNIEnv *, jobject)&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello world!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  &#125;</code></pre><h2 id="生成链接库"><a href="#生成链接库" class="headerlink" title="生成链接库"></a>生成链接库</h2><p>完成C/C++文件编写以后,通过以下命令将Hello.cpp编译成动态链接库.</p><pre><code class="hljs shell">g++ -fPIC -shared -o libhi.jnilib Hello.cpp -I/System/Library/Frameworks/JavaVM.framework/Headers</code></pre><ul><li>-fPIC : 要求编译器生成与位置无关的代码,否则会导致链接库在内存中无法被正确加载</li><li>-shared : 要求编译器生成共享链接库.使用该选项时必须指定-fPIC选项</li><li>-o : 该选项后需要指定动态链接库名字,需要保证其后缀名和运行平台对应,比如linux下是.so,mac下是.jnilib</li><li>-I : 该选项后需要指定jni.h文件所在的路径</li></ul><p><img src="https://i.imgur.com/eYe0HzY.png" srcset="/img/loading.gif" alt="image-20180829122221898"></p><p>接下来通过命令:<code>java Hello</code>运行主程序:</p><pre><code class="hljs java">Hello world!</code></pre><p>这里为了省事,我直接用g++来编译.</p><h1 id="JNI注意事项"><a href="#JNI注意事项" class="headerlink" title="JNI注意事项"></a>JNI注意事项</h1><p>在JNI开发过程中我们经常会遇到类问题:一是.h文件创建失败,另一类是调用过程,经常会遇到UnsatisfiedLinkError,</p><h2 id="h创建失败"><a href="#h创建失败" class="headerlink" title=".h创建失败"></a>.h创建失败</h2><p>在有些情况,通过javah创建.h文件时,可能会遇到错误:<code>Error: Could not find class file for &#39;XXX&#39;</code>.产生该问题的原因一般由于javah中路径指定有问题.在上述例子中由于我们Hello.java不存在包结构,因此在根目录下执行’javah Hello’会正常生成.h文件.但如果项目结构如下所示:</p><p><img src="https://i.imgur.com/LuHDXns.png" srcset="/img/loading.gif" alt="image-20180829133113486"></p><p>此时需要先进入src目录下,然后在该目录下执行如下命令:<code>javah -d jni com.lionoggo.Hello</code>即可,此处<code>-d</code>参数用来指定头文件存放路径.</p><p><img src="https://i.imgur.com/2mYpnI1.png" srcset="/img/loading.gif" alt="image-20180829133317779"></p><h2 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h2><p>该错误一般由于链接库路径不对或者链接库自身问题导致.</p><ol><li><p>链接库路径问题</p><p>如果链接库和主程序不在同一目录内,在执行时需要指定链接库路径,如下目录结构:</p><p><img src="https://i.imgur.com/KFscKtJ.png" srcset="/img/loading.gif" alt="image-20180829142537772"></p></li></ol><p>此时在执行主程序时需要指定路径:<code>java -Djava.library.path=./lib Hello</code></p><ol start="2"><li><p>链接库本身</p><p>此处需要注意在macOS中动态链接库的后缀为jnilib,因此这里不要写成’g++ -fPIC -shared -o libhi.so …’,否则会导执行Java程序抛出以下错误:</p></li></ol><pre><code class="hljs java">Exception in thread <span class="hljs-string">"main"</span> java.lang.UnsatisfiedLinkError: no hi in java.library.pathat java.lang.ClassLoader.loadLibrary(ClassLoader.java:<span class="hljs-number">1867</span>)at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="hljs-number">870</span>)at java.lang.System.loadLibrary(System.java:<span class="hljs-number">1122</span>)at Hello.main(Hello.java:<span class="hljs-number">5</span>)</code></pre><h1 id="RegisterNatives解耦Native方法"><a href="#RegisterNatives解耦Native方法" class="headerlink" title="RegisterNatives解耦Native方法"></a>RegisterNatives解耦Native方法</h1><p>回过头来看上述Native的方法名:</p><pre><code class="hljs c++"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_Hello_say</span> <span class="hljs-params">(JNIEnv *, jobject)</span></span>;</code></pre><p>在没有包名的前提下,该方法看起来没什么问题,但是现在假设我们存在包名结构:<code>com.lionoggo.ireader</code>,那这个方法名就会变得很长:</p><pre><code class="hljs c++"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_lionoggo_ireader_Hello_say</span> <span class="hljs-params">(JNIEnv *, jobject)</span></span>;</code></pre><p>除此之外,每个方法都要带固定的<code>JNIEXPORT void JNICALL</code>,这就导致无法将Native方法名修改为更简洁的方式.JNI中提供了<code>RegisterNatives()</code>为Java中的Native方法动态绑定某个具体Native的实现方法.</p><h2 id="JNI-OnLoad-JNI-OnUnload"><a href="#JNI-OnLoad-JNI-OnUnload" class="headerlink" title="JNI_OnLoad/JNI_OnUnload"></a>JNI_OnLoad/JNI_OnUnload</h2><p>JNI组件被成功加载和卸载时,回回调响应的函数.当JVM执行执行<code>System.loadLibrary()</code>时会调用JNI组件的<code>JNI_ONLoad(JavaVm *vm,void *reserved)</code>,当VM释放JNI组件时会调用<code>JNI_OnUnload()</code>.</p><pre><code class="hljs c"><span class="hljs-comment">/* Defined by native libraries. */</span><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-keyword">void</span> *reserved)</span></span>;<span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">JNI_OnUnload</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-keyword">void</span> *reserved)</span></span>;</code></pre><p>要在JNI组件被加载时动态绑定Native方法,那么<code>JNI_OnLoad()</code>就是个非常好的时机,这里结合刚才提到的<code>RegisterNatives</code>来为Java中Native方法绑定具体的实现.</p><h2 id="RegisterNatives"><a href="#RegisterNatives" class="headerlink" title="RegisterNatives"></a>RegisterNatives</h2><pre><code class="hljs c"><span class="hljs-function">jint <span class="hljs-title">RegisterNatives</span><span class="hljs-params">(jclass clazz, <span class="hljs-keyword">const</span> JNINativeMethod* methods,</span></span><span class="hljs-function"><span class="hljs-params">        jint nMethods)</span></span></code></pre><p>该方法是JNI环境提供的用来注册Native方法的方法.期三个参数含义如下:</p><ul><li>clazz: Java Native类</li><li>methods: 用来注册的Native方法数组</li><li>nMethods: 用来注册的Native方法数目</li></ul><h2 id="JNINativeMethod"><a href="#JNINativeMethod" class="headerlink" title="JNINativeMethod"></a>JNINativeMethod</h2><p>JNINativeMethod是jni.h中定义的结构体,用来描述Native方法,macOS中可以在路径<code>System/Library/Frameworks/JavaVM.framework/Headers/jni.h</code>找到:</p><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * used in RegisterNatives to describe native method name, signature,</span><span class="hljs-comment"> * and function pointer.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">char</span> *name;       <span class="hljs-comment">// native方法名</span>    <span class="hljs-keyword">char</span> *signature;  <span class="hljs-comment">// native方法签名</span>    <span class="hljs-keyword">void</span> *fnPtr;      <span class="hljs-comment">// native函数指针</span>&#125; JNINativeMethod;</code></pre><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>有了JNI_OnLoad和RegisterNatives后,我们就可以来实现Native方法的动态注册了,这里仍然之前的Hello.java作为演示,其过程相对固定,主要分为三步:</p><ol><li><p>根据需要实现相应的Native方法:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello world!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</code></pre></li><li><p>定义需要被绑定的本地方法.</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> JNINativeMethod methods[] = &#123;    <span class="hljs-comment">//java类native方法名|方法签名|Native实现方法名</span>&#123;<span class="hljs-string">"say"</span>,<span class="hljs-string">"()V"</span>,(<span class="hljs-keyword">void</span>*)sayHello&#125;,&#125;;</code></pre></li><li><p>实现JNI_OnLoad方法,并使用RegisterNatives绑定java和native方法对应关系:</p><pre><code class="hljs c"><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-keyword">void</span> *reserved)</span></span><span class="hljs-function"></span>&#123;    JNIEnv* env;    <span class="hljs-comment">// 1.获取JNI环境对象</span>    <span class="hljs-keyword">if</span> (JNI_OK != vm-&gt;GetEnv(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>**&gt; (&amp;env),JNI_VERSION_1_4)) &#123;        <span class="hljs-comment">//LOGW("JNI_OnLoad could not get JNI env");</span>        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    <span class="hljs-comment">// 2.获取Java Native类</span>    g_jvm = vm;    jclass clazz = env-&gt;FindClass(classPathName);  <span class="hljs-comment">//获取Java NativeLib类</span>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    <span class="hljs-comment">// 3.调用RegisterNatives注册Native方法</span>    <span class="hljs-keyword">if</span> (env-&gt;RegisterNatives(clazz, methods, <span class="hljs-keyword">sizeof</span>(methods)/<span class="hljs-keyword">sizeof</span>((methods)[<span class="hljs-number">0</span>])) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    <span class="hljs-keyword">return</span> JNI_VERSION_1_4;&#125;</code></pre></li></ol><p>经过以上三部,就可以实现动态绑定Native方法了.HelloRegister.cpp的完整代码如下:</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>JavaVM* g_jvm;<span class="hljs-comment">// Method define start</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello world!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">// Method define end</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * classPathName = <span class="hljs-string">"com/lionoggo/Hello"</span>;<span class="hljs-keyword">static</span> JNINativeMethod methods[] = &#123;    <span class="hljs-comment">//java类native方法名|方法签名|Native实现方法名</span>&#123;<span class="hljs-string">"say"</span>,<span class="hljs-string">"()V"</span>,(<span class="hljs-keyword">void</span>*)sayHello&#125;,&#125;;<span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-keyword">void</span> *reserved)</span></span><span class="hljs-function"></span>&#123;    JNIEnv* env;    <span class="hljs-comment">// 1.获取JNI环境对象</span>    <span class="hljs-keyword">if</span> (JNI_OK != vm-&gt;GetEnv(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>**&gt; (&amp;env),JNI_VERSION_1_4)) &#123;        <span class="hljs-comment">//LOGW("JNI_OnLoad could not get JNI env");</span>        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    g_jvm = vm;    <span class="hljs-comment">// 2.获取Java Native类</span>    jclass clazz = env-&gt;FindClass(classPathName);    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    <span class="hljs-comment">// 3.调用RegisterNatives注册Native方法</span>    <span class="hljs-keyword">if</span> (env-&gt;RegisterNatives(clazz, methods, <span class="hljs-keyword">sizeof</span>(methods)/<span class="hljs-keyword">sizeof</span>((methods)[<span class="hljs-number">0</span>])) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> JNI_ERR;    &#125;    <span class="hljs-keyword">return</span> JNI_VERSION_1_4;&#125;</code></pre><p>将其打包成本地链接库libhi.jnilib,然后像之前一样执行Hello.java即可.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RegisterNatives除了能解决原来JNI中方法遵循特定方法命名规则外,还具备以下两个优点:</p><ul><li><p>VM查找Native效率的提高</p><p>在调用Native方法时,VM需要多次在本地链接库中进行查找,多次调用就会产生多次查找.而通过RegisterNatives注册后,VM的查找次数会减少.</p></li><li><p>在执行期间进行Native方法的替换.</p><p>在methods通过函数指针来绑定方法,这意味着我们可以在运行期间多次调用RegisterNatives来实现Native方法的替换.</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html" target="_blank" rel="noopener">Java Native Interface</a></p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android杂谈:从模块化到组件化</title>
    <link href="/2016/12/15/Android%E6%9D%82%E8%B0%88:%E4%BB%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E5%88%B0%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <url>/2016/12/15/Android%E6%9D%82%E8%B0%88:%E4%BB%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E5%88%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化和组件化"><a href="#模块化和组件化" class="headerlink" title="模块化和组件化"></a>模块化和组件化</h1><p>以下高能,请做好心理准备,看不懂请发邮件来交流.本文不推荐新手阅读,如果你刚接触Android开发不久,请立刻放弃阅读本文</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>组件化不是个新概念,其在各行各业都一直备受重视.至于组件化什么时候在软件工程领域提出已经无从考究了,不过呢可以确认的是组件化最早应用于服务端开发,后来在该思想的指导下,前端开发和移动端开发也产生各自的开发方式.</p><p>在了解组件化之前,先来回顾下<a href="https://en.wikipedia.org/wiki/Modular_programming" target="_blank" rel="noopener">模块化</a>的定义</p><blockquote><p>Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.</p></blockquote><p>简单来说,模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块,汽车的发送机也可是一个模块.</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>现在来看看”组件化开发”,这里我们看一下其<a href="https://en.wikipedia.org/wiki/Component-based_software_engineering" target="_blank" rel="noopener">定义</a>:</p><blockquote><p>Component-based software engineering (CBSE), also known as component-based development (CBD), is a branch of software engineering that emphasizes the separation of concerns in respect of the wide-ranging functionality available throughout a given software system. It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software.</p></blockquote><p>通俗点就是:组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，已较少耦合。</p><p>咋样一看还是非常抽象,说了这么多好像还是不明白.什么是组件呢?组件可以是模块、web资源,软件包,比如汽车的发动机是一个模块,也是一个组件,再或者前端中的一个日历控件是一个模块,也一个组件.</p><h2 id="模块化-vs-组件化"><a href="#模块化-vs-组件化" class="headerlink" title="模块化 vs 组件化"></a>模块化 vs 组件化</h2><p>当你看到这的时候,想必心理一阵恶寒:模块化?组件化?到底是什么鬼?有啥区别.<br>有这种感觉才是对的,模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦.</p><h2 id="组件化优缺点"><a href="#组件化优缺点" class="headerlink" title="组件化优缺点"></a>组件化优缺点</h2><p>组件化开发的好处是显而易见:系统级的控制力度细化到组件级的控制力度,一个复杂系统的构建最后就是组件集成的结果.每个组件都有自己独立的版本,可以独立的编译,测试,打包和部署产品组件化后能够实现完整意义上的按需求进行产品配置和销售,用户可以选择使用那些组件,组件之间可以灵活的组建.</p><p>配置管理,开发,测试,打包,发布完全控制到组建层面,并带来很多好处.比如一个组件小版本进行升级,如果对外提供的接口没有发生任何变化,其他组件完全不需要再进行测试.</p><p>但是组件化的实施对开发人员和团队管理者提出了更高水平的要求.相对传统方式,在项目的管理和组织上难度加大,要求开发人员对业务有更深层次上的理解.</p><hr><h1 id="Android项目实践"><a href="#Android项目实践" class="headerlink" title="Android项目实践"></a>Android项目实践</h1><h2 id="为什么要在Android中实行组件化开发"><a href="#为什么要在Android中实行组件化开发" class="headerlink" title="为什么要在Android中实行组件化开发"></a>为什么要在Android中实行组件化开发</h2><p>为什么要在Android中实行组件化开发呢,其根本原因在于业务的增长提高了项目的复杂性,为了更好的适应团队开发,提高开发效率,实行组件化乃大势所趋.为了更好的帮助大家理解上面这句话,我将从最早的Android 项目开发方式说起.</p><h3 id="简单开发模型"><a href="#简单开发模型" class="headerlink" title="简单开发模型"></a>简单开发模型</h3><p>所谓的简单开发模型是最基础的开发方式,工程中没有所谓的模块,没有所谓的规划,常见于初学者学习阶段或者是个人学习过程所写的demo,其结构大概如下:</p><p><img src="https://i.imgur.com/VwrYIL4.jpg" srcset="/img/loading.gif" alt="image-20181214110345831"></p><p>不难发现,往往是在一个界面中存在着大量的业务逻辑,而业务逻辑中充斥着各种各种网络请求,数据操作等行为,整个项目中没有所谓的模块的概念,项目组成的基本单位不是模块,而是方法级的.</p><p>关于这种开发模型没什么需要介绍的,我们早期都经历过,现在除了很少非常古老的项目以及初学者练手之作,已经很少见到.</p><h3 id="单工程开发模型"><a href="#单工程开发模型" class="headerlink" title="单工程开发模型"></a>单工程开发模型</h3><p>该种开发模型已经有了明确的模块划分,并且通过逻辑上的分层呈现出较好结构,该模型最为我们所熟悉,通常用于早期产品的快速开发,团队规模较小的情况下.该种开发模型结构如下:</p><p><img src="https://i.imgur.com/iKmaIEz.jpg" srcset="/img/loading.gif" alt="image-20181214110516196"></p><p>随着产品的迭代,业务越来越复杂,随之带来的是项目结构复杂度的极度增加,此时我们面临着几个问题:</p><ol><li>实际业务变化非常快,但是工程之前的业务模块耦合度太高,牵一发而动全身.</li><li>对工程所做的任何修改都必须要编译整个工程</li><li>功能测试和系统测试每次都要进行.</li><li>团队协同开发存在较多的冲突.不得不花费更多的时间去沟通和协调,并且在开发过程中,任何一位成员没办法专注于自己的功能点,影响开发效率.</li><li>不能灵活的对工程进行配置和组装.比如今天产品经理说加上这个功能,明天又说去掉,后天在加上.</li></ol><p>在面临这些问题的前提下,我们重新来思考组件化,看看它是否能解决我们在Android 项目开发中所遇到的难题.</p><h3 id="主工程多组件开发模型"><a href="#主工程多组件开发模型" class="headerlink" title="主工程多组件开发模型"></a>主工程多组件开发模型</h3><p>借助组件化这一思想,我们在”单工程”模型的基础上,将业务层中的各业务抽取出来,封装成相应的业务组件,将基础库中各部分抽取出来,封装成基础组件,而主工程是一个可运行的app,作为各组件的入口(主工程也被称之为壳程序).这些组件或以jar的形式呈现,或以aar的形式呈现.主工程通过依赖的方式使用组件所提供的功能.</p><p><img src="https://i.imgur.com/34Is4zJ.jpg" srcset="/img/loading.gif" alt="image-20181214110610910"></p><p>(需要注意这是理想状态下的结构图,实际项目中,业务组件之间会产生通信,也会产生依赖,关于这一点,我们在下文会谈)</p><p>不论是jar还是aar,本质上都是Library,他们不能脱离主工程而单独的运行.当团队中成员共同参与项目的开发时,每个成员的开发设备中必须至少同时具备主工程和各自负责组件,不难看出通过对项目实行组件化,每个成员可以专注自己所负责的业务,并不影响其他业务,同时借助稳定的基础组件,可以极大减少代码缺陷,因而整个团队可以以并行开发的方式高效的推进开发进度.</p><p>不但如此,组件化可以灵活的让我们进行产品组装,要做的无非就是根据需求配置相应的组件,最后生产出我们想要的产品.这有点像玩积木,通过不同摆放,我们就能得到自己想要的形状.</p><p>对测试同学而言,能有效的减少测试的时间:原有的业务不需要再次进行功能测试,可以专注于发生变化的业务的测试,以及最终的集成测试即可.</p><p>到现在为止,我们已经有效解决了”单工程开发模型”中一些问题,对于大部分团队来说这种已经可以了,但是该模型仍然存在一些可以改进的点:每次修改依赖包,就需要重新编译生成lib或者aar.比如说小颜同学接手了一个项目有40多个组件,在最后集成所有组件的时候,小颜同学发现其中某组件存在问题,为了定位和修改该组件中的问题,小颜同学不断这调试该组件.由于在该模型下,组件不能脱离主工程,那么意味着,每次修改后,小颜同学都要在漫长的编译过程中等待.更糟糕的是,现在离上线只有5小时了,每次编译10分钟,为改这个bug,编译了20次,恩….什么也不用干了,可以提交离职报告了</p><p>如何解决这种每次修改组件都要连同主工程一起编译的问题?下面我们来看主工程多子工程开发模型是如何解决该问题的.</p><h3 id="主工程多子工程开发模型"><a href="#主工程多子工程开发模型" class="headerlink" title="主工程多子工程开发模型"></a>主工程多子工程开发模型</h3><p>该种开发模型在”主工程多组件”开发模型的基础上做了改进,其结构图如下:</p><p><img src="https://i.imgur.com/iCJiHL9.jpg" srcset="/img/loading.gif" alt="image-20181214110637269"></p><p>不难发现,该种开发模型在结构上和”主工程多组件”并无不同,唯一的区别在于:所有业务组件不再是mouble而是作为一个子工程,基础组件可以使moudle,也可以是子工程,该子工程和主工程不同:Debug模式下下作为app,可以单独的开发,运行,调试;Release模式下作为Library,被主工程所依赖,向主工程提供服务.</p><p>在该种模型下,当小颜同学发现某个业务组件存在缺陷,会如何做呢?比如是基础组件2出现问题,由于在Debug模式下,基础组件2作为app可以独立运行的,因此可以很容易地对该模块进行单独修改,调试.最后修改完后只需要重新编译一次整个项目即可.</p><p>不难发现该种开发模型有效的减少了全编译的次数,减少编译耗时的同时,方便开发者进行开发调试.</p><p>对测试同学来说,功能测试可以提前,并且能够及时的参与到开发环节中,将风险降到最低.</p><p>到现在,我们在理论层次上讲明了采用组件化开发给我们带来的便利,空口无凭是没有说服力的,在下面的一小节中,我们来谈谈如何组件化在Android中的实施过程.</p><h2 id="组件化过程中遇到的问题"><a href="#组件化过程中遇到的问题" class="headerlink" title="组件化过程中遇到的问题"></a>组件化过程中遇到的问题</h2><h3 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h3><p>组件化首要做的事情就是划分组件.如何划分并没有一个确切的标准,我建议早期实施组件化的时候,可以以一种”较粗”的粒度来进行,这样左右的好处在于后期随着对业务的理解进行再次细分,而不会有太大的成本.当然,我建议划分组件这一工作有团队架构人员和业务人员协商定制.</p><h3 id="子工程工作方式切换"><a href="#子工程工作方式切换" class="headerlink" title="子工程工作方式切换"></a>子工程工作方式切换</h3><p>在”主工程多子工程模型”中,我们提到子工程在Debug模式下做为单独的Application运行,在Release模式下作为Library运行,如何去动态修改子工程的运行模式呢?我们都知道采用Gradle构建的工程中,用<code>apply plugin: &#39;com.android.application&#39;</code>来标识该为Application,而<code>apply plugin: &#39;com.android.library&#39;</code>标志位Library.因此,我们可以在编译的是同通过判断构建环境中的参数来修改子工程的工作方式,在子工程的gradle脚本头部加入以下脚本片段:</p><pre><code class="hljs groovy"><span class="hljs-keyword">if</span> (isDebug.toBoolean()) &#123;    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.application'</span>&#125; <span class="hljs-keyword">else</span> &#123;    apply <span class="hljs-string">plugin:</span> <span class="hljs-string">'com.android.library'</span>&#125;</code></pre><p>除此之外,子工程中在不同的运行方式下,其AndroidMainifest.xml也是不相同的,需要为其分别提供自己AndroidManifest.xml文件:在子工程src目录下(其他位置创建)创建两个目录,用来存放不同的AndroidManifest.xml,比如这里我创建了debug和release目录</p><p><img src="https://i.imgur.com/a3Ic3Tj.jpg" srcset="/img/loading.gif" alt="这里写图片描述"><br>接下来同样需要在该子工程的gradle构建脚本中根据构建方式制定:</p><pre><code class="hljs groovy">android &#123;    sourceSets &#123;        main &#123;            <span class="hljs-keyword">if</span>(isDebug.toBoolean()) &#123;                manifest.srcFile <span class="hljs-string">'src/debug/AndroidManifest.xml'</span>            &#125; <span class="hljs-keyword">else</span> &#123;                manifest.srcFile <span class="hljs-string">'src/release/AndroidManifest.xml'</span>            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="组件通信与组件依赖"><a href="#组件通信与组件依赖" class="headerlink" title="组件通信与组件依赖"></a>组件通信与组件依赖</h3><p>在”主工程多组件”这种理想模型下业务组件是不存在相互通信和依赖的,但现实却是相反的,如下图:</p><p><img src="https://i.imgur.com/gq0JE8I.jpg" srcset="/img/loading.gif" alt="image-20181214110748460"></p><p>这里,业务组件1和业务组件3同时向业务组件2提供服务,即业务组件2需要同时依赖业务组件3和业务组件1.</p><p>现在我们再来看一种更糟糕的情况:</p><p><img src="https://i.imgur.com/5puinLp.jpg" srcset="/img/loading.gif" alt="image-20181214110817901"></p><p>由此看来,在业务复杂的情况下,组件与组件之间的相互依赖会带来两个问题:</p><ul><li>重复依赖:比如可能存在业务组件3依赖业务组件1,而业务组件2又依赖业务组件3和业务组件1,此时就导致了业务组件1被重复依赖.</li><li>子系统通信方式不能依靠传统的显示意图.在该种模型下,使用显示意图将导致组件高度耦合.比如业务组件2依赖业务组件1,并通过显示意图的方式进行通信,一旦业务组件1不再使用,那么业务组件2中使用现实意图的地方会出现错误,这显然与我们组件化的目的背道而驰.</li></ul><h4 id="解决组件通信"><a href="#解决组件通信" class="headerlink" title="解决组件通信"></a>解决组件通信</h4><p>先来解决业务组件通信问题.当年看到上面那张复杂的组件通信图时,我们不难想到操作系统引入总线机制来解决设备挂载问题,同样,借用总线的概念我们在工程添加”组件总线”,用于不同组件间的通信,此时结构如下:</p><p><img src="https://i.imgur.com/ABv4JnM.jpg" srcset="/img/loading.gif" alt="image-20181214110906701"></p><p>所有挂载到组件总线上的业务组件,都可以实现双向通信.而通信协议和HTTP通信协议类似,即基于URL的方式进行.至于实现的方式一种可以基于系统提供的隐式意图的方式,另一种则是完全自行实现组件总线.这篇文章不打算在此不做详细说明了.</p><h4 id="解决重复依赖"><a href="#解决重复依赖" class="headerlink" title="解决重复依赖"></a>解决重复依赖</h4><p>对于采用aar方式输出的Library而言,在构建项目时,gradle会为我们保留最新版本的aar,换言之,如果以aar的方式向主工程提供提供依赖不会存在重复依赖的问题.而如果是直接以project形式提供依赖,则在打包过程中会出现重复的代码.解决project重复依赖问题目前有两种做法:1.对于纯代码工程的库或jar包而言,只在最终项目中执行compile,其他情况采用provider方式;2.在编译时检测依赖的包,已经依赖的不再依赖</p><h3 id="资源id冲突"><a href="#资源id冲突" class="headerlink" title="资源id冲突"></a>资源id冲突</h3><p>在合并多个组件到主工程中时,可能会出现资源引用冲突,<br>最简单的方式是通过实现约定资源前缀名(resourcePrefix)来避免,需要在组件的gradle脚本中配置:</p><pre><code class="hljs groovy">andorid&#123;...buildTypes&#123;...&#125;resourcePrefix <span class="hljs-string">"moudle_prefix"</span>&#125;</code></pre><p>一旦配置resourcePrefix,所有的资源必须以该前缀名开头.比如上面配置了前缀名为moudle_prefix,那么所有的资源名都要加上该前缀,如:mouble_prefix_btn_save.</p><h3 id="组件上下文-Context"><a href="#组件上下文-Context" class="headerlink" title="组件上下文(Context)"></a>组件上下文(Context)</h3><p>最后需要注意在Debug模式下和Release模式下,所需要的Context是否是你所希望的,以避免产生强转异常.</p><hr><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>最早接触组件化这个概念是在从事广告SDK工作中,最近陆续续的做了一些总结,因此有了这篇关于”组件化开发”的文章.另外,组件化开发不是银弹,并不能完全解决当前业务复杂的情况,在进行项目实施和改进之前,一定要多加考量.</p><p>敬请期待第二篇,我们将在第二篇内介绍如何对项目实施组件化.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
      <tag>组件化</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android SDK设计与开发(一)</title>
    <link href="/2016/12/10/%E8%B0%88Android%20SDK%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91(%E4%B8%80)/"/>
    <url>/2016/12/10/%E8%B0%88Android%20SDK%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h1><h2 id="什么是SDK"><a href="#什么是SDK" class="headerlink" title="什么是SDK"></a>什么是SDK</h2><p>SDK是Software Development Kit的缩写,译为”软件开发工具包”,通常是为辅助开发某类软件而编写的特定软件包,框架集合等,SDK一般包含相关文档,范例和工具.</p><p>SDK可以分为系统SDK和应用SDK.所谓的系统SDK是为特定的软件包,软件框架,硬件平台,操作系统等简历应用时所使用的开发工具集合.而应用SDK则是基于系统SDK开发的独立于具体业务而具有特定功能的集合.比如在进行Android 应用开发时,我们使用Google提供的系统SDK(Android SDK),而我们经常使用的友盟SDK,极光SDK则是基于系统SDK开发的.</p><h2 id="什么是Library"><a href="#什么是Library" class="headerlink" title="什么是Library"></a>什么是Library</h2><p>Library即我们所说的库,通常是一组或者几组类的集合,通常是应用中某些功能的具体实现或者对系统已有功能的增强或补充.对Android开发者而言,最常见的莫过于是Support Library,另外就是我们经常使用各种网络请求库(OkHttp,Volley),数据库操作,图片加载库(Glide,ImageLoader)等.</p><h2 id="什么是Framework"><a href="#什么是Framework" class="headerlink" title="什么是Framework"></a>什么是Framework</h2><p>Framework即我们所说的框架,通常是系统或者应用的骨架,很多时候,它表现为一组抽象的构建及构件实例间交互的方法.因此,可以认为,Framework规定了应用的体系结构,阐明了整体设计,写作构件之间的依赖关系以及控制流程.注意自处的Framework并不完全等同于你所熟知的Android Framework框架,可以认为Android Framework中体现了Framework的思想,并进行了实现.</p><h2 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API"></a>什么是API</h2><p>API是Application Programming Interface,又称为应用编程接口，是软件系统不同组成部分衔接的约定。更加通俗的说就API就是我们常见和编写的方法或函数.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>明确了上面提到的概念之后,现在就可以来描述这四者之间的关联:<br>SDK主要包含Framework,API及Library的三部分.Framework定义了SDK整体的可重用设计,规定了SDK各功能模块的职责以及依赖关系.其中个功能模块体现为Library.模块之间的内部通信及SDK外部通信(SDK对外提供服务的接口)则通过API进行.</p><p>另外完整的SDK还应该包含大量的示例和其他工具.比如在Android SDK的tools目录下提供了大量的辅助开发工具.</p><p>对我们而言,大部分情况下是为某种具体的业务需求开发对应的SDK,以便作为第三正提供给其他需求方使用.比如百度推送的SDK主要实现消息推送功能,需求方只需要集成百度推送的SDK便可以使自己应用具备推送功能.</p><p>到现在已经介绍了SDK的主要构成,接下来我们重点来介绍SDK的实现目标以及在SDK架构中的一些核心点.</p><h1 id="浅谈SDK实现目标"><a href="#浅谈SDK实现目标" class="headerlink" title="浅谈SDK实现目标"></a>浅谈SDK实现目标</h1><p>上面介绍了开发中常见的概念,现在来谈谈SDK的实现目标.任何应用都应具备:简洁易用,稳定,高效,轻量,SDK作为一种特定应用当然也不例外.</p><h2 id="简洁易用"><a href="#简洁易用" class="headerlink" title="简洁易用"></a>简洁易用</h2><p>按照”奥卡姆剃须刀”理论,一个好的产品对第三方使用者使用而言应该是简洁易用,不用改让使用者花费太长时间学习的.这对SDK同样适用—SDK不应该对宿主应用有过多的代码侵入,也不应该有复杂频繁的接入工作.比如当开发者需要使用SDK的服务时,只需要在缘由的代码中新增一行即可.常见的SDK初始化如下:</p><pre><code class="hljs plain">public class Ad&#123;    @TargetApi(9)    public synchronized static void init(Context context, SdkParams params) &#123;        &#x2F;&#x2F;省略多行代码    &#125;&#125;</code></pre><p>当我们需要使用该SDK的服务时,通过一行代码便可启用<code>Ad.init(this,params)</code></p><p>要保证较少的代码侵入主要在对外提供服务时充分考虑到使用者的使用场景来设计出优良的API.一个优良的API在定义的时候应该满足绝大数开发者所预期的方式—语义上要求通俗易懂,使用上要求简单可靠.</p><p>一个优良的API首先是简单可靠的.在正常使用的情况下体现为稳定可靠的执行,在异常情况下体现为及时的告知使用者使用错误.初次之外,遵循一致的明明规则,并是所有的API呈现出一致的风格对开发而言无疑是个好消息.</p><h2 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h2><p>站在SDK使用者角度来看,我们期望第三方的SDK服务应该是稳定高效的,体现在提供稳定可靠的服务,在不影响宿主稳定性的前提下足够的高效,这就要求我们SDK设计者在设计并实现SDK时要尽可能的做到以下几点:</p><ul><li>对外提供稳定的API.SDK的API一旦确定,如无非常严重情况不可更改.作为提供服务方,发生API变更所带来的变更成本非常大.</li><li>对外提供稳定的业务.在稳定的API后,必须要有稳定的业务来支撑.</li><li>SDK运行时的稳定,作为服务提供方,我们必须确保SDK自身运行的稳定,并且保证接入方不会因为我们的SDK产生不稳定的情况.</li><li>版本稳定更新.和面向普通用户的应用相比,SDK版本的迭代是非常缓慢的.并且需要尽可能的对开发者屏蔽迭代过程,以免给开发者带来不必要的适配开销.</li></ul><h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>无论是普通的应用开发还是SDK开发,都应该考虑到性能问题,SDK设计者应该着重考虑以下问题:</p><ul><li>更少的内存占用.在不使用多进程的情况下,SDK服务和宿主程序运行在同一进程中,这种情况下必须要求限制SDK内存的占用,不能因为说因为我们SDK占用太多的内存资源,导致应用的存活时间变短.</li><li>更少的内存抖动.在占用更少内存的前提下,SDK设计者必须刻意的减少反复GC造成的内存抖动问题.</li><li>更少的电量消耗.尽管很多时候无法对电量消耗做一个很好的权衡,但是仍然有一些可以参考的做法,比如减少使用耗电模块的时间.比如在使用定位服务时,不要求非常高的精度下优先使用网络定位而不是GPS定位.</li><li>更少的流量消耗.</li></ul><h1 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h1><p>SDK的架构实现决定了SDK后续的维护难度,因此有必要在此对SDK整体架构中的一些点做些简单的说明.</p><h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><p>根据单一职责将系统拆分为不同的小模块，每个模块保持相对独立。模块之间通过协议或接口通信，以减少相互之间的依赖耦合.模块内部按照设计的几大原则进行实现,以保证模块本身可以灵活实现</p><p>对于现代开发而言,模块化是常用的手段,从宏观角度来看,模块是系统最小的组成单元.</p><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>组件开发同样是个老生常提的概念,但从我个人的感受来说,组件是对逻辑的封装,并具备单个可移植性.比如可以把日志记录做成一个组件,之后它可以被轻松在应用在不同的项目中.对于android 开发者而言,Android 提供的每个UI 控件同样也是组件,比如Button,TextView等.</p><p>在明确了组件这一概念之后,组件化开发也就不难理解:所谓的组件化就是将整个项目划分成多个模块,几个模块或者单个模块作为一个组件,开发过程中我们可以对每个组件进行并行开发,最后发布时通过依赖将组件合并成完整的应用.</p><p>那为什么要使用组件化呢?<br>随着android的逐渐成熟,现在的app业务越来越复杂,与此同时,android工程也变得日益庞大,代码行数十几万已经是常态,此时有几个问题便会凸显出来:</p><ol><li>工程任何一点改动都会造成整个工程的重新编译.记忆最深的就是早期在没有进行组件化的时候,庞大的工程动辄需要十几分钟的编译时间,一杯茶的时间就出来了,很多时候,不得不眼巴巴的等着,尽管现在可以使用facebook出品的buck以及来自阿里的feeline来加速编译过程,单仍然不够.</li><li>整个工程中充斥的大量重复或者冗余的子模块,业务耦合度非常高,牵一发而动全身.这就造成了”老人不敢改,新人无法改”,因为谁也不能预知在做修改之后,会产生什么影响.</li><li>协作开发基本上是不可能的,天知道彼此在做什么.代码合并的的时候更是令人痛苦.</li><li>不方便测试.高度耦合的业务和模块导致无法下手进行测试,只能草草了事.</li></ol><p>通过引入组件化,上面遇到的问题便可迎刃而解.在SDK当中,根据实际情况对其进行组件化,比如我们将分享功能组件化,可以轻松的支持多种渠道的分享,在需要更新分享功能时,可以对其进行单独的编译和测试.</p><p>通过组件化,我们也可以轻松的实现SDK的定制功能,通过编写编译脚本,我们可以决定哪些组件被依赖,最终合并到完整的应用当中.比如友盟中的提供的可定制分享组件(如下图)的原理就是如此.</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1ft55hqkqlyj319k0owaq6.jpg" srcset="/img/loading.gif" alt="mage-20180710224805"></p><h2 id="插件化开发"><a href="#插件化开发" class="headerlink" title="插件化开发"></a>插件化开发</h2><p>什么是插件化开发这里就不做介绍了,一方面插件化并不是个新概念,另外就是插件化到目前为止理论层次上已经非常成熟,不想15念开始研究的时候资料相对较少.</p><p>在SDK中为什么使用插件化呢?SDK不同于普通应用,不能频繁的进行更新,以免让开发者觉得SDK不稳定或者让开发者频繁的集成.SDK看起来变化较慢,实则变化频繁.就以以前做的广告SDK而言,有时候经常需要对某类机型进行数据采集或者及时更新反作弊模块,在没有使用插件化之前,解决该问题是非常麻烦的.但是在我们利用插件化之后,解决该问题就变得非常容易:我们将SDK整体划分为两部分:宿主和插件.宿主只向开发者提供必要的服务接口,并提供了自定义插件加载器.而核心的逻辑则是存在于插件中.当需要采集数据的时候,只需要由开发人员开发好数据采集插件并下发到指定设备即可;当需要修复SDK缺陷时,同样也只需要下发新的插件包即可.</p><p>通过在SDK使用插件化方案,可以有效的对开发者屏蔽手动更新的过程.宿主相对稳定,一旦确定,一般不会变动,而后续的业务变化则只需要通过更新插件来支撑.</p><p>除了上面谈到的利用插件化解决动态更新之外,通过将整个工程分为宿主和插件可以实现宿主的并行开发和分开编译,并且能有效的解决方法数65535的限制.在没有使用插件化之前,我们整个项目是由很多组件通过依赖形成的庞大工程,不得不通过</p><h2 id="SDK初始化"><a href="#SDK初始化" class="headerlink" title="SDK初始化"></a>SDK初始化</h2><p>和应用开发不同,很多情况下SDK没有自身的上下文Context,而必须要借助应用提供.SDK初始化的常见做法:<code>Ad.init(Context context,AdParams params)</code>,我们往往推荐开发者在应用Application组件中的onCreate()中去掉用该方法,这就意味着该初始化过程是同步的,假如SDK本身初始化时间较长,就会影响应用的启动速度.</p><p>在这种情况下,作为SDK的设计者必须着手解决该问题.通常将SDK服务进一步划分成核心服务和辅助服务,之后通过并行初始化和延迟初始化的手段来减少SDK初始化耗时.曾经在我所负责的广告SDK中,有开发者反馈我们的SDK启动较慢,通过对整个SDK启动流程进行分析后,我们将插件加载服务和云控服务并行初始化,而对于像日志服务则采用颜值初始化,通过该手段有效的减少了初始化耗时</p><h2 id="云更新控制"><a href="#云更新控制" class="headerlink" title="云更新控制"></a>云更新控制</h2><p>云控服务作为一种服务端控制客户端的手段在SDK中开发中非常重要,现在的SDK开发可以不支持插件化,但是必须要提供云控服务,以便让服务端能控制SDK,比如在不需要进行数据采集的时候,可以通过云控服务关闭SDK采集功能,在需要的时候在将其打开.</p><p>对本身是基于插件化开发的SDK而言,云控服务更是不可或缺.</p><p>从实现的角度而言,云控服务分为服务端主动和客户端主动.服务端主动是指服务端会将最新的云控开关的信息推送到SDK,而客户端主动则是SDK在进行操作之前会首先请求云控信息.对有推送开发经营的同学而言,这非常容易理解,就是像是为了实现消息推送功能,我们可以通过客户端轮训也可以通过服务端保持长连接进行消息推送一样.</p><h2 id="SDK安全"><a href="#SDK安全" class="headerlink" title="SDK安全"></a>SDK安全</h2><h3 id="SDK身份校验"><a href="#SDK身份校验" class="headerlink" title="SDK身份校验"></a>SDK身份校验</h3><p>为了区分接入者并挑高SDK自身安全性,我们通常会为开发者分配api key和api secret,SDK会读取开发者配置的api key和api secret,并用于随后的网络通信中.这是非常常见的做法,比如当你集成极光推送SDK的时候,它也许需要你提供api key和api secret,如果没有则需要到官网进行申请.</p><h3 id="NDK加密"><a href="#NDK加密" class="headerlink" title="NDK加密"></a>NDK加密</h3><p>为了安全起见,数据加密类,模块算法类都都应该采用NDK开发,将其封装在so文件当中.有很多开发者不明白为什么这样会增强安全性.这里我们简单的做个说明.由于.so文件是通过c/c++编译出的文件,相对于java的反编译文件来说,可读性更差,另外大部分的Android开发者并不具备较深的C/C++能力,因此一定程度上增加了被破解的能力.</p><h3 id="通讯加密"><a href="#通讯加密" class="headerlink" title="通讯加密"></a>通讯加密</h3><p>针对实际情况对通讯协议进行加密,具体是采用对称加密还是非对称加密,则需要根据实际情况做选择.另外,请尽可能使用https来代替http.</p><h3 id="设备安全"><a href="#设备安全" class="headerlink" title="设备安全"></a>设备安全</h3><p>在很多情况下,比如广告SDK中,有一些开发者会通过虚拟机来刷广告,因此有必要针对此情况做判断.一旦SDK检测出非法请求后可以采取两种方案,一种是SDK拒绝服务,另外一种则是正常服务,SDK会将作弊信息上传至服务器,以便后端服务定向排除数据.</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>对于和服务端频繁通信的SDK而言,减少传输数据大小是重中之重.</p><p>在设计SDK和服务端通讯之间的数据协议时,需要根据实际情况考虑,但有以下几条建议值得我们接受:</p><ul><li>如果对传输的数据大小有要求,建议对数据进行压缩.</li><li>可以采用json/xml/Protobuf等协议,如果它们仍然不能满足则可以考虑自定义二进制协议.</li></ul><h2 id="系统兼容"><a href="#系统兼容" class="headerlink" title="系统兼容"></a>系统兼容</h2><p>作为SDK的设计者,面临一个很大的问题是我们不得不考虑开发者应用所支持的系统最小版本,但是在SDK发布之前,我们并不知道会什么样的开发者使用我们提供的服务,因此为了让SDK支持更广泛的设备,我们需要降低最低支持的系统版本.比如现在失眠上主流的系统版本是Android 5.0,那么对SDK而言,起码要支持到Android 4.0,甚至是Android 2.3.</p><p>降低最低支持版本看起来很容易,但是我们不得不做更多的工作来确保SDK能表现出一致的工作行为(通常,我们在SDK内部检测当前系统版本来确定哪些方法可以被调用).更残酷的真相是我们花费了很大的精力去支持2.3,但来自2.3系统版本的请求量却连1%都不到.</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>Android中任何开发都避不开权限申请.作为SDK的设计者,对于权限遵循”如无必要,无需增加”,换句话说就是用不到的权限,就不要加上去,这也是我们所谓的最小权限原则,该原则同样适用于普通应用开发.</p><p>在刚接触SDK开发时,某些早期功能需要某些权限,但是后期该功能被砍掉了,但是权限却忘记去掉,这就导致不必要权限仍然存在的情况.</p><p>另外过多的权限申请,会让开发者怀疑你的目的.比如一个广告SDK的你申请照相机权限是想干嘛?恩,我怀疑你在偷拍我….好吧,这里我只是开个玩笑.</p><p>另外,从android 6.0以上,google改变了权限申请的策略,因此需要单独对此做适配.</p><h2 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h2><p>无论系统大小,日志服务是基本的服务.一个良好的日志服务能够帮助我们快速的发现问题,定位缺陷,从而获得问题的解决方案.</p><p>SDK的日志服务和其他常见的日志服务并无太大的不同,但是要保证以下几点:</p><ol><li>日志服务能够记录有效的信息,在SDK要关键位置进行打点.</li><li>日志服务上传日志信息到服务器时,要保证最大的可靠性,不能发生上传失败后抛弃日志的情况.</li><li>日志服务不能影响对正常的操作流程有过多的性能影响.SDK产生的日志信息往往是非常多的,因此必须考虑日志IO操作所带来的开销.</li></ol><h1 id="版本管理策略"><a href="#版本管理策略" class="headerlink" title="版本管理策略"></a>版本管理策略</h1><h2 id="SDK-版本号命名及修改原则"><a href="#SDK-版本号命名及修改原则" class="headerlink" title="SDK 版本号命名及修改原则"></a>SDK 版本号命名及修改原则</h2><p>SDK版本号命名和我们以往的命名规则并无太大不同,通由4部分组成,格式为:<br>V主版本号_子版本号_阶段版本号_日期版本号加希腊字母版本号.比如<code>V1_1_2_161209_beta</code>.</p><h3 id="希腊字母版本号说明"><a href="#希腊字母版本号说明" class="headerlink" title="希腊字母版本号说明"></a>希腊字母版本号说明</h3><ul><li>Alpha版:内部测试版,此版本表示该软件在该阶段主要是以实现功能为主,Bug相对较多,需要继续修改,通常只在内部流通流通而不对外开放.</li><li>Beta版:外部测试版,该版本相对Alpha已经有了很大的改进,不存在严重的Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除Bug.</li><li>RC版:该版本已经相当成熟,不存在导致错误的Bug.与正式版相差无几.</li><li>Release版:该版本意味着”最终版本”,是最终交付用户或者公开发布的版本,也称为标准版.需要注意的是,该版本在发布的时候回以符合R来代替Release单词.</li></ul><h3 id="版本号修改规则"><a href="#版本号修改规则" class="headerlink" title="版本号修改规则"></a>版本号修改规则</h3><ol><li>主版本号变化:当功能模块有较大的变化或者整体架构发生变化</li><li>子版本号变化:当功能有一定变化</li><li>阶段版本号变化:一般是Bug修复或者较小的变动,根据反馈,需要经常发布修订版本.</li><li>日期版本号(161209):用于记录修改项目的当前日期,每天对项目的修改都要更改日期版本号.</li><li>希腊字母版本号:此版本�号用于标注当前软件处于那个开发阶段,当软件进入到另一个阶段是需要修改.</li></ol><h2 id="API版本管理"><a href="#API版本管理" class="headerlink" title="API版本管理"></a>API版本管理</h2><p>和普通应用API版本管理不同,SDK设计者需要着重关注SDK API的管理.原则上SDK API一旦公开发布后其状态(签名和具体实现)应为不可变.</p><p>对于特殊情况下API的变更,需要遵守”开闭原则”,即一个类,模块,方法应该对扩展开发,对修改关闭.这就要求我们做到以下几点:</p><ol><li>在需要调整SDK API时,优先选择添加新方法,而不是在原方法上修改.对于实现相同功能的新方法,尽可能的要兼容原始方法.</li><li>在需要废除某些方法时,需要在正式版发版前使用@deprecated标识,并给出替代方案和废弃的时间(通常是SDK版本号)</li></ol><h2 id="接入文档和API文档版本管理"><a href="#接入文档和API文档版本管理" class="headerlink" title="接入文档和API文档版本管理"></a>接入文档和API文档版本管理</h2><p>接入文档是用来告诉SDK使用者,如何使用SDK,使用的详细步骤和可能发生的问题,每个公司会有自己的一套规则,这个不需要做太多的解释.</p><p>另外,接入文档通常分为两份:内部版和公开版.内部版通常用于内部开发人员和测试人员,信息较为详细,而公开版则是面向开发者,相比内部版会省略的一些信息.</p><p>API文档其实就是对SDK API的更详细说明,类似java中的api doc,可以借助jdk的自带javadoc直接生成,当然在android studio也提供了便捷的生成方式.</p><p>无论是接入文档还是api说明文档,其变更一般发生在SDK版本发生变化时.当SDK发生变更时,文档必须随之更新,不能出现SDK更新后说明文档不与之匹配的情况.</p><h2 id="集成Demo版本管理"><a href="#集成Demo版本管理" class="headerlink" title="集成Demo版本管理"></a>集成Demo版本管理</h2><p>集成Demo通常是一个简单的app,用来展示如何快速的接入SDK.其版本变更策略和SDK版本的变化保持一致.</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SDK开发中需要关注的点非常多,每个点都不能用三言两语完成的,后面会在此基础上慢慢的补充.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>SDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix Domain Socket</title>
    <link href="/2016/10/01/%E8%B0%88Unix%20Domain%20Socket/"/>
    <url>/2016/10/01/%E8%B0%88Unix%20Domain%20Socket/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-Domain-Socket简介"><a href="#Unix-Domain-Socket简介" class="headerlink" title="Unix Domain Socket简介"></a>Unix Domain Socket简介</h1><p>Unix Domain Socket是在网络Socket架构上发展而来用来实现同一台主机内进程通信的机制,简称UDS.和网络Socket相比,使用UDS传输数据不需要经过网络协议栈,不存在数据封包和拆包等过程,只涉及数据拷贝的过程.UDS使用系统文件地址来作为通信地址,无须像网络Socket那样必须指定可用的IP和端口号,使用更加简单高效.</p><p>此外UDS支持SOCK_DGRAM和SOCK_DGRAM两种工作方式,即数据包套接字和流套接字,这两者类似UDP/TCP,但由于UDS在本机内是借助内核通信,因此不会出现丢包及发送包和接收包次序不一致的问题,换言之就是两种工作模式下,UDS都是可靠的通信机制.</p><p>尽管是POSIX标准中的一个组件,但在LInux中同样是受支持的,此外UDS是全双工的,能够用于两个没有亲缘关系的进程之间通信.</p><h1 id="UDS函数"><a href="#UDS函数" class="headerlink" title="UDS函数"></a>UDS函数</h1><p>和使用网络Socket类似,UDS服务端使用流程为:</p><pre><code class="hljs shell">socket -&gt; bind -&gt; listen -&gt; accept -&gt; recv/send -&gt; close</code></pre><p>UDS客户端使用流程如下:</p><pre><code class="hljs shell">socket -&gt; connect -&gt; recv/send -&gt; close</code></pre><h2 id="Socket创建"><a href="#Socket创建" class="headerlink" title="Socket创建"></a>Socket创建</h2><p>通过函数<code>socket()</code>来创建Socket,其函数原型为:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span>;</code></pre><p>在使用UDS时,domain必须被设置成AF_UNIX或AF_LOCAL,而不能网络SOCKET中的AF_INET.使用AF_UNIX参数将会在系统上创建一个socket文件,不同进程通过读写这个文件来实现通信.</p><p>第二个参数type表示套接字的类型:SOCK_STREAM或SOCK_DGRAM.正如之前所说SOCK_STREAM和SOCK_DGRAM都是可靠的,不存在丢包以及发送包的次序和接收包的次序不一致的问题,两者之间唯一的区别在于SOCK_STREAM无论发送多大的数据都不会被截断,而对于SOCK_DGRAM而言,如果发送的数据超过了一个报文的最大长度,那么数据会被截断.</p><p>第三个参数protocol表示协议,对UDS而言,其值需要被设置成0.</p><h2 id="Socket绑定"><a href="#Socket绑定" class="headerlink" title="Socket绑定"></a>Socket绑定</h2><p>如果服务端Socket采用SOCK_STREAM工作模式,那么需要为该Socket对应的文件描述地址绑定地址,该过程通过<code>bind()</code>函数实现,其原型为:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;</code></pre><p>sockfd即通过<code>socket()</code>返回的文件描述符,<code>*addr</code>用于描述套接字的地址,采用sockaddr_un结构体表示,addrlen表示结构体的长度.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span>    <span class="hljs-keyword">sa_family_t</span> sun_family;         <span class="hljs-comment">/* AF_UNIX */</span>    <span class="hljs-keyword">char</span> sun_path[UNIX_PATH_MAX];   <span class="hljs-comment">/* 路径名 */</span>&#125;;</code></pre><p>在sockaddr_un中,字段sun_family必须要设置成AF_UNIX.而sun_path则表示路径名.在使用<code>bind()</code>时,需要创建并初始化sockaddr_un结构体,并将该结构体的指定传入作为<code>bind()</code>参数,同时将addrlen设置成该结构体的实际大小.</p><h2 id="监听客户端连接"><a href="#监听客户端连接" class="headerlink" title="监听客户端连接"></a>监听客户端连接</h2><p>对于服务端而言,服务端Socket需要通过<code>listen()</code>监听来自客户端的连接,其使用过程和网络Socket保持一致,该函数原型为:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;</code></pre><p>参数sockfd是Socket创建后返回的文件描述符;而backlog用于设置请求排队的最大长度,也就是当有多个客户端程序和服务端相连时,该参数用来表示客户端排队的长度.</p><h2 id="接受客户端连接"><a href="#接受客户端连接" class="headerlink" title="接受客户端连接"></a>接受客户端连接</h2><p>对于服务端而言,当接受到来自客户端请求时,需要<code>accept()</code>来处理客户端连接,其函数原型为:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;</code></pre><p>和网络Socket不同,UDS不存在客户端地址的问题,所以参数addr和addrlen参数需要被设置成NULL.在<code>accept()</code>调用后,服务器端会阻塞直到客户端发起连接. </p><h2 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h2><p>对于客户端Socket而言,在使用<code>socket()</code>创建套接字描述符之后,就可以通过<code>connect()</code>来连接服务端了,其函数原型为:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr,<span class="hljs-keyword">int</span> addrlen)</span></span>;</code></pre><p>和<code>bind()</code>函数类似,在该函数中同样需要制定*addr,用于表示需要连接到的服务端套接字地址.</p><h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><p>当客户端和服务端建立连接后,就可以进行数据收发了,对于工作在SOCK_STREAM模式下的服务端而言,通过<code>write()</code>和<code>read()</code>实现数据写入和读取操作,其使用方式和操作网络Socket一致:</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> length)</span></span>; <span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> length)</span></span>;</code></pre><p>对于工作在SOCK_DGRAM模式下的服务端而言,接受数据和发送数据分别通过函数<code>recvfor()</code>和<code>sendto()</code>来完成.</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags, struct sockaddr *addr, <span class="hljs-keyword">int</span> *addrlen)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sendto</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">int</span> addrlen)</span></span>;</code></pre><h1 id="UDS实例"><a href="#UDS实例" class="headerlink" title="UDS实例"></a>UDS实例</h1><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;   </span></span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 80  </span> <span class="hljs-keyword">char</span> *socket_path = <span class="hljs-string">"server.socket"</span>;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  </span><span class="hljs-function"></span>&#123;      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">server_addr</span>, <span class="hljs-title">client_addr</span>;</span>      <span class="hljs-keyword">socklen_t</span> client_addr_len;      <span class="hljs-keyword">int</span> serverfd;     <span class="hljs-keyword">int</span> clientfd;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;      <span class="hljs-keyword">char</span> buf[MAXLINE];      <span class="hljs-keyword">int</span> i, n;          <span class="hljs-comment">// 1. 创建Socket</span>    <span class="hljs-keyword">if</span> ((serverfd = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;          perror(<span class="hljs-string">"Socket创建错误"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Socket创建完成\n"</span>);    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));      server_addr.sun_family = AF_UNIX;      <span class="hljs-built_in">strcpy</span>(server_addr.sun_path, socket_path);      <span class="hljs-built_in">size</span> = offsetof(struct sockaddr_un, sun_path) + <span class="hljs-built_in">strlen</span>(server_addr.sun_path);      unlink(socket_path);          <span class="hljs-comment">// 2. 绑定Socket</span>    <span class="hljs-keyword">if</span> (bind(serverfd, (struct sockaddr *)&amp;server_addr, <span class="hljs-built_in">size</span>) &lt; <span class="hljs-number">0</span>) &#123;          perror(<span class="hljs-string">"Socket绑定错误"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Socket绑定成功\n"</span>);          <span class="hljs-comment">// 3. 监听Socket  </span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(serverfd, <span class="hljs-number">10</span>) &lt; <span class="hljs-number">0</span>) &#123;          perror(<span class="hljs-string">"Socket监听错误"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);              &#125;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Socket开始监听\n"</span>);       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;          client_addr_len = <span class="hljs-keyword">sizeof</span>(client_addr);                 <span class="hljs-keyword">if</span> ((clientfd = accept(serverfd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len)) &lt; <span class="hljs-number">0</span>)&#123;              perror(<span class="hljs-string">"连接建立失败"</span>);              <span class="hljs-keyword">continue</span>;          &#125;                    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;              n = <span class="hljs-built_in">read</span>(clientfd, buf, <span class="hljs-keyword">sizeof</span>(buf));              <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;                  perror(<span class="hljs-string">"读取客户端数据错误"</span>);                  <span class="hljs-keyword">break</span>;              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) &#123;                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"连接断开\n"</span>);                  <span class="hljs-keyword">break</span>;              &#125;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"接受客户端数据: %s"</span>, buf);               <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                  buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);              &#125;                          <span class="hljs-built_in">write</span>(clientfd, buf, n);              <span class="hljs-built_in">printf</span>(<span class="hljs-string">"向客户端发送数据: %s"</span>, buf);         &#125;          <span class="hljs-built_in">close</span>(clientfd);      &#125;      <span class="hljs-built_in">close</span>(serverfd);      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/un.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;  </span></span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE 80  </span> <span class="hljs-keyword">char</span> *client_path = <span class="hljs-string">"client.socket"</span>;  <span class="hljs-keyword">char</span> *server_path = <span class="hljs-string">"server.socket"</span>;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">client_addr</span>, <span class="hljs-title">server_addr</span>;</span>      <span class="hljs-keyword">int</span> len;      <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];      <span class="hljs-keyword">int</span> sockfd, n;       <span class="hljs-comment">// 1. Socket创建</span>    <span class="hljs-keyword">if</span> ((sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;          perror(<span class="hljs-string">"Socket创建失败"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125;            <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client_addr));      client_addr.sun_family = AF_UNIX;      <span class="hljs-built_in">strcpy</span>(client_addr.sun_path, client_path);      len = offsetof(struct sockaddr_un, sun_path) + <span class="hljs-built_in">strlen</span>(client_addr.sun_path);      unlink(client_addr.sun_path);          <span class="hljs-comment">// 2. Socket绑定</span>    <span class="hljs-keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;client_addr, len) &lt; <span class="hljs-number">0</span>) &#123;          perror(<span class="hljs-string">"Socket绑定错误"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125;       <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));      server_addr.sun_family = AF_UNIX;      <span class="hljs-built_in">strcpy</span>(server_addr.sun_path, server_path);      len = offsetof(struct sockaddr_un, sun_path) + <span class="hljs-built_in">strlen</span>(server_addr.sun_path);          <span class="hljs-comment">// 3. 连接服务端</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (struct sockaddr *)&amp;server_addr, len) &lt; <span class="hljs-number">0</span>)&#123;          perror(<span class="hljs-string">"连接服务端失败"</span>);          <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125;       <span class="hljs-keyword">while</span>(fgets(buf, MAXLINE, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;             <span class="hljs-built_in">write</span>(sockfd, buf, <span class="hljs-built_in">strlen</span>(buf));             n = <span class="hljs-built_in">read</span>(sockfd, buf, MAXLINE);             <span class="hljs-keyword">if</span> ( n &lt; <span class="hljs-number">0</span> ) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务端关闭\n"</span>);             &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, n);             &#125;        &#125;       <span class="hljs-built_in">close</span>(sockfd);      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><h2 id="编译并执行"><a href="#编译并执行" class="headerlink" title="编译并执行"></a>编译并执行</h2><p>使用gcc命令对其进行编译后,并运行</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编译</span>gcc uds_server.c -o servergcc uds_client.c -o client<span class="hljs-meta">#</span><span class="bash"> 运行</span>./server./client</code></pre>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix</tag>
      
      <tag>Socket</tag>
      
      <tag>UDS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap之哈希数组容量计算</title>
    <link href="/2016/09/21/JDK1.8%E4%B9%8BHashMap%E5%93%88%E5%B8%8C%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2016/09/21/JDK1.8%E4%B9%8BHashMap%E5%93%88%E5%B8%8C%E6%95%B0%E7%BB%84%E5%AE%B9%E9%87%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>HashMap在初始化时允许我们指定负载因子和哈希数组初始化容量大小,以JDK 1.8为例,其最终调用构造方法如下:</p><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;......      <span class="hljs-keyword">this</span>.loadFactor = loadFactor;      <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);  &#125;</code></pre><p>默认情况下负载因子loadFactory为0.75f初始化容量initialCapacity为16.</p><p>其中HashMap要求哈希数组的大小必须2<sup>n</sup>,如果我们在初始时指定initialCapacity为7会是如何?其处理逻辑在<code>tableSizeFor()</code>中,该方法用于返回大于输入参数且离它最近的2的整数次幂的数.比如对于参数7,那么最终哈希数组的大小为2<sup>3</sup>,也就是8.</p><h1 id="哈希数组容量计算"><a href="#哈希数组容量计算" class="headerlink" title="哈希数组容量计算"></a>哈希数组容量计算</h1><p><code>tableSizeFor()</code>实现代码如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre><p>先来看以下代码目的是什么:</p><pre><code class="hljs java">n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;</code></pre><p>第一行代码是将n进行无符号右移1位,并将结果与右移前的n做按位或操作,最后把结果重新赋给n;后续操作类似.为了方便,通过一个例子来了解整个过程,我们随便取个数,只关注这个数高位的1即可.假设n对应的二进制数为:</p><pre><code class="hljs plain">1000 0000 0000 0000 0000 0000 0000 0000</code></pre><p>第一行代码执行过后n变化过程如下,不难发现原本高位的1个1变成2个1.</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1000 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &gt;&gt;&gt;1</td><td><code>0100 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &#124;= n &gt;&gt;&gt; 1</td><td><code>1100 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>第二行代码执行过后n变化过程如下,不难发现原本高位2个1变成4个.</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1100 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &gt;&gt;&gt; 2</td><td><code>0011 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &#124;= n &gt;&gt;&gt; 2</td><td><code>1111 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>第三行代码执行过后n变化过程如下,不难发现原本高位4个1变成8个.</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1111 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &gt;&gt;&gt; 4</td><td><code>0000 1111 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &#124;= n &gt;&gt;&gt; 4</td><td><code>1111 1111 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>第四行代码执行过后n变化过程如下,不难发现原本高位的8个1变成了16个.</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1111 1111 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>n &gt;&gt;&gt; 8</td><td><code>0000 0000 1111 1111 0000 0000 0000 0000</code></td></tr><tr><td>n &#124;= n &gt;&gt;&gt; 8</td><td><code>1111 1111 1111 1111 0000 0000 0000 0000</code></td></tr></tbody></table><p>第五行代码执行后n的变化过程如下:</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1111 1111 1111 1111 0000 0000 0000 0000</code></td></tr><tr><td>n &gt;&gt;&gt; 16</td><td><code>0000 0000 0000 0000 1111 1111 1111 1111</code></td></tr><tr><td>n &#124;= n &gt;&gt;&gt; 16</td><td><code>1111 1111 1111 1111 1111 1111 1111 1111</code></td></tr></tbody></table><p>此时我们发现32个bit已经全部被替换成了1.</p><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>原始 n</td><td><code>1000 0000 0000 0000 0000 0000 0000 0000</code></td></tr><tr><td>当前 n</td><td><code>1111 1111 1111 1111 1111 1111 1111 1111</code></td></tr><tr><td>现在执行n+1操作:</td><td></td></tr></tbody></table><table><thead><tr><th>步骤</th><th>值</th></tr></thead><tbody><tr><td>n</td><td><code>1111 1111 1111 1111 1111 1111 1111 1111</code></td></tr><tr><td>n + 1</td><td><code>0001 0000 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>总结一下,该算法让最高位的1后面的位全变为1.比如10,11变为11;100,101,110,111变为111;最后再让结果n+1就可得到了2的整数次幂的值了.比如我们cap为7时,n就是<code>7 - 1 = 6</code>,对应二进制位为<code>110</code>,经过变换之后,n对应二进制位111,对n进行加1操作后,n对应的二进制位1000,即十进制8.</p><p>回过头来看第一条语句：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;</code></pre><p>为了方便理解,直接来看个例子.假设当前输出参数cap为8,其二进制1000,如果不对它减1而直接操作,将得到答案10000,即16.显然不是预期结果.cap进行减1后二进制为111,再进行操作则会得到原来的数值1000,即8.总结下来就是避免对参数自身已经是2<sup>n</sup>的情况导致计算出错.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>JDK 1.8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Https简易工作原理</title>
    <link href="/2016/09/20/Https%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <url>/2016/09/20/Https%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>最近在看到这么一篇讲解Https原理的文章，语言精炼，通俗易懂，特地将其翻译下，原文在此<a href="http://www.songzhw.com/2016/09/13/how-does-https-work/" target="_blank" rel="noopener">how does https work</a></p><h1 id="加密算法简介"><a href="#加密算法简介" class="headerlink" title="加密算法简介"></a>加密算法简介</h1><p>正文开始之前，我先来解释简单的解释下对称加密和非对称加密.</p><blockquote><p><strong>对称加密</strong>采用对称密码编码技术，也就是编码和解码采用相同描述字符，即加密和解密使用相同的密钥，实现这种加密技术的算法称对称加密算法。对称加密使用简单，密钥较短，加密和解密过程较快，耗时短，常见的对称加密算法有DES，3DES，lDEA，AES，RC4等。</p></blockquote><blockquote><p><strong>非对称加密</strong>与对称加密不同，其加密算法需要两个密钥：公开密钥（publickey）和私有密钥（private），两者是一对的。如果用公钥加密，只能用私钥才能解密。非对称加密保密性好，但加密和解密花费的时间较长，不适合对大文件加密而只适合对少量的数据加密。常见的非对称加密算法有RSA，ECC，DSA(数字签名)等。</p></blockquote><blockquote><p><strong>Hash算法</strong>是一种单向算法，通过Hash算法可以对目标数据生成一段特定长度、唯一的hash值,但是不能通过这个hash值重新计算出原始的数据，因此也称之为摘要算法，经常被用在不需要数据还原的密码加密以及数据完整性校验上，常用的算法有MD2，MD4，MD5，SHA等。</p></blockquote><p>现在我们对对称加密，非对称加密及Hash算法做了简单的说明之后，就可以开始了解https的工作原理了。</p><hr><h1 id="https是如何工作的？"><a href="#https是如何工作的？" class="headerlink" title="https是如何工作的？"></a>https是如何工作的？</h1><p>这篇文章是我在我团队中分享的。很多人不理解https的好处，不理解https的原理，因此我将这篇文章也分享给大家。</p><h2 id="加密（Cipher）"><a href="#加密（Cipher）" class="headerlink" title="加密（Cipher）"></a>加密（Cipher）</h2><p>在java 1.2时，引入JCR（java 加密扩展）系统，用来负责java中的密钥和证书。</p><p>我们都知道，如果我们想要加密或解密一些信息，我们必须要有一个密钥。这好比你想要开门或者锁门，必须要有钥匙一样。</p><p>在java中，密钥由KeyGenerator或KeyPairGenerator生成。前者用来生成对称密钥，后者用来生成非对称密钥。</p><ul><li>对称密钥：使用同一个密钥进行加密和解密</li><li>非对称密钥：使用不同的密钥进行加密和解密，通常被称为公钥（public key）和私钥（private key）。 公钥可以广泛传播，但是私钥只有其所有者知道。在一个安全的非对称密钥加密方案中，当信息用公钥加密后，只有用私钥才能解密。所以，即使一个黑客拿到你公钥加密过后的信息，也无法解密它，因为它没有配对的私钥。这样，传输的消息就是安全的。</li></ul><h2 id="证书（Certificate）"><a href="#证书（Certificate）" class="headerlink" title="证书（Certificate）"></a>证书（Certificate）</h2><p>在现实中，如果你进入到钻石专卖店中想要买一颗钻石，你怎么知道钻石是真的？作为一个普通人来说，我们没有钻石方面的知识，但是如果这钻石有个由美国政府颁发的许可证，我们就会相信它是真的。（去过珠宝店的同学都知道，每件珠宝都有自己的鉴定书）</p><p>证书的作用也是如此。在计算机世界中，它可能是包含一些密钥，是另一个证书（姑且称之为证书B好了）。这些密钥是我们需要的，而证书B是一个许可证，用来证明这个证书是可信赖的。</p><blockquote><p>做个简短的解释，每个钻石都有自己的“身份证书”，但是如何说明这个身份证书是合法的，而不是自己伪造的？因此，我们需要一个权威的机构来证明这个钻石的身份证书是合法的，如果这个钻石的身份是合法的，该权威机构就会为其颁发一个“许可证”，这个许可证就相当于上面我们说到的证书B。可以看到，证书B的目的就是证明这个身份证书是这个钻石的身份证书，即证明某某东西是某某东西的东西</p></blockquote><p>问题来了：我们怎么确定证书B是可信赖的呢？这个问题非常棒。</p><p>Android已经把将近150个CA根证书（数字证书认证机构认证过的证书）内置在我们手机中。这150多个证书被全世界信赖，他们就像是美国的大法官。</p><blockquote><p>这150多个证书类似我们刚才说的证书B，分别用来证明某某东西是某某东西的东西</p></blockquote><p>B证书中里有另外一个证书（姑且称之为C证书），我们通过检查C来确定C是否是可信任的。。。通过这个证书链，如果我们找到的最后一个或根证书 和手机中预置的150个证书中某个相同，我们就可以这个证书原件（此处就是B）</p><blockquote><p>这里我对证书链进行说明。证书之间的信任关系是可以嵌套的。比如，CA信任D，D信任C，C信任B<br>,B信任A。。。这就是证书链。只要我们信任证书链上的头一个证书，那么后续的证书都是可以信任的。这里也就是如果我信任了证书CA，那么后面的D，C，B，A都是可以信任的。这里来打个比方，假设军队中的每个士兵都只认识自己的直接上级，那么这时候总司令怎么确认某个士兵是自己部队 当中的呢？总司令（CA）会问的直接下级（D），而司令的直接下级又会找自己的直接下级，依次往下找…如果最后能找到这个士兵直属上级，那就说明这个士兵是该部队当中的。</p></blockquote><p>附：证书有多种格式</p><ul><li><p>x.509<br>x.509证书通常用于包含一个公钥</p></li><li><p>PKCS12<br> PKCS12证书通常用来包含一个私钥。因此，PKCS12需要密码才能打开。</p></li></ul><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><p>现在我们来了解https部分。Https（http over ssl）包含上面提到的加密和证书两部分，被设计用来在Internet安全进行通信。</p><h3 id="如何安全的通信？"><a href="#如何安全的通信？" class="headerlink" title="如何安全的通信？"></a>如何安全的通信？</h3><p>如何安全通信呢？对称加密是我们最先想到的方案：将数据进行加密，然后将加密过的数据和密钥同时传到服务器，服务器使用这个密钥解密加密过后的数据。</p><p><img src="https://i.imgur.com/9rUcGsD.png" srcset="/img/loading.gif" alt="mage-20180708125333"></p><p>现在，我们来看看这种可能的场景：黑客截获了该通信，这意味着黑客拥有了密钥和密文。一旦黑客有了密钥，那么解密密文就是很简单的事情了，我们的数据就这样泄漏了。</p><h3 id="如何使用非对称加密？"><a href="#如何使用非对称加密？" class="headerlink" title="如何使用非对称加密？"></a>如何使用非对称加密？</h3><p>上面的解决方案非常不安全。我们继续往下看。使用非对称加密怎么样？</p><p>这个想法非常棒：服务端发送给你公钥，你使用这个公钥加密数据。因为服务端是唯一拥有私钥的，<br>这意味着只有服务端能够解密密文。即使黑客截获了该通讯，但因为没有私钥也就无法解密密文。</p><p>但是，非对称加密比对称加密更加耗时。为了用户体验，不建议使用非对称加密这种方式来加密/解密大量的数据<br>。</p><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>前两种方案都无法解决我们安全通信，我们怎么结合上面的两种方案呢？来看看最终方案：</p><p><img src="https://i.imgur.com/Qc1qOok.jpg" srcset="/img/loading.gif" alt="ttp"></p><p>上面这张图片已经清楚的展示了HTTPS工作的流程。</p><p>1.[Server]生成一对密钥：公钥和私钥，我们称之为“KeyPub”，“KeyPri”<br>2.[Server]服务端将公钥（KeyPub）发送到客户端<br>3.[Client]生成一个对称密钥（姑且称之为key2），然后用key2加密数据。<br>4.[Client]使用公钥（KeyPub）加密key2.这时，key2是安全的，因为只有服务度有私钥KeyPri<br>5.[Client]发送用key2加密后的信息及用KeyPub加密过的key2到服务端<br>6.[Server]服务端使用KeyPri解密得到加密过的key2，得到真正的key2<br>7.[Server]使用key2解密消息正文。这样，数据就被安全的传输到了服务端。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由于对称加密比非对称加密快，https决定使用对称加密来加密数据，使用非对称加密对称加密生成的密钥，以确保安全。</p><p>这篇文章最后并没有很好的说明证书的作用，因此如果你以前没了解过，到此可能产生一些困惑，后面我会再单独写一篇文章来说明下。</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Https</tag>
      
      <tag>加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析AIL语言及init.rc</title>
    <link href="/2016/07/21/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90AIL%E8%AF%AD%E8%A8%80%E5%8F%8Ainit.rc%E6%96%87%E4%BB%B6/"/>
    <url>/2016/07/21/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90AIL%E8%AF%AD%E8%A8%80%E5%8F%8Ainit.rc%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="AIL语法"><a href="#AIL语法" class="headerlink" title="AIL语法"></a>AIL语法</h1><p>AIL语言非常简单,主要包括两部分:结构语法及注释语法.下面我们就这两点进行说明</p><h2 id="结构语法"><a href="#结构语法" class="headerlink" title="结构语法"></a>结构语法</h2><p>AIL语言包含主要包含五种结构语法:</p><ol><li>Actions</li><li>Services</li><li>Options</li><li>Commands</li><li>Imports</li></ol><p>需要注意,AIL采用是面向行的代码风格,即用换行符作为一条语句的分隔符,也就是在init.rc中以一条语句通常占据一行.如果一行写不下,可以在行尾添加反斜杠来链接到下一行,换言之,通过行尾添加反斜杠符可以将多行代码链接为一行代码.</p><p>init.rc有许多Service和Action组成.那么什么是Service和Action呢?<br>Action和Service显式声明了一个语句块,而Commands和Options则分别用来定义Actions和Service(你可以理解为这是Action或者Service的属性).</p><p>另外,我们声明的Commands和Options属于最近声明的语句块,即就近原则.需要注意,在第一个语句块之前的commands和options会被忽略.</p><p>每个Actions或者Services应该有唯一的名字.对于名字重复的情况,Action和Service有自己不同的处理方式:</p><blockquote><p>如果第二个定义的Action的名字和之前存在Action的名字相同,第二个Action中定义的Commands将会被添加到已经存在的同名Action中.如果第二个定义的Service的名字和之前存在的Service的名字相同,第二个Service会被忽略并输出错误信息.</p></blockquote><h2 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h2><p>AIL中的注释语法和Shell脚本一致,以#开头即可</p><h1 id="结构语法详解"><a href="#结构语法详解" class="headerlink" title="结构语法详解"></a>结构语法详解</h1><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Actions代表一些Action.Action代表一组命令,它包含一个触发器,该触发器决定了何时执行这个Action,即在什么情况下才能执行该Action中的定义命令.当一些条件满足触发器的条件时,该Action中定义的命令会被添加到要执行命令队列的尾部(如果这组命令已经在队列中,则不会再次添加).</p><p>当一个Action从队列移除时,该Action定义的命令会依次被执行.</p><p>Action的格式如下:</p><pre><code class="hljs plain">on &lt;trgger&gt; [&amp;&amp; &lt;trigger&gt;]*   &lt;command&gt;   &lt;command&gt;   &lt;command&gt;   ...</code></pre><p>不难发现Action都是以on开始,随后会定义触发器(trigger),接着便是为其定义命令(Commmand).在开始讲解Trigger和Command之前,我们先来看一段Action的示例代码:</p><pre><code class="hljs plain">on boot    # 初始化网络    ifup lo    hostname localhost    domainname localdomain</code></pre><h2 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h2><p>trigger即我们上面所说的触发器,本质上是一个字符串,能够匹配某种包含该字符串的事件.<br>trigger又被细分为事件触发器(event trigger)和属性触发器(property trigger).</p><p>事件触发器可由”trigger”命令或初始化过程中通过QueueEventTrigger()触发,通常是一些事先定义的简单字符串,例如:<code>boot</code>,<code>late-init</code><br>属性触发器是当指定属性的变量值变成指定值时触发,其格式为<code>property:&lt;name&gt;=*</code> </p><p>一个Action可以有多个属性触发器,但是最多有一个事件触发器.下面我们看两个例子:</p><pre><code class="hljs plain">on boot &amp;&amp; property:a&#x3D;b</code></pre><p>该Action只有在boot事件发生时,并且属性a和b相等的情况下才会被触发.</p><pre><code class="hljs plain">on property:a&#x3D;b &amp;&amp; property:c&#x3D;d</code></pre><p>该Action会在以下三种情况被触发:</p><ul><li>在启动时,如果属性a的值等于b并且属性c的值等于d</li><li>在属性c的值已经是d的情况下,属性a的值被更新为b</li><li>在属性a的值已经是b的情况下,属性c的值被更新为d</li></ul><p>当前AIL中常用的有以下几种事件触发器:</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>boot</code></td><td>init.rc被装载后触发</td></tr><tr><td><code>device-added-&lt;path&gt;</code></td><td>指定设备被添加时触发</td></tr><tr><td><code>device-removed-&lt;path&gt;</code></td><td>指定设备被移除时触发</td></tr><tr><td><code>service-exited-&lt;name&gt;</code></td><td>在特定服务(service)退出时触发</td></tr><tr><td><code>early-init</code></td><td>初始化之前触发</td></tr><tr><td><code>late-init</code></td><td>初始化之后触发</td></tr><tr><td><code>init</code></td><td>初始化时触发</td></tr></tbody></table><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>Commands代表一组命令,在为Action设置了触发器后,就需要为其定义一组命令(command)了.AIL中内置了众多的命令,下面我们做个简单的说明:</p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>bootchart_init</code></td><td>如果配置了bootcharing,则启动.包含在默认的init.rc中</td></tr><tr><td><code>chmod</code></td><td>更改文件权限</td></tr><tr><td><code>chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;</code></td><td>更改文件的所有者和组</td></tr><tr><td><code>calss_start &lt;serviceclass&gt;</code></td><td>启动指定类别服务下的所有未启动的服务</td></tr><tr><td><code>class_stop &lt;serviceclass&gt;</code></td><td>停止指定类别服务类下的所有已运行的服务</td></tr><tr><td><code>class_reset &lt;serviceclass&gt;</code></td><td>停止指定类别的所有服务(服务还在运行),但不会禁用这些服务.后面可以通过class_start重启这些服务</td></tr><tr><td><code>copy &lt;src&gt; &lt;dst&gt;</code></td><td>复制文件,对二进制/大文件非常有用</td></tr><tr><td><code>domainname &lt;name&gt;</code></td><td>设置域名称</td></tr><tr><td><code>enable &lt;servicename&gt;</code></td><td>启用已经禁用的服务</td></tr><tr><td><code>exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt; ]* ]]</code><br><code>--&lt;command&gt; [ &lt;argument&gt; ]*</code></td><td>fork一个进程执行指定命令,如果有参数,则带参数执行</td></tr><tr><td><code>export &lt;name&gt;</code></td><td>在全局环境中,将<code>&lt;name&gt;</code>变量的值设置为<code>&lt;value&gt;</code>,即以键值对的方式设置全局环境变量.这些变量对之后的任何进程都有效</td></tr><tr><td><code>hostname</code></td><td>设置主机名</td></tr><tr><td><code>ifup &lt;interface&gt;</code></td><td>启动某个网络接口</td></tr><tr><td><code>insmod [-f] &lt;path&gt; [&lt;options&gt;]</code></td><td>加载指定路径下的驱动模块。-f强制加载，即不管当前模块是否和linux kernel匹配</td></tr><tr><td><code>load_all_props</code></td><td>从/system，/vendor加载属性。默认包含在init.rc</td></tr><tr><td><code>load_persist_props</code></td><td>当/data被加密时，加载固定属性</td></tr><tr><td><code>loglevel &lt;level&gt;</code></td><td>设置kernel日志等级</td></tr><tr><td><code>mkdir &lt;path&gt; [mode] [owner] [group]</code></td><td>在制定路径下创建目录</td></tr><tr><td><code>mount_all &lt;fstab&gt; [ &lt;path&gt; ]*</code></td><td>在给定的fs_mgr-format上调用fs_mgr_mount和引入rc文件</td></tr><tr><td><code>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt;[ &lt;flag&gt; ]* [&lt;options&gt;]</code></td><td>挂载指定设备到指定目录下.</td></tr><tr><td><code>powerct</code></td><td>用来应对sys.powerctl中系统属性的变化,用于系统重启</td></tr><tr><td><code>restart &lt;service&gt;</code></td><td>重启制定服务，但不会禁用该服务</td></tr><tr><td><code>restorecon &lt;path&gt; [ &lt;path&gt; ]*</code></td><td>恢复指定文件到file_contexts配置中指定的安全上线文环境</td></tr><tr><td><code>restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]*</code></td><td>以递归的方式恢复指定目录到file_contexts配置中指定的安全上下文中</td></tr><tr><td><code>rm &lt;path&gt;</code></td><td>删除指定路径下的文件</td></tr><tr><td><code>rmdir &lt;path&gt;</code></td><td>删除制定路径下的目录</td></tr><tr><td><code>setprop &lt;name&gt; &lt;value&gt;</code></td><td>将系统属性<code>&lt;name&gt;</code>的值设置为<code>&lt;value&gt;</code>,即以键值对的方式设置系统属性</td></tr><tr><td><code>setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;</code></td><td>设置资源限制</td></tr><tr><td><code>start &lt;service&gt;</code></td><td>启动服务(如果该服务还未启动)</td></tr><tr><td><code>stop &lt;service&gt;</code></td><td>关闭服务(如果该服务还未停止)</td></tr><tr><td><code>swapon_all &lt;fstab&gt;</code></td><td></td></tr><tr><td><code>symlink &lt;target&gt; &lt;path&gt;</code></td><td>创建一个指向<code>&lt;path&gt;</code>的符合链接<code>&lt;target&gt;</code></td></tr><tr><td><code>sysclktz &lt;mins_west_of_gmt&gt;</code></td><td>设置系统时钟的基准,比如0代表GMT,即以格林尼治时间为准</td></tr><tr><td><code>trigger &lt;event&gt;</code></td><td>触发一个事件,将该action排在某个action之后(用于Action排队)</td></tr><tr><td><code>verity_load_state</code></td><td></td></tr><tr><td><code>verity_update_state &lt;mount_point&gt;</code></td><td></td></tr><tr><td><code>wait &lt;path&gt; [ &lt;timeout&gt; ]</code></td><td>等待一个文件是否存在,存在时立刻返回或者超时后返回.默认超时事件是5s</td></tr><tr><td><code>write &lt;path&gt; &lt;content&gt;</code></td><td>写内容到指定文件中</td></tr></tbody></table><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>Services代表一些Service.Service是一些在系统初始化时就启动或者退出时需要重启的程序.其格式如下:</p><pre><code class="hljs plain">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*        &lt;option&gt;        &lt;option&gt;        ...</code></pre><p>不难发现,首先需要为服务定义名字,并指定程序路径,然后便是通过option来修饰服务.同样先来看一下示例:</p><pre><code class="hljs plain">service ueventd &#x2F;sbin&#x2F;ueventd    class core    critical    seclabel u:r:ueventd:s0</code></pre><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>Options代表一些option.option用来修饰服务,决定了服务在什么时候运行以及怎样运行.AIL中提供了非常多的option,下面我们做个简单说明:</p><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td><code>console</code></td><td>服务需要一个控制台.</td></tr><tr><td><code>critical</code></td><td>表示这是一个关键设备服务.如果4分钟内此服务退出4次以上,那么这个设备将重启进入recovery模式</td></tr><tr><td><code>disabled</code></td><td>服务不会自动启动,必须通过服务名显式启动</td></tr><tr><td><code>setenv &lt;name&gt; &lt;value&gt;</code></td><td>在进程启动过程中,将环境变量<code>&lt;name&gt;</code>的值设置为<code>&lt;value&gt;</code>,即以键值对的方式设置环境变量</td></tr><tr><td><code>socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [seclabel]]]</code></td><td>创建一个unix域下的socket,其被命名<code>/dev/socket/&lt;name&gt;</code>. 并将其文件描述符fd返回给服务进程.其中,type必须为dgram,stream或者seqpacke,user和group默认是0.seclabel是该socket的SELLinux的安全上下文环境,默认是当前service的上下文环境,通过seclabel指定.</td></tr><tr><td><code>user &lt;username&gt;</code></td><td>在执行此服务之前切换用户名,当前默认的是root.自Android M开始,即使它要求linux capabilities,也应该使用该选项.很明显,为了获得该功能,进程需要以root用户运行</td></tr><tr><td><code>group &lt;groupname&gt;</code></td><td>在执行此服务之前切换组名,除了第一个必须的组名外,附加的组名用于设置进程的补充组(借助setgroup()函数),当前默认的是root</td></tr><tr><td><code>seclabel &lt;seclabel&gt;</code></td><td>在执行该服务之前修改其安全上下文,默认是init程序的上下文</td></tr><tr><td><code>oneshot</code></td><td>当服务退出时,不重启该服务</td></tr><tr><td><code>class &lt;name&gt;</code></td><td>为当前service设定一个类别.相同类别的服务将会同时启动或者停止,默认类名是default.</td></tr><tr><td><code>onrestart</code></td><td>当服务重启时执行该命令</td></tr><tr><td><code>priority &lt;priority&gt;</code></td><td>设置服务进程的优先级.优先级取值范围为-20~19,默认是0.可以通过setpriority()设置</td></tr></tbody></table><h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p>用来引入一个要解析的其他配置文件,通常用于当前配置文件的扩展.<br>其格式如下:</p><pre><code class="hljs plain">import &lt;path&gt;</code></pre><p>如果path是个一个目录,则该目录下的每个.rc文件都被引入.</p><p>在初始化过程中,共有两次使用import来引入.rc文件:</p><ol><li>在初始化引导期间,引入/init.rc文件</li><li>在执行mount_all命令时,引入/{system,vendor,odm}/etc/init/或者指定路径下的.rc文件</li></ol><p>我们来看看init.rc文件引入的.rc文件:</p><pre><code class="hljs plain">import &#x2F;init.environ.rcimport &#x2F;init.usb.rcimport &#x2F;init.$&#123;ro.hardware&#125;.rcimport &#x2F;init.$&#123;ro.zygote&#125;.rc</code></pre><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties代表Init进程运行中的一些属性信息.在Init运行中,通过以下属性能够获取当前程序内部信息:</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>init.svc.&lt;name&gt;</code></td><td>指定名称服务的状态,有stopped,stopping,runing,restarting这种四种状态</td></tr><tr><td><code>init.action</code></td><td>获取当前正在执行的action</td></tr><tr><td><code>init.command</code></td><td>获取当前正在执行的command</td></tr></tbody></table><h1 id="文件示例"><a href="#文件示例" class="headerlink" title="文件示例"></a>文件示例</h1><p>到现在为止,有关AIL相关的知识基本介绍完毕,下面截取init.rc文件中的一段来做个简单的说明:</p><pre><code class="hljs plain">&#x2F;&#x2F;引入其他要解析的rc文件import &#x2F;init.environ.rcimport &#x2F;init.usb.rcimport &#x2F;init.$&#123;ro.hardware&#125;.rcimport &#x2F;init.usb.configfs.rcimport &#x2F;init.$&#123;ro.zygote&#125;.rc#定义了一个action,在init初始化之前触发on early-init    # Set init and its forked children&#39;s oom_adj.    write &#x2F;proc&#x2F;1&#x2F;oom_score_adj -1000    # Disable sysrq from keyboard    write &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sysrq 0    # Set the security context of &#x2F;adb_keys if present.    restorecon &#x2F;adb_keys    # Shouldn&#39;t be necessary, but sdcard won&#39;t start without it. http:&#x2F;&#x2F;b&#x2F;22568628.    mkdir &#x2F;mnt 0775 root system    # Set the security context of &#x2F;postinstall if present.    restorecon &#x2F;postinstall        #启动ueventd服务    start ueventd        #...省略多行...    #定义ueventd服务,设置服务为&#x2F;sbin&#x2F;ueventdservice ueventd &#x2F;sbin&#x2F;ueventd    class core#为其设置类名为core    critical#表明这是一个关键服务    seclabel u:r:ueventd:s0 #设置其安全上下文</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AIL是一种非常简单的语言,主要用于定义启动流程中需要做的事情.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>AIL</tag>
      
      <tag>init.rc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从inotify机制到FileObserver原理</title>
    <link href="/2016/07/14/%E4%BB%8Einotify%E5%88%B0FileObserver/"/>
    <url>/2016/07/14/%E4%BB%8Einotify%E5%88%B0FileObserver/</url>
    
    <content type="html"><![CDATA[<h1 id="inotify简介"><a href="#inotify简介" class="headerlink" title="inotify简介"></a>inotify简介</h1><p>那还有其他的方式么?熟悉linux的童鞋应该记得从linux kernel 2.6.13开始引入inotify机制,用于通知用户相关文件变化情况:任何一个文件发生某种变化,都会产生一个相应的文件事件.</p><p>我们不仅好奇,文件的哪些事件能够被监控,也就是说inotify支持监控文件的哪些变化呢?继续往下看.</p><h2 id="可监控事件类型"><a href="#可监控事件类型" class="headerlink" title="可监控事件类型"></a>可监控事件类型</h2><p>目前inotify能够监控的以下文件变化事件:</p><table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>IN_ACCESS</td><td>文件被访问</td></tr><tr><td>IN_MODIFY</td><td>文件被修改</td></tr><tr><td>IN_ATTRIB</td><td>文件属性被修改</td></tr><tr><td>IN_CLOSE_WRITE</td><td>可写文件被关闭</td></tr><tr><td>IN_CLOSE_NOWRITE</td><td>不可写文件被关闭</td></tr><tr><td>IN_CLOSE</td><td>文件被关闭,也就以上两者的集合</td></tr><tr><td>IN_OPEN</td><td>文件被打开</td></tr><tr><td>IN_MOVED_FROM</td><td>文件被移来</td></tr><tr><td>IN_MOVED_TO</td><td>文件被移走</td></tr><tr><td>IN_MOVE</td><td>文件被移动,也就是以上两者的集合</td></tr><tr><td>IN_CREATE</td><td>文件被创建</td></tr><tr><td>IN_DELETE</td><td>文件被删除</td></tr><tr><td>IN_DELETE_SELF</td><td>自删除,也就是一个可执行文件在执行时尝试删除自己</td></tr><tr><td>IN_MOVE_SELF</td><td>自移动,也就是一个可执行文件在执行时尝试移动自己</td></tr><tr><td>IN_UNMOUNT</td><td>宿主文件系统被卸载</td></tr></tbody></table><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><p>不难发现,inotify对文件监控的支持是非常全面的,足以满足我们绝大部门的需求.接下来,我们对innotify的api做个简单的说明:<br>|方法|说明|<br>|—-|—|<br>|inotify_init|用于创建一个inotify实例,返回一个指向该实例的的文件描述符|<br>|inotify_add_watch|添加对文件或者目录的监控,可以指定需要监控那些文件变化事件|<br>|inotify_rm_watch|从监控列表中移除监控文件或者目录|<br>|read|读取事件信息|<br>|close|关闭文件描述符,并会移除所有在该描述符上监控|</p><h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><p>在可监控事件中,我们已经了解inotify支持的文件事件.现在来看看这些当这些文件事件产生时,其发出通知的结构.在inotify中,事件通知结构用结构体inotify_event表示:</p><pre><code class="hljs plain">struct inotify_event&#123;  int wd;               &#x2F;&#x2F;监控目标的watch描述符  uint32_t mask;        &#x2F;&#x2F;事件掩码  uint32_t cookie;      &#x2F;&#x2F;事件同步cookie  uint32_t len;         &#x2F;&#x2F;name字符串的长度  char name __flexarr;  &#x2F;&#x2F;被监视目标的路径名  &#125;;</code></pre><p>这里需要记住一点:name字段并不是什么时候都有的:只有要监控的目标是一个目录,且产生的事件与目录内部的文件或子目录相关,且与目录本身无关时才会提供相应的name字段.<br>cookie用于关联被观察对象的IN_MOVED_FROM事件和IN_MOVED_TO 事件. </p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>了解以上之后,那么该怎么用呢?要实现对文件或者目录的监控需要经过以下几个步骤:</p><h3 id="1-创建inotify实例"><a href="#1-创建inotify实例" class="headerlink" title="1. 创建inotify实例"></a>1. 创建inotify实例</h3><p>在应用程序中,首先需要创建inotify实例:</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fd=inotify_init();</code></pre><p>该方法创建了一个inotify实例,并返回一个文件描述符以便能够通过这个描述符访问到inotify实例.</p><h3 id="2-添加监控"><a href="#2-添加监控" class="headerlink" title="2. 添加监控"></a>2. 添加监控</h3><p>在获得inotify实例产生的文件描述符之后,我们就可以为其添加watch.另外,我们也可以使用mask(事件掩码)来设置我们想监控的事件类型.当然可以我们也可以使用IN_ALL_EVENTS监控所有事件:</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> wd=inotify_add_watch(fd,path,mask)</code></pre><p><strong><em>补充:</em></strong><br>此处的fd即inotify_init()方法返回的文件描述符.每个文件描述符都有一个排序的事件序列.path则是需要监控的文件或者目录的路径.mask则是事件掩码,它表示应用程序对哪些事件感兴趣.</p><p>文件系统产生的事件由Watch对象来管理,该方法将返回的wd就是Watch对象的句柄.</p><h3 id="3-等待事件与循环处理"><a href="#3-等待事件与循环处理" class="headerlink" title="3. 等待事件与循环处理"></a>3. 等待事件与循环处理</h3><p>在为inotify实例添加watch之后,接下来就是等待事件了.为了能不断的处理事件,我们将其放在循环体当中.<br>在循环中,通过read()方法可以一次获得多个事件.在没有事件产生时,read()被阻塞,一旦有事件产生,那么我们就可以读取事件到的我们设置的事件数组中,然后对事件数组进行处理,其简单代码如下:</p><pre><code class="hljs c++"><span class="hljs-comment">//事件数组,自定义设置,这里我们设置为128</span><span class="hljs-keyword">char</span> event_buf[<span class="hljs-number">128</span>];<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;     <span class="hljs-keyword">int</span> num_bytes=<span class="hljs-built_in">read</span>(fd,event_buf,len);     <span class="hljs-comment">//处理事件</span>     handleEvent(event_buf);     <span class="hljs-comment">//....省略....</span>&#125;</code></pre><p><strong><em>补充</em></strong><br>event_buf是一个事件数组,用于接受文件变化所产生的事件(inotify_event).len则指定了要读的长度.通常来说,len大于事件数组的大小,很多时候,我们也会直接取事件数组的大小来作为len.</p><h3 id="4-停止监控"><a href="#4-停止监控" class="headerlink" title="4.停止监控"></a>4.停止监控</h3><p>当需要停止监控的时候,需要为文件描述符删除watch:</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> r=inotify_rm_watch(fd,wd);</code></pre><p>此处的fd也是在创建inotify时返回的文件描述符,wd则是上面提到watch对象的句柄.</p><p>到现在,我们已经对inotity有了初步的理解,感兴趣的童鞋可以自行研究.我们的重点还是Android中FileObserver的实现.接下来,我们真正的开始了解FileObserver的实现.</p><h1 id="FileObserver实现原理"><a href="#FileObserver实现原理" class="headerlink" title="FileObserver实现原理"></a>FileObserver实现原理</h1><p>我们知道Android 1.5时对应的linux内核已经是2.6.26,因此完全可以在Android上利用inotify机制来实现对文件的监控.Google很显然意识到了这一点,并且帮我们在inotify的基础上进行封装—FileObserver,以实现监听文件访问,创建,修改,删除等操作</p><p>接下来,来看一下FileObserver如何借助inotify实现文件监控的.</p><h2 id="监控线程初始化"><a href="#监控线程初始化" class="headerlink" title="监控线程初始化"></a>监控线程初始化</h2><p>在FileObserver中存在一个静态内部类ObserverThread,该线程类是实现了文件监控的过程:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileObserver</span> </span>&#123;    <span class="hljs-comment">//可监控的事件</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALL_EVENTS = ACCESS | MODIFY | ATTRIB | CLOSE_WRITE            | CLOSE_NOWRITE | OPEN | MOVED_FROM | MOVED_TO | DELETE | CREATE            | DELETE_SELF | MOVE_SELF;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-comment">//....省略多行代码....</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObserverThread s_observerThread;    <span class="hljs-keyword">static</span> &#123;        s_observerThread = <span class="hljs-keyword">new</span> ObserverThread();        s_observerThread.start();    &#125;       <span class="hljs-comment">//....省略多行代码....</span>&#125;</code></pre><p>不难发现发现FileObserver通过静态代码块的方式构造了s_observerThread对象,我们来看一下其构造过程:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObserverThread</span><span class="hljs-params">()</span> </span>&#123;       super(<span class="hljs-string">"FileObserver"</span>);       m_fd = init();   &#125;</code></pre><p>这里又调用natvie方法<code>init()</code>.既然这样,我们就在深入一下,看看init()方法的实现(现在,是不是发现我们自己编译源码的好处了?)该方法的实现在: /frameworks/base/core/jni/android_util_FileObserver.cpp</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">android_os_fileobserver_init</span><span class="hljs-params">(JNIEnv* env, jobject object)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span>    <span class="hljs-keyword">return</span> (jint)inotify_init();<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><p>其实现非常简单，就是调用inotify中的inotify_init()来创建一个inotify实例。回到FileObserver中来看s_ObserverThread的启动：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            observe(m_fd);        &#125;</code></pre><p>这里同样是调用natvie方法<code>observe(int fd)</code>：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_os_fileobserver_observe</span><span class="hljs-params">(JNIEnv* env, jobject object, jint fd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span><span class="hljs-comment">//设置事件数组</span>    <span class="hljs-keyword">char</span> event_buf[<span class="hljs-number">512</span>];    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inotify_event</span>* <span class="hljs-title">event</span>;</span>    <span class="hljs-comment">//循环处理读到的事件</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">int</span> event_pos = <span class="hljs-number">0</span>;        <span class="hljs-comment">//读取事件</span>        <span class="hljs-keyword">int</span> num_bytes = <span class="hljs-built_in">read</span>(fd, event_buf, <span class="hljs-keyword">sizeof</span>(event_buf));        <span class="hljs-keyword">if</span> (num_bytes &lt; (<span class="hljs-keyword">int</span>)<span class="hljs-keyword">sizeof</span>(*event))        &#123;            <span class="hljs-keyword">if</span> (errno == EINTR)                <span class="hljs-keyword">continue</span>;            ALOGE(<span class="hljs-string">"***** ERROR! android_os_fileobserver_observe() got a short event!"</span>);            <span class="hljs-keyword">return</span>;        &#125;<span class="hljs-comment">//处理事件数组</span>        <span class="hljs-keyword">while</span> (num_bytes &gt;= (<span class="hljs-keyword">int</span>)<span class="hljs-keyword">sizeof</span>(*event))        &#123;            <span class="hljs-keyword">int</span> event_size;            event = (struct inotify_event *)(event_buf + event_pos);            jstring path = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">if</span> (event-&gt;len &gt; <span class="hljs-number">0</span>)            &#123;                path = env-&gt;NewStringUTF(event-&gt;name);            &#125;                      <span class="hljs-comment">//调用ObserverThread中的onEvent方法 </span>            env-&gt;CallVoidMethod(object, method_onEvent, event-&gt;wd, event-&gt;mask, path);            <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;                env-&gt;ExceptionDescribe();                env-&gt;ExceptionClear();            &#125;            <span class="hljs-keyword">if</span> (path != <span class="hljs-literal">NULL</span>)            &#123;                env-&gt;DeleteLocalRef(path);            &#125;            event_size = <span class="hljs-keyword">sizeof</span>(*event) + event-&gt;len;            num_bytes -= event_size;            event_pos += event_size;        &#125;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><p>不难看出,此处的循环主要就是从inotity中取出事件,然后回调ObserverThread中的<code>onEvent()</code>方法.现在,回到ObserverThread中的<code>onEvent()</code>方法中:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> wfd, <span class="hljs-keyword">int</span> mask, String path)</span> </span>&#123;            <span class="hljs-comment">// look up our observer, fixing up the map if necessary...</span>            FileObserver observer = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">synchronized</span> (m_observers) &#123;                <span class="hljs-comment">//根据wfd找出FileObserver对象</span>                WeakReference weak = m_observers.get(wfd);                <span class="hljs-keyword">if</span> (weak != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">// can happen with lots of events from a dead wfd</span>                    observer = (FileObserver) weak.get();                    <span class="hljs-keyword">if</span> (observer == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//observer已经被回收时,从m_observers中删除该对象</span>                        m_observers.remove(wfd);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// ...then call out to the observer without the sync lock held</span>            <span class="hljs-keyword">if</span> (observer != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//回调给FileObserver中的onEvent方法进行处理</span>                    observer.onEvent(mask, path);                &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;                    Log.wtf(LOG_TAG, <span class="hljs-string">"Unhandled exception in FileObserver "</span> + observer, throwable);                &#125;            &#125;        &#125;</code></pre><p>FileObserver中的<code>onEvent()</code>为抽象方法,也就是要求你继承FileObserver,并实现该方法,在其中做相关的操作.<br>到现在为止我们已经明白了ObserverThread如何被启动,以及如何获取inotify中的事件,并回调给上层进行处理.</p><h2 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h2><p>上面提到m_observers表,该表维护着已经注册的FileObserver对象.接下来,我们就就来看看FileObserver中的<code>startWatching()</code>方法,该方法注册FileObserver对象,也是启动监控的过程:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWatching</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (m_descriptor &lt; <span class="hljs-number">0</span>) &#123;            m_descriptor = s_observerThread.startWatching(m_path, m_mask, <span class="hljs-keyword">this</span>);        &#125;    &#125;</code></pre><p>具体的注册操作委托给s_observerThread中的<code>startWatching()</code>:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startWatching</span><span class="hljs-params">(String path, <span class="hljs-keyword">int</span> mask, FileObserver observer)</span> </span>&#123;            <span class="hljs-comment">//调用native方法startWatching,并得到一个watch对象的句柄</span>            <span class="hljs-keyword">int</span> wfd = startWatching(m_fd, path, mask);            Integer i = <span class="hljs-keyword">new</span> Integer(wfd);            <span class="hljs-keyword">if</span> (wfd &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">synchronized</span> (m_observers) &#123;                    <span class="hljs-comment">//将watch对象句柄和当前FileObserver关联</span>                    m_observers.put(i, <span class="hljs-keyword">new</span> WeakReference(observer));                &#125;            &#125;            <span class="hljs-keyword">return</span> i;        &#125;</code></pre><p>该方法中同样调用了native方法,其具体实现是:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">android_os_fileobserver_startWatching</span><span class="hljs-params">(JNIEnv* env, jobject object, jint fd, jstring pathString, jint mask)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span>    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path = env-&gt;GetStringUTFChars(pathString, <span class="hljs-literal">NULL</span>);        res = inotify_add_watch(fd, path, mask);        env-&gt;ReleaseStringUTFChars(pathString, path);    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>不难看出,这里通过inotify的<code>inotify_add_watch()</code>为上面生成的inotify对象添加watch对象,并将watch对象的句柄返回给ObserverThread.</p><h2 id="停止监控"><a href="#停止监控" class="headerlink" title="停止监控"></a>停止监控</h2><p>到现在我们已经了解了如何注册watch句柄到FileObserver对象.有了注册的过程,当然少不了反注册的过程.同样,FileObserver为我们提供了<code>stopWatching()</code>来实现反注册,即停止监控的过程:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWatching</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (m_descriptor &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//已经注册过的才能反注册</span>           s_observerThread.stopWatching(m_descriptor);           m_descriptor = -<span class="hljs-number">1</span>;       &#125;   &#125;</code></pre><p>具体的实现也是交给了s_observerThread的<code>stopWatching()</code>方法:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWatching</span><span class="hljs-params">(<span class="hljs-keyword">int</span> descriptor)</span> </span>&#123;            stopWatching(m_fd, descriptor);        &#125;</code></pre><p>接着委托给了natvie方法:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_os_fileobserver_stopWatching</span><span class="hljs-params">(JNIEnv* env, jobject object, jint fd, jint wfd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span>    inotify_rm_watch((<span class="hljs-keyword">int</span>)fd, (<span class="hljs-keyword">uint32_t</span>)wfd);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><p>这里的实现非常简单,就是调用inotify_rm_watch方法来解除inotify实例和watch实例的关系.</p><p>到现在为止我们已经弄明白了FileObserver的实现原理,为了方便理解,我们用一张简单的图来描述整个过程:</p><p><img src="https://i.imgur.com/sdTuQlt.jpg" srcset="/img/loading.gif" alt="notify"></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>想必你已经了解了FileObserver的实现原理,接下里我们来看看如何使用.要想实现文件监控,我们只需要继承FileObserver类,并在<code>onEvent()</code>处理相关事件即可,简单的用代码演示一下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDCardObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileObserver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SDCardObserver</span><span class="hljs-params">(String path)</span> </span>&#123;        <span class="hljs-keyword">super</span>(path);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String s)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (i) &#123;            <span class="hljs-keyword">case</span> FileObserver.ALL_EVENTS:                <span class="hljs-comment">//全部事件</span>                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> FileObserver.CREATE:                <span class="hljs-comment">//文件被创建</span>                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> FileObserver.DELETE:                <span class="hljs-comment">//文件被删除</span>                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> FileObserver.MODIFY:                <span class="hljs-comment">//文件被修改</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>这里我们需要注意两个问题:</p><ol><li>谨慎的选择你要处理的事件,否则可能造成死循环.</li><li>当不再需要监听时,请记得停止监控</li><li>需要注意FileObserver对象被垃圾回收的情况,从上面的原理中我们知道,该对象被回收后将不会再触发事件.</li></ol>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>inotify</tag>
      
      <tag>FileObserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空杯心态,一个程序员的自我修炼</title>
    <link href="/2016/06/11/%E7%A9%BA%E6%9D%AF%E5%BF%83%E6%80%81/"/>
    <url>/2016/06/11/%E7%A9%BA%E6%9D%AF%E5%BF%83%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="禅师与我"><a href="#禅师与我" class="headerlink" title="禅师与我"></a>禅师与我</h1><p>梦回远古,我是一个佛学造诣很深的人,听说某个寺庙有位德高望重的老禅师,便去拜访.老禅师的徒弟接待我时,我心想:我是佛学造诣很深的人,这老禅师算是老几,有我厉害,有我懂得多么?后来,老禅师十分恭敬的接待了我并为我沏茶.可在倒水时,明明杯子里的水已经满了,但老禅师还是在不停的倒,我心有疑惑,便笑问道:”大师,杯中水已满,为什么还不停下来?”.禅师说:”是啊,既然已经满了,干嘛还要倒呢?”</p><p>是啊,既然我已经觉得自己知道很多了为什么还要来请教禅师?是我知道的太多还是太少?回想这半年,经常觉得自己学了很多了,不自觉的便有飘飘然然的感觉.现在想想不是自己知道的太多,而恰恰是自己知道的太少.井底的青蛙之所以觉得天空只有巴掌那么大,恰是因为他对外面的世界知道的太少.</p><h2 id="我看”空杯”"><a href="#我看”空杯”" class="headerlink" title="我看”空杯”"></a>我看”空杯”</h2><p>所谓的空杯心态,我想应该是应该时刻要把自己想象成”一个空着的杯子”吧,每个人心里都有一个个杯子,里边盛的是过往的成就,荣耀,知识等.我们不断的往这杯子中倒水,直到水满溢出,此时如果不将水倒出,是没有办法再装下后面倒进来的水的.其实,空杯是一种做事心态,也是一种求学心态.盛满水的水杯,再也容不下多余的水,认为自己通晓天下知识的人,再也学不到新的知识;认为自己武功天下第一的人,再也不会有任何的提高;认为自己技术到达顶尖的人,再也不会有任何的进步了.</p><p>回顾以前,很多时候总是自夸:我以前如何如何,随之而来的便是对现在处境的贬低.现在想想当时之所以这么说就是没有正确的认识自己的现在,没有倒掉心中的这杯水.想认识现在,先放下对以往的执念吧:过去的荣耀与成功只是属于曾经你认识的自己,而不是现在.带着执念而来的我,就像是一个盛满水的杯子,再也容不下了其他,会觉得现在的生活事事不如意,人人不开心,最终便是牢骚满腹,止步于此.</p><p>试想,我以这样的心态再过十年会是如何?十年之后的大街上,我会不会是那个满脸怒气,只会碎碎念,怨天尤人的男子,会不会成为自己最不想成为的人?也许,在将来的某次的同学聚会上,偶然被同学谈起:哦,你说的的是他啊,好险现在精神有问题吧.</p><p>对不起,这不是我想要的自己,我的梦很大,如果现在就是一个满水的杯子了,那么我的未来也就止步于此.</p><h2 id="倒掉这杯水"><a href="#倒掉这杯水" class="headerlink" title="倒掉这杯水"></a>倒掉这杯水</h2><p>我们知道,任何事物的变化和发展都是”外在否定”和”内在否定”协同促成的结果.可以说,否定是事物发展的本质.对于我们而言,外在的否定意味着周围人对你的批评与建议或是其他不顺你心的事情,通常来说这是一个我们自己被动的过程.而内在否定则是,自己要从内心舍弃过去的荣耀和成就,这是个我们主动的过程.很多时候,不如意事十之八九,当周围的环境在否定你的时候,不要急于反驳别人,也不要急于为自己找借口开脱,不妨耐下心来先认同别人指责,也就是先自我否定一番,问问自己为什么是这样.一来,可以减少彼此的对立和冲突,二来可以发现自己真正的问题.</p><p>当然,这说起来容易做起来难.我们有情绪,有感受,有着所谓的自尊,所以往往一遇到别人指责时就会大发雷霆,觉得对方故意找茬…别否认,大部分人都是这样的:任何动物都是具有领域意识,人也不例外.更准确的说,人的领域意识可以说是最强的,有时候别人的一句话足可以激怒我们,不是么?在原始时代,较强的领域意识能够保护我们的生命,免于我们被捕杀,后来随着”群体”的形成以及”大规模合作社会”的到来,我们的领域意识已经在一定程度上降低,但是这项远古已经进化出来的心理本能仍然对我们有着莫大的影响,尽管它不是那么的符合目前社会的要求.</p><p>有一个简单有效的做法帮到了我:在我想说话之前,延迟3s中让自己站在别人的立场上思考一下.原本,我是一个乐于争辩,并且有时易怒,这样做的好处就是减少了不必要的争辩,无形之中节约了自己的时间,除此之外,内心更加理性平和.</p><p>倒掉这杯水,更重要的是在思维上的转变:要认同空杯心态,忘却过去,尤其是过往的荣耀;承认自己的的渺小和无知,接受别人的优秀,虚心学习;放大视野,缩小焦点.</p><blockquote><p>有一项定律叫做彼得定律,大意是在一个等级制度中,每个员工趋向上升到他所不能升任的职位.这项定律,对于我们在自己成长的某个阶段同样也成立:在一个成长阶段中,我们总会趋向上升到自己能发展的最大高度.<br>不禁问自己,在一个阶段中达到最大高度后就只能止步于此么?或者说人总会成长到某个高度,然后止步不前?</p></blockquote><p>我们回想自己求学的时候,在小学这个阶段,我们掌握小学的知识后,如果继续求学便可以到初中这个阶段,在掌握初中的知识后,便可以继续高中求学…如此往复,直至死亡到来,生命停止.不难发现,求学是可以突破局限的.当自己困惑,停止不前的时候,不妨想想,自己有多久没有真正的”学习”了,不妨冥想一下,用一张纸,写下自己的困惑.然后,开始新的求学之路,直到某一天你拿出当时写有困惑的那张纸,自己却不仅仅笑笑,将其撕碎,扬起.</p><h1 id="求学三重"><a href="#求学三重" class="headerlink" title="求学三重"></a>求学三重</h1><p>想起清代国学大师王国维说过学问三种境界,终有些感悟.</p><ul><li>一重:昨夜西风凋碧树,独上高楼,望尽天涯路</li><li>二重:衣带渐宽终不悔,为伊消得人憔悴</li><li>三重:众里寻他千百度,暮然回首,那人却在灯火阑珊处.</li></ul><p>所谓一重境界是求学和立志之境,此为”知”,也就是知识和智慧.换言之提醒我们要保持不断的学习,不断的提高自己,增加智慧,于此同时,在这个过程中要去寻找自己的方向.</p><p>所谓二重境界是”行”之境界,为实现自己的理想而坚韧不拔.一重境界是二重境界的基石,二重境界是一重境界的目标,所谓的知行合一,说的就是如此.</p><p>所谓三重境界是”得”之境界,功到自然成啊.能做到知行合一,便是得.得,不是需要可以追求的,而恰是水到渠成.</p><h1 id="读书三思"><a href="#读书三思" class="headerlink" title="读书三思"></a>读书三思</h1><p>求学,从哪里学?一是于书中学,所言书中自有颜如玉;二是从世中学,所谓世事洞明皆学问.对于刚毕业的我们,涉世未深,很大程度上做不到从世中学,因此,选择从书中就是最佳的途径了,也就是读书.</p><p>读书有三思:为知,为己,为人:</p><ul><li>开始读书时,是为了获得知识,增长智慧,这是我们认知这个世界的前提,此阶段为”为知”.</li><li>后续读书时,从关注的外在逐渐延伸到内在,也就是我们开始逐渐的想要认知自己,发现自我,这个阶段是我们经常所说的修身,在这个阶段中,培养自己的人格和道德是主要的旋律.-</li><li>最后便是”为人”.为人,不是指做给别人看,也不是为刻意的赢得别人的夸奖和赞同,而是为他人着想,为天下人立志.</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>大概是这些了.希望自己能在下半年中,以新的面貌和更加积极的心态面对生活.</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于时间的思考</title>
    <link href="/2016/03/14/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2016/03/14/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="你的时间值多少钱"><a href="#你的时间值多少钱" class="headerlink" title="你的时间值多少钱?"></a>你的时间值多少钱?</h1><p>用金钱量化的时间,这是我第一次这么做.虽然打小老师就说”时间就是金钱”,可我真没有计算过.如果说时间的价值是一秒钟一块钱,一天共有86400秒.这意味这你每分钟都在花出3600块钱.那我每秒又能够赚多少钱呢,算了算,大概是0.00634195元吧.这数字的比值是相当恐怖的,在这之前,我从未想过.</p><h1 id="关于模式"><a href="#关于模式" class="headerlink" title="关于模式"></a>关于模式</h1><p>将具体事物抽象是为了寻求共同的模式,而将抽象事物再转为具体的事物才能更好的理解抽象事物.举一反三这个词语充分说明了这个过程,通过一个具体来抽象共同点,进而在将抽象应用于具体,这个过程是一个循环往复,不断加深理解的过程.</p><p>在这之前,我有个很显著的缺点就是,对于具体的问题无法理解或者说是不会理解,这就导致了抽象不完全.除此之外,我并没有将抽象之后的结果反过来应用与具体的事物,这就进一步造成了我对知识理解不深.</p><p>我曾认为我对逻辑和数学不感兴趣,这本身没有什么兴趣.当然大部分人也是对逻辑和数学没有兴趣的,我们这些人共同的特征是无法感知这些无形的,抽象的理论会给我们带来怎样有形的,具体的好处—这些好处本身也同样或者可能是更加抽象和无形的.这就造成了一个很大的问题:无法理解导致我们的不加重视,进而导致我们错失了那些原本可能给我们带来很大受益的事物.对于抽象事物最有效的理解方式莫过于把他给具体化.对于时间同样也是如此,将抽象的事物进行量化,有助于加深你对时间的理解,进而帮助你更好的珍惜时间.</p><h1 id="巴普洛夫的哪条狗"><a href="#巴普洛夫的哪条狗" class="headerlink" title="巴普洛夫的哪条狗"></a>巴普洛夫的哪条狗</h1><p>作为动物,我们学的一个最基本的途径就是通过反馈—–想起巴普洛夫的那条狗.但是对于时间来说,我们很难得到这样的反馈.你今天浪费了时间或者有效利用了时间,并不会有什么反馈给你,当然在你可能会在某个瞬间觉得后悔或者高兴,但那也仅仅是转瞬即逝,不是吗?后面,你照样还会浪费时间,照样会在某个瞬间觉得惭愧..如此循环以往,这太正常了,最后经过几天的时间之后,你就会变得麻木,甚至你的原始大脑会阻止你想起这段糟糕的经历,最终的结果就是你只能在浪费时间中荒废掉.如果把一天的时间当作考试,每天晚上12点的时候,时间这个老师就开始给你批阅卷子,并在你面前讲试卷,这样的话,我们可能每个人都会非常珍惜时间了,这就是反馈的作用.</p><p>遗憾的是,时间就是一位旁观者,只负责记录用过的时间,而不会把浪费和珍惜这两种结果反馈给你,这也就是我们大多数情况下根本意识不到时间.</p><h1 id="对时间的两大曲解"><a href="#对时间的两大曲解" class="headerlink" title="对时间的两大曲解"></a>对时间的两大曲解</h1><blockquote><p>a.我们通常认为,明天会拥有更多的时间;<br>b.我们普遍相信在明天会拥有比今天更多的金钱;`</p></blockquote><p>这两大曲解也同样可以用来解释,我们做事为什么总是拖沓.我们的大脑以为自己将来会有更多的时间去做自己想要做的事情.而实际上,明天甚至会比今天更紧张,这就导致大脑一直企图寻找下一天(这一天的时间是非常充裕,最好是48小时的).现在想想也就是明白了为何古人早以感叹”明日复明日,明日何其多!我生待明日,万事成蹉跎”了.</p><p>此外从每个人的感受出发,时间并不是匀速的.爱因斯坦曾经这么解释相对论:一位先生和一位漂亮的女士在一起呆上一个小时,他会感觉像是一分钟;但如果让他在火炉子上带上一分钟,他会感觉比一小时还长.这句话同样也可以用来形容时间的流逝.</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思维</tag>
      
      <tag>时间</tag>
      
      <tag>巴普洛夫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析Base64原理</title>
    <link href="/2016/01/01/%E7%AE%80%E6%9E%90Base64%E5%8E%9F%E7%90%86/"/>
    <url>/2016/01/01/%E7%AE%80%E6%9E%90Base64%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Base64起源"><a href="#Base64起源" class="headerlink" title="Base64起源"></a>Base64起源</h1><p>在网络传输中,有些方式并不支持所有的字节,比如早起邮件系统支持传输可见字符,而对于ASCII中的控制字符就无法传输.在比如在传图图片时,由于图片对应的二进制流中的字节有些事不可见字符,因此也就无法进行传输,那怎么在不修改传输协议的前提下,来支持所有的字节传输呢,换言之就是讲不可见字符表示为可见字符?</p><p>而Base64就是该问题的一种解决方案,它是一种基于64个可见字符来表示二进制数据的方法.</p><h1 id="Base64编码规则"><a href="#Base64编码规则" class="headerlink" title="Base64编码规则"></a>Base64编码规则</h1><p>Base64首先定义一个可见字符的索引表,按照规定,字符选用了<code>A-Z、a-z、0-9、+、/</code>这64个字符.</p><ul><li><p>接下来首先将待转换的字符串每三个化为一组,由于每个字符占一个字节,因此一组三个字符占3个字节,共24位.</p></li><li><p>然后将上面的24个二进制位按照6位一组,划分为4组.</p></li><li><p>在每组前面填两个0,每组由6位变为8位一组,即由4组6位,变成4组8位,共4字节.</p></li><li><p>然后将每个字节转为十进制,并从字符索引表中取出对应下标处的字符.</p></li></ul><p>字符索引表结构如下:</p><p>  <img src="https://i.imgur.com/THhlJsk.jpg" srcset="/img/loading.gif" alt="image-20181120152040773"></p><h2 id="abc编码实例"><a href="#abc编码实例" class="headerlink" title="abc编码实例"></a>abc编码实例</h2><p>假设我们要将abc进行编码,根据上述流程,其变化如下:</p><p><img src="https://i.imgur.com/3OUetHh.jpg" srcset="/img/loading.gif" alt="image-20181120151944396"></p><p>因此对abc编码之后的结果为<code>YWJj</code>.</p><p>在转换过程中,如果到最后发现最后字符不够3个情况,那么此时可以在最后追加相应个数的<code>=</code>符号即可,补齐规则如下:</p><ul><li><p>2个字节:2个字节共16个二进制位,按照规则进行分组,每6位一组,则第3组缺少2位,用0补齐后边,由于第4组完全没有数据则用<code>=</code>补上即可.</p></li><li><p>1个字节:1字节共8个二进制位,按照规则进行分组,每6个一组,则第2组缺少4位,用0补齐后边,由于后面两组没有对应数据,直接都用<code>=</code>补上即可.</p></li></ul><h2 id="A编码实例"><a href="#A编码实例" class="headerlink" title="A编码实例"></a>A编码实例</h2><p>以对A进行编码为例,其过程如下所示:</p><p><img src="https://i.imgur.com/3K9o0O5.jpg" srcset="/img/loading.gif" alt="image-20181120151845402"></p><p>最终编码结果为<code>QQ==</code>.</p><h2 id="AA编码实例"><a href="#AA编码实例" class="headerlink" title="AA编码实例"></a>AA编码实例</h2><p>以对AA进行编码为例,其过程如下所示:</p><p><img src="https://i.imgur.com/FGBvVz5.jpg" srcset="/img/loading.gif" alt="image-20181120151753037"></p><p>最终编码结果为<code>QUE=</code>.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Base64编码过程中,涉及到填充操作,因此相比原来会占用更多的空间,通常Base64编码后的文本要比原来大1/3.此外,为什么Base64要以3个字节为一组呢?因为6和8的最小公倍数为24,3个字节正好是24位,每6个bit位一组,恰好能够分为4组.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从VFS谈文件读写</title>
    <link href="/2015/12/05/%E4%BB%8EVFS%E7%9C%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <url>/2015/12/05/%E4%BB%8EVFS%E7%9C%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h1><p>在CPU的所有指令中,有一些指令是非常危险的,误用将导致系统崩溃.为了安全起见CPU将指令分为<strong><em>特权指令和非特权指令</em></strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令.Intel CPU提供0到3四种级别的运行模式，数字越小特权越高.在Linux机器上，CPU只会在以下两种模式下运行:</p><ul><li>受信任的内核模式(0级别),对应于Linux中的内核态</li><li>受限制的用户模式(3级别): 对应于LInux中的用户态</li></ul><p>处理器总处于以下状态中的一种：</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li><li>用户态，运行于用户空间。</li></ol><p>用户空间的应用程序,通过系统调用进入内核空间.此时用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值,变量等.而所谓的进程上下文可以被看做是用户进程传递给内核的这些参数以及内核要保存的那些变量和寄存器值和当时的环境等。</p><p>硬件通过触发中断信号,导致内核调用中断处理程序进入内核空间.这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>除了内核本身处于内核模式以外,所有的用户进程都运行在用户模式之中.用户空间的程序无法直接执行内核代码,它们不能直接调用内核空间中的函数.运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行.在Linux中,除异常和中断陷入外,系统调用是用户空间访问内核的唯一合法入口.</p><blockquote><p>系统调用的本质也是中断.相对外围硬件设备产生的硬中断信号而言,系统调用产生的是软中断.异常,中断和系统调用三者最大的区别在于系统调用是进程主动请求切换的,而其他两者则是被动的.</p></blockquote><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>虚拟文件系统(VFS)作为Kernal的子系统,为用户空间提供了文件和文件系统相关的接口.平常我们说对文件的操作就建立在这之上.那为什么要有虚拟文件系统呢?你可以虚拟机文件系统理解为Java中接口的概念:一个操作系统可以支持不同的底层文件系统(具体Java接口的实现),如 NTFS, FAT, ext3等,为了给内核和用户进程提供统一的文件系统视图,而在内核和用户进程之间加入了抽象层,即虚拟文件系统(Java接口定义).</p><p>内核通过VFS能够方便,简单地支持各种类型的文件系统.底层文件系统通过提供VFS所期望的抽象接口和数据结构,这样内核就可以简单的和任何文件系统协作,并且这样提供给用户空间的接口,也可以和任何文件系统无缝连接在一起.也即是说所有的文件操作都通过VFS,由VFS来适配不同的底层文件系统,最终完成操作.</p><p><img src="https://i.imgur.com/KVrP0Yk.png" srcset="/img/loading.gif" alt="image-20181020173556821"></p><p>简单点说,VFS定义了一个通用文件系统的接口层和适配层:</p><ul><li>接口层: 为用户进程提供一组操作文件/目录/其他对象的统一方法</li><li>适配层: 和不同的底层文件系统进行适配</li></ul><h2 id="虚拟文件系统结构"><a href="#虚拟文件系统结构" class="headerlink" title="虚拟文件系统结构"></a>虚拟文件系统结构</h2><p>VFS整体采用面向对象的设计思路,采用不同的数据结构表示不同的结构对象.由于内核主要是由C代码编写,因此内核中关于对象的实现都是采用结构体实现,同时这些结构体中也包含有关操作这些数据结构的函数指针,当然操作函数具体的实现依赖于不同的底层文件系统.</p><p>在VFS中主要由以下四个主要的对象类型:</p><ul><li>超级块对象</li><li>索引节点对象</li><li>目录项对象</li><li>文件对象</li></ul><h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>整个文件系统的第一块空间,代表一个具体已经安装的文件系统,用于保存一个文件系统的所有元数据，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息,可以说是文件系统的信息库.文件系统的任意元数据修改都要修改超级块,另外为了性能考虑,该超级块对象是常驻内存并被缓存的。</p><p>在内核中该对象由结构体<code>super_block</code>表示,其操作由结构体<code>super_operations</code>表示,定义在<code>linux/fs.h</code>中.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>      <span class="hljs-title">s_list</span>;</span>          <span class="hljs-comment">// 指向所有超级块的链表 </span>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span>  *<span class="hljs-title">s_op</span>;</span>  <span class="hljs-comment">// 超级块方法</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>         *<span class="hljs-title">s_root</span>;</span>         <span class="hljs-comment">// 目录挂载点 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>          <span class="hljs-title">s_lock</span>;</span>       <span class="hljs-comment">// 超级块信号量</span>    <span class="hljs-keyword">int</span>                   s_count;         <span class="hljs-comment">// 超级块引用计数</span>    ......            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>      <span class="hljs-title">s_inodes</span>;</span>        <span class="hljs-comment">// inode链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_info</span>       *<span class="hljs-title">s_mtd</span>;</span>          <span class="hljs-comment">// 存储磁盘信息</span>    <span class="hljs-keyword">fmode_t</span>               s_mode;          <span class="hljs-comment">// 安装权限</span>&#125;;</code></pre><h3 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h3><p>索引节点对象包含了内核在操作文件或目录是需要的全部信息,如文件的长度、创建及修改时间、权限、所属关系等,通过命令<code>ls -li</code>可查看.一个索引节点代表文件系统中(索引节点仅当文件被访问时才在内存中创建)的一个文件,可以是设备或者管道这样的特殊文件.</p><p>在内核中该对象由结构体<code>inode</code>表示,其操作由结构体<code>inode_operations</code>表示,定义在linux/fs.h中.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">i_hash</span>;</span>          <span class="hljs-comment">// 散列表，用于快速查找inode</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>  <span class="hljs-title">i_list</span>;</span>    <span class="hljs-comment">// 索引节点链表 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>  <span class="hljs-title">i_sb_list</span>;</span> <span class="hljs-comment">// 超级块链表超级块 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>  <span class="hljs-title">i_dentry</span>;</span>  <span class="hljs-comment">// 目录项链表 </span>    ......    <span class="hljs-keyword">uid_t</span>             i_uid;     <span class="hljs-comment">// 使用者id </span>    <span class="hljs-keyword">gid_t</span>              i_gid;     <span class="hljs-comment">// 使用组id </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>   <span class="hljs-title">i_atime</span>;</span>   <span class="hljs-comment">// 最后访问时间 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>   <span class="hljs-title">i_mtime</span>;</span>   <span class="hljs-comment">// 最后修改时间 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>   <span class="hljs-title">i_ctime</span>;</span>    <span class="hljs-comment">// 最后改变时间 </span>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span>  *<span class="hljs-title">i_op</span>;</span>       <span class="hljs-comment">// 索引节点操作函数 </span>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>   *<span class="hljs-title">i_fop</span>;</span>      <span class="hljs-comment">// 缺省的索引节点操作 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>            *<span class="hljs-title">i_sb</span>;</span>        <span class="hljs-comment">// 相关的超级块 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>          *<span class="hljs-title">i_mapping</span>;</span>   <span class="hljs-comment">// 相关的地址映射 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>          <span class="hljs-title">i_data</span>;</span>       <span class="hljs-comment">// 设备地址映射 </span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>                  i_flags;      <span class="hljs-comment">// 文件系统标志 </span>    <span class="hljs-keyword">void</span>                          *i_private;   <span class="hljs-comment">// fs 私有指针 </span>&#125;;</code></pre><h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>在文件路径中,每个部分都是目录项对象.比如<code>/bin/cp</code>中的/,bin,cp都属于目录项对象.另外目录项对象不需要在磁盘中存储因此没有对应的磁盘数据结构,VFS根据字符串形式的路径名现场创建它.</p><p>在内核中,该对象由结构体dentry表示,其操作由结构体<code>dentry_operator</code>表示,定义在<code>linux/dcache.h</code>中.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span>    <span class="hljs-keyword">atomic_t</span>      d_count;         <span class="hljs-comment">// 使用计数 </span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  d_flags;         <span class="hljs-comment">// 目录项标识 </span>    <span class="hljs-keyword">spinlock_t</span>    d_lock;          <span class="hljs-comment">// 单目录项锁 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>  *<span class="hljs-title">d_inode</span>;</span>        <span class="hljs-comment">// 相关联的索引节点 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span>  <span class="hljs-title">d_hash</span>;</span>     <span class="hljs-comment">// 散列表 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>      *<span class="hljs-title">d_parent</span>;</span>  <span class="hljs-comment">// 父目录的目录项对象 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span>        <span class="hljs-title">d_name</span>;</span>     <span class="hljs-comment">// 目录项名称 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">d_lru</span>;</span>      <span class="hljs-comment">// 未使用的链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">d_subdirs</span>;</span>  <span class="hljs-comment">// 子目录链表 </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">d_alias</span>;</span>    <span class="hljs-comment">// 索引节点别名链表</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       d_time;    <span class="hljs-comment">// 重置时间 </span>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> *<span class="hljs-title">d_op</span>;</span> <span class="hljs-comment">// 目录项操作相关函数 </span>        ......&#125;;</code></pre><h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象表示进程已经打开的文件,是已打开的文件在内存中的表示,该对象会由相应的<code>open()</code>系统调用创建,由<code>close()</code>系统调用撤销.需要注意的是,由于多个进程可以同时打开和操作同一个文件,这意味同一个文件也可能存在对个对应的文件对象,但由于是同一个文件，其索引节点对象是唯一的,这样就实现了共享同一个磁盘文件.</p><p>在内核中,该对象由<code>file</code>结构体表示,其操作由结构体<code>file_operator</code>表示,定义在<code>linux/fs.h</code>中.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span>    <span class="hljs-keyword">union</span> &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">llist_node</span>  <span class="hljs-title">fu_llist</span>;</span>      <span class="hljs-comment">// 文件对象链表</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>    <span class="hljs-title">fu_rcuhead</span>;</span>    <span class="hljs-comment">// 释放之后的RCU链表</span>    &#125; f_u;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span>            <span class="hljs-title">f_path</span>;</span>        <span class="hljs-comment">// 包含的目录项</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>           *<span class="hljs-title">f_inode</span>;</span>      <span class="hljs-comment">// 缓存值</span>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>  *<span class="hljs-title">f_op</span>;</span>  <span class="hljs-comment">// 文件操作函数</span>    <span class="hljs-keyword">spinlock_t</span>f_lock;               <span class="hljs-comment">// 锁</span>    <span class="hljs-keyword">atomic_long_t</span>          f_count;       <span class="hljs-comment">// 文件对象引用计数</span>        ......            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>   *<span class="hljs-title">f_mapping</span>;</span>&#125;;</code></pre><p>除了以上四种对象类型外,还需要之道以下对象类型的含义:</p><ul><li>address_space:它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么address_space可以说关联了内存系统和文件系统.</li><li>block:表示实际记录文件的内容，一个文件可能会占用多个 block。</li></ul><h2 id="文件打开列表"><a href="#文件打开列表" class="headerlink" title="文件打开列表"></a>文件打开列表</h2><p>文件打开列表包含了内核中所有已经打开的文件。每个列表表项是一个文件对象file.在超级块对象结构体(super_block)中存在s_files指针(内核版本3.19之前存在)指向了“已打开文件列表模块”，该链表信息是所有进程共享的。</p><h2 id="进程与虚拟文件系统"><a href="#进程与虚拟文件系统" class="headerlink" title="进程与虚拟文件系统"></a>进程与虚拟文件系统</h2><p>系统中每一个进程都有自己的一组打开的文件,其中<code>file_struct</code>,<code>fs_struct</code>,`这两个个结构体有效的将进程和VFS联系在一起.内核中使用结构体task_struct表示单个进程的描述符，它包含一个进程的所有信息,如进程的空间地址,挂起信号,进程状态进程号,打开的文件等信息,其定义如下:</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;        <span class="hljs-comment">//进程状态</span>        ......            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span> *<span class="hljs-title">fs</span>;</span><span class="hljs-comment">// 文件系统信息</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span> <span class="hljs-comment">// 打开文件信息</span>        ......&#125;</code></pre><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>在Linux中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数,它本质就是files_struct结构体中fd_array域数组的索引.在后续会进一步说明.</p><h4 id="file-struct"><a href="#file-struct" class="headerlink" title="file_struct"></a>file_struct</h4><p>每个进程用一个files_struct结构来记录其使用文件的情况,主要包含文件描述符表和打开文件对象的信息.站在进程的角度上,这个files_struct结构又被称为用户打开文件表，它是进程的私有数据。从task_struct定义可见,其中一个files的指针来指向files_struct.</p><p>files_struct结构在include/linux/fdtable.h中定义如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span>  <span class="hljs-keyword">atomic_t</span>     count;           <span class="hljs-comment">// 结构的使用计数,表示共享该表的进程数</span>  <span class="hljs-keyword">bool</span>         resize_in_progress;  <span class="hljs-keyword">wait_queue_head_t</span> resize_wait;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span> __<span class="hljs-title">rcu</span>  *<span class="hljs-title">fdt</span>;</span>   <span class="hljs-comment">// 指向其他fd表的指针</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdtable</span>        <span class="hljs-title">fdtab</span>;</span>  <span class="hljs-comment">// 基fd表</span>  <span class="hljs-keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;  <span class="hljs-keyword">int</span> next_fd;        <span class="hljs-comment">// 已分配的文件描述符加1,表示缓存下一个可用的fd</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      close_on_exec_init[<span class="hljs-number">1</span>];     <span class="hljs-comment">// 执行exec()时关闭的文件描述符链表</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      open_fds_init[<span class="hljs-number">1</span>];          <span class="hljs-comment">// 文件描述符的初值集合</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>      full_fds_bits_init[<span class="hljs-number">1</span>];        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> __<span class="hljs-title">rcu</span>  *<span class="hljs-title">fd_array</span>[<span class="hljs-title">NR_OPEN_DEFAULT</span>];</span><span class="hljs-comment">// 文件对象指针的初始化数组</span>&#125;;</code></pre><p>fd_array数组指针指向已打开的文件对象,在64位机器上NR_OPEN_DEFAULT这个宏的值为64.如果进程打开的文件数目多于64，内核就分配一个新的、更大的文件指针数组，并且将fdt指针指向它.</p><p>对于在fd数组中有入口地址的每个文件来说，数组的索引就是<strong>文件描述符（<em>file descriptor</em>）</strong>。通常，数组的第一个元素（索引为0）是进程的标准输入文件，数组的第二个元素（索引为1）是进程的标准输出文件，数组的第三个元素（索引为2）是进程的标准错误文件.</p><h3 id="fs-struct"><a href="#fs-struct" class="headerlink" title="fs_struct"></a>fs_struct</h3><p>进程和文件系统相关的信息,由fs_struct结构体表示,定义在<code>linux/fs_struct.h</code>中.从task_struct定义可见,其中一个fs的指针来指向fs_struct.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span> &#123;</span><span class="hljs-keyword">int</span> users;             <span class="hljs-comment">// 用户数目</span><span class="hljs-keyword">spinlock_t</span> lock;       <span class="hljs-comment">// 结构体的锁</span><span class="hljs-keyword">seqcount_t</span> seq;   <span class="hljs-keyword">int</span> umask;             <span class="hljs-comment">// 当打开文件设置文件权限时所使用的位掩码</span><span class="hljs-keyword">int</span> in_exec;           <span class="hljs-comment">// 当前正在执行的文件</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span> <span class="hljs-title">root</span>, <span class="hljs-title">pwd</span>;</span> <span class="hljs-comment">// 根目录路径,当前工作目录的路径</span>&#125; __randomize_layout;</code></pre><h1 id="I-O缓冲区"><a href="#I-O缓冲区" class="headerlink" title="I/O缓冲区"></a>I/O缓冲区</h1><p>在I/O过程中，涉及到磁盘和内存数据之间的传输操作,由于磁盘读写速度远小于内存读写速度,因此需要将读取过的数据缓存在内存里。而用于缓存数据的内存区域就是高速缓冲区（buffer).通过缓冲区能够有效的减少磁盘I/O的操作.</p><blockquote><p>需要注意buffer cache和cpu cache不同,前者用于磁盘和内存之间的缓冲,而后者用于CPU和内存之间的缓冲.</p></blockquote><p>对于I/O缓冲区,根据具体I/O操作设备不同,主要由两种缓冲方案:buffer cache和page cache.buffer cache即块缓冲器，page cache即页缓冲器,两者最大的区别是缓存粒度的不同:buffer cache面向的是文件系统的块;而内核的内存管理组件采用了比文件系统的块更高级别的抽象-页page.</p><p>在linux不支持虚拟内存机制之前，还没有页的概念，此时缓冲区以块为单位对设备进行操作。在linux支持虚拟内存的机制后页是虚拟内存管理的最小单位，此时采用页缓冲的机制来缓冲内存。Linux2.6之后这两个缓存机制被整合在一起，页和块可以相互映射.另外页缓存面向的是虚拟内存，块缓存是面向块设备。</p><p>page cache是由内存中的物理页组成的,其内容对应磁盘上的物理块.文件IO操作实际上只和page cache交互.在内核中,使用结构体<code>page</code>表示一个内存中的物理页.</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags; <span class="hljs-comment">// flags来记录该页是否是脏页，是否正在被写回等等</span><span class="hljs-keyword">union</span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span>            <span class="hljs-comment">// 指向了地址空间address_space，表示是一个页缓存器中的页，对应于一个文件的地址空间</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span>;</span> <span class="hljs-keyword">pgoff_t</span> index;<span class="hljs-comment">// 记录这个页在文件中的页偏移量；</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;&#125;;        ......                  &#125;;        ......&#125;</code></pre><p>文件系统的inode实际维护了这个文件所有的块block的块号，通过对文件偏移量offset取模可以很快定位到这个偏移量所在的文件系统的块号。同样，通过对文件偏移量offset进行取模可以计算出偏移量所在的页的偏移量。</p><p>page cache使用address_space来作为文件系统和页缓存的中间桥梁,用来表示一个文件在页缓存器中已经缓存了的物理页.此外,在address_space中通过指针可以方便的获取文件inode和struct page的信息.</p><h1 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h1><h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><ol><li>进程调用库函数向内核发起读文件请求</li><li>内核检查进程的文件描述符定位到虚拟文件系统的已打开文件列表中的文件表项</li><li>调用该文件可用的系统调用函数read()</li><li>read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode</li><li>在inode中，通过文件内容偏移量计算出要读取的页</li><li>通过inode找到文件对应的address_space</li><li>在address_space中访问该文件的页缓存树，查找对应的页缓存结点.如果页缓存命中,则直接返回文件内容;否则会产生一个缺页中断异常,接下来会创建一个页缓存页，并通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页,之后再重新进行第6步查找页缓存</li><li>文件读取完成</li></ol><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><ol><li>进程调用函数库向内核发起写文件请求.</li><li>内核检查进程的文件描述符定位到虚拟文件系统的已打开文件列表中的文件表项.</li><li>调用该文件可用的系统调用函数write().</li><li>write()函数通过文件表项链接到目录项模块,根据传入的文件路径,在目录项中检索,找到该文件的inode</li><li>在inode中,通过文件内容偏移量计算出要读取的页.</li><li>通过inode找到文件对应的address_space.</li><li>在address_space中访问该文件的页缓存树,查找对应的页缓存节点.如果页缓存命中,直接把文件修改内容同步到页缓存中,此时写入操作意味着已经完成了;如果页缓存页缺失,则会产生缺页中断异常,接下来会创建一个页缓存页,并通过inode节点找到文件该页的磁盘地址,然后读取相应的内容来填充该,重新在address_space中访问该文件的页缓存树,查找对应的页缓存节点,页缓存页命中,接下来就和之前一样,将修改同步到该缓存页即可.</li><li>页缓冲中的页一旦被修改,就会被标记成脏页.脏页需要被同步写会磁盘中,以保证磁盘和缓存的中数据一致.一方面我们可以在进程中主动调用sync()或者fsync()调用把脏页写回,另一方面pdflush进程会定时把脏页写回到磁盘.需要注意的是脏页一旦处在写回磁盘的过程中,该页会设置写回标记,此时会被加锁,内核不能讲该页置换出内存,其他写请求将被阻塞直到写操作完成.</li></ol>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>VFS</tag>
      
      <tag>内核态</tag>
      
      <tag>系统调用</tag>
      
      <tag>I/O缓冲区</tag>
      
      <tag>文件读写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StringBuilder &amp; StringBuffer设计与实现</title>
    <link href="/2015/12/01/StringBuilder%E5%92%8CStringBuilder%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2015/12/01/StringBuilder%E5%92%8CStringBuilder%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h1><p><code>StringBuilder</code>与<code>StringBuffer</code>是两个常用的操作字符串的类,两者最大的区别在于<code>StringBuilder</code>是线程不安全的，而<code>StringBuffer</code>是线程安全的,此外前者是JDK1.5加入的.后者在JDK1.0就有了.</p><p>和String不同,StringBuilder和StringBuffer都是基于数组扩容来实现,其核心代码在其父类AbstractStringBuilder中.可以说StringBuilder和StringBuffer的实现原理是一样的,唯一的不同的是StringBuffer的大多数方法都是用synchronize修饰,即线程安全.直接看下其类图更明了些:</p><p> <img src="https://i.imgur.com/5dT87rr.png" srcset="/img/loading.gif" alt="image-20181023093009963"></p><p><code>AbstractStringBuilder</code>内部用一个<code>char[]</code>数组保存字符串，可以在构造的时候指定初始容量方法,其构造方法定义如下:</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-keyword">char</span>[] value;<span class="hljs-comment">// 用于保存字符串</span>    <span class="hljs-keyword">int</span> count;        AbstractStringBuilder() &#123;    &#125;<span class="hljs-comment">// 在创建时可以为其指定初始化容量.</span>    AbstractStringBuilder(<span class="hljs-keyword">int</span> capacity) &#123;        value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[capacity];    &#125;    &#125;</code></pre><h2 id="扩容算法"><a href="#扩容算法" class="headerlink" title="扩容算法"></a>扩容算法</h2><p>正如之前我们提到StringBuilder和StringBuffer最核心的地方是数据扩容,现在我们来看一下其数组扩容的原理.由于StringBuilder和StringBuffer都是AbstractStringBuilder的子类,其扩容原理一致,因此扩容算法在AbstrStringBuilder中实现.数组扩容算法主要由<code>ensureCapacityInternal()</code>来实现:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;      <span class="hljs-comment">//minimumCapcity为当前所需容量大小,value.length表示当前数组容量大小</span>      <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//数组扩容,先计算扩容之后的容量,再将原数组内容拷贝</span>          value = Arrays.copyOf(value,                  newCapacity(minimumCapacity));      &#125;  &#125;</code></pre><p><code>newCapacity()</code>用于计算扩容之后数组的大小:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;       <span class="hljs-comment">// overflow-conscious code</span>       <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;       <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;           newCapacity = minCapacity;       &#125;       <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)           ? hugeCapacity(minCapacity)           : newCapacity;   &#125;</code></pre><p>不难看出扩容算法是首先把容量扩大为原来的两倍,然后加2.如果扩容之后容量仍小于指定容量,那么就把新的容量设置为指定容量minCapacity.接下来对新的容量进行判断,主要是对溢出情况的判断,因此可能会抛出OutMemoryError.</p><h2 id="字符串追加"><a href="#字符串追加" class="headerlink" title="字符串追加"></a>字符串追加</h2><p>append()是我们最常用的方法,用于实现字符串追加.append()有很多的重载方法,用于实现不同类型的数据的追加.常见用于追加String类型的方法定义如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;      <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)          <span class="hljs-keyword">return</span> appendNull();      <span class="hljs-keyword">int</span> len = str.length();      <span class="hljs-comment">//1. 数组扩容</span>      ensureCapacityInternal(count + len);      <span class="hljs-comment">//2. 将str拷贝到value数组中</span>      str.getChars(<span class="hljs-number">0</span>, len, value, count);      <span class="hljs-comment">//3. 修改count</span>      count += len;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  &#125;</code></pre><p>所有的追加操作实现比较类似,首先进行扩容操作,其次进行字符串的拷贝,最后进行字符数中字符个数的修改.需要注意如果<code>str</code>是<code>null</code>,则会调用<code>appendNull()</code>方法。这个方法其实是追加了<code>&#39;n&#39;</code>、<code>&#39;u&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;l&#39;</code>这几个字符。如果不是<code>null</code>,则首先进行扩容操作,然后调用<code>String</code>的<code>getChars()</code>方法将<code>str</code>追加到<code>value</code>末尾.最后返回对象本身，所以<code>append()</code>可以连续调用.</p><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>在AbstractStringBuilder中提供了<code>subString()</code>方法用于字符串的截取操作,其最终都通过以下方法实现:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);    <span class="hljs-keyword">if</span> (end &gt; count)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end);    <span class="hljs-keyword">if</span> (start &gt; end)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end - start);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, start, end - start);&#125;</code></pre><p>不难发现截取操作返回的是一个新的String对象,在生成该String对象的时候内部需要进行数组拷贝操作,相对耗时,因此在操作”长”字符串时需要格外注意.</p><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>由于AbstractStringBuilder实现字符串操作和核心操作,因此StringBuilder只需要继承它,并调用父类的大部分操作即可.首先我们来看其构造函数:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">super</span>(capacity);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);    append(str);&#125;</code></pre><p>可以看出StringBuilder的默认的容量大小为16,当然也允许我们指定初始化容量.在某些情况下我们可能直接用String类型初始化它,此时的初始化容量大小是:String类型的长度+16,比如初始化字符串是”Hello”,那么此时默认的容量大小为5+16.</p><h2 id="字符串追加-1"><a href="#字符串追加-1" class="headerlink" title="字符串追加"></a>字符串追加</h2><p>StringBuilder的append()方法直接调用了父类AbstractStringBuilder中的方法,如<code>append(String str)</code></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">super</span>.append(str);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;</code></pre><p>需要注意,对于StringBuilder而言,不要进行没必要的toString()方法调用,因为每次调用toString()时,都new了一个新的String对象.因此频繁调用会增加gc的工作量,影响性能.</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">// Create a copy, don't share the array</span>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);   &#125;</code></pre><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>和StringBuilder实现类似,只不过考虑到线程同步的问题,在StringBuffer中很多方法使用synchronized修饰,以<code>append(String str)</code>为例:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;      toStringCache = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">super</span>.append(str);      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  &#125;</code></pre><h2 id="字符串数组缓存"><a href="#字符串数组缓存" class="headerlink" title="字符串数组缓存"></a>字符串数组缓存</h2><p>和StringBuilder不同的是StringBuffer中多了toStingCache属性,其定义如下:</p><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuffer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;&#125;</code></pre><p>toStringCache用于缓存最后一次调用toString时的字符数组.一旦StringBuffer发生修改时(比如append时),该字段会被重新置为null,其实现如下:</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;         toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>); &#125;</code></pre><p>在toString()中除了会初始化toStringCache对象,返回的String对象也和StringBuider的不一样:构造出来的String对象并没有实际复制字符串,只是把value指定了构造参数.这样可以节省复制元素的时间.</p><pre><code class="hljs java">String(<span class="hljs-keyword">char</span>[] value, <span class="hljs-keyword">boolean</span> share) &#123;    <span class="hljs-comment">// assert share : "unshared not supported";</span>    <span class="hljs-keyword">this</span>.value = value;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>StringBuilder</code>和<code>StringBuffer</code>都是可变字符串，前者线程不安全，后者线程安全。</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的大部分方法均调用父类<code>AbstractStringBuilder</code>的实现。其扩容机制首先是把容量变为原来容量的2倍加2。最大容量是<code>Integer.MAX_VALUE</code>，也就是<code>0x7fffffff</code>。</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的默认容量都是16，事先预先估计好字符串的大小避免扩容带来的时间消耗。</li></ul><p>需要注意,在jdk 8之前,字符串常量被保存在PermGen中,而从jdk 1.8开始,JVM采用Metaspace来代替了PermGen,字符串常量也因此被转移到了堆区.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>StringBuffer</tag>
      
      <tag>StringBuilder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈JVM类加载机制</title>
    <link href="/2015/11/13/%E6%B7%B1%E5%85%A5JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2015/11/13/%E6%B7%B1%E5%85%A5JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p> 虚拟机将class文件加载到内存，并对数据校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。在java中语言中类的加载、连接和初始化过程都是在程序运行期间完成的，因此在类加载时的效率相对编译型语言较低，除此之外，只有在任何一个类只有在运行期间使用到该类的时候才会将该类加到内存中。总之，java依赖于运行期间动态加载和动态链接来实现类的动态使用。其整个流程如下：</p><p>  <img src="https://i.imgur.com/S0Vifmh.png" srcset="/img/loading.gif" alt="image-20180721131144810"></p><p>  其中加载、检验、准备、初始化和卸载这个五个阶段的顺序是固定的，而解析则未必。为了支持动态绑定，解析这个过程可以发生在初始化阶段之后。另外，这个过程表示的是按顺序开始，不是所谓的第一步、第二步、第三步的关系，而往往是交叉混合进行，在一个阶段中可能调用或者激活另一个过程。<br>  java中，对于初始化阶段，有且只有以下五种情况才会对要求类立刻“初始化”：</p><ol><li>使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。</li><li>初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。</li><li>使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化。</li><li>虚拟机启动时，用户会先初始化要执行的主类（含有main）</li><li>jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。</li></ol><p>按照以上流程，我们重点来看<code>加载-校验-准备-解析-初始化</code>五个阶段。</p><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>加载过程主要完成三件事情：</p><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li><li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li></ol><p>这个过程主要就是类加载器完成。（对于HotSpot虚拟而言，Class对象较为特殊，其被放置在方法区而不是堆中）</p><h2 id="校验阶段"><a href="#校验阶段" class="headerlink" title="校验阶段"></a>校验阶段</h2><p>此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。主要包括以下四个阶段：</p><ol><li>文件格式验证：基于字节流验证，验证字节流符合当前的Class文件格式的规范，能被当前虚拟机处理。验证通过后，字节流才会进入内存的方法区进行存储。</li><li>元数据验证：基于方法区的存储结构验证，对字节码进行语义验证，确保不存在不符合java语言规范的元数据信息。</li><li>字节码验证：基于方法区的存储结构验证，通过对数据流和控制流的分析，保证被检验类的方法在运行时不会做出危害虚拟机的动作。</li><li>符号引用验证：基于方法区的存储结构验证，发生在解析阶段，确保能够将符号引用成功的解析为直接引用，其目的是确保解析动作正常执行。换句话说就是对类自身以外的信息进行匹配性校验。 </li></ol><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>仅仅为类变量（static修饰的变量）分配内存空间并且设置该类变量的初始值（这里的初始值指的是数据类型默认的零值），这里不包含用final修饰的static，因为用final修饰的类变量在javac执行编译期间就会分配，同时要注意，这里不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量会在对象实例化是随着对象一起被分配在java堆中。举例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value=<span class="hljs-number">33</span>;</code></pre><p>这据代码的赋值过程分两次，一是上面我们提到的阶段，此时的value将会被赋值为0；而value=33这个过程发生在类构造器的<code>&lt;clinit&gt;()</code>方法中。</p><h2 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h2><p>解析阶段主要是将常量池内的符号引用替换为直接引用的过程。符号引用是用一组符号来描述目标，可以是任何字面量，而直接引用则是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。通常而言一个符号引用在不同虚拟机实例翻译出来的直接引用一般不会相同。<br>和C之类的纯编译型语言不同，Java类文件在编译过程中只会生成class文件，并不会进行连接操作，这意味在编译阶段Java类并不知道引用类的实际地址，因此只能用“符号引用”来代表引用类。举个例子来说明，在com.sbbic.Person类中引用了com.sbbic.Animal类，在编译阶段，Person类并不知道Animal的实际内存地址，因此只能用com.sbbic.Animal来代表Animal真实的内存地址。在解析阶段，JVM可以通过解析该符号引用，来确定com.sbbic.Animal类的真实内存地址（如果该类未被加载过，则先加载）。<br>主要有以下四种：</p><ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>类加载过程的最后一步，到该阶段才真正开始执行类中定义的java代码，同样该阶段也是初始化类变量和其他资源（执行static字段和静态代码块），换句话说该阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<br><code>&lt;clinit&gt;</code>()方法是由编译器自动收集类中所有的类变量的赋值动作和静态语句块（static{}）中的语句合并而成。<code>&lt;clinit&gt;()</code>方法和实例构造方法不同<code>&lt;init&gt;()</code>不同，它不需要显示的调用父类的<code>&lt;clinit&gt;()</code>，虚拟机会保证父类<code>的&lt;clinit&gt;(</code>)方法在子类的<code>&lt;clinit&gt;()</code>方法之前执行完成，也就是说，父类的静态语句块和静态变量优先于子类中变量赋值操作。<br><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量赋值的操作，那么编译器就不会为这个类生<code>成&lt;clinit&gt;(</code>)方法。接口中不能使用静态语句块，单仍然有变量赋值的操作，所以仍然可以生成<code>&lt;clinit&gt;(</code>)方法，但与类不同的执行接口<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。</p><p>通常系统自带的类加载器分为三种：</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用类加载器</li></ul><p><strong>启动类加载器</strong>(Bootstrap ClassLoader):由C/C++实现,负责加载<code>&lt;JAVA_HOME&gt;\jre\lib</code>目录下或者是-Xbootclasspath所指定路径下目录以及系统属性sun.boot.class.path制定的目录中特定名称的jar包到虚拟机内存中。在JVM启动时,通过Bootstrap ClassLoader加载rt.jar,并初始化sun.misc.Launcher从而创建Extension ClassLoader和Application ClassLoader的实例.</p><p>需要注意的是,Bootstrap ClassLoader智慧加载特定名称的类库,比如rt.jar.这意味我们自定义的jar扔到<code>&lt;JAVA_HOME&gt;\jre\lib</code>也不会被加载.我们可以通过以下代码,查看Bootstrap ClassLoader到底初始化了那些类库:</p> <pre><code class="hljs java">URL[] urLs = Launcher.getBootstrapClassPath().getURLs();     <span class="hljs-keyword">for</span> (URL urL : urLs) &#123;         System.out.println(urL.toExternalForm());     &#125;</code></pre><p><strong>扩展类加载器</strong>（Extension Classloader）：只有一个实例,由sun.misc.Launcher$ExtClassLoader实现,负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下或是被系统属性java.ext.dirs所指定路径目录下的所有类库。</p><p><strong>应用类加载器</strong>(Application ClassLoader):只有一个实例,由sun.misc.Launcher$AppClassLoader实现,负责加载系统环境变量ClassPath或者系统属性java.class.path制定目录下的所有类库，如果应用程序中没有定义自己的加载器，则该加载器也就是默认的类加载器.该加载器可以通过以下获取：</p><p><code>java.lang.ClassLoader.getSystemClassLoader</code></p><p>以上三种是我们经常认识最多,除此之外还包括<strong>线程上下文类加载器</strong>(Thread Context ClassLoader)和<strong>自定义类加载器</strong>.</p><p>每个线程都有一个类加载器(jdk 1.2后引入),称之为Thread Context ClassLoader,即线程上下文类加载器,如果线程创建时没有设置,则默认从父线程中继承一个,如果在应用全局内都没有设置,则所有线程上下文类加载器就是Application ClassLoader.可通过Thread.currentThread().setContextClassLoader(ClassLoader)来设置,通过Thread.currentThread().getContextClassLoader()来获取.</p><p>我们来想想线程上下文加载器有什么用的?该类加载器容许父类加载器通过子类加载器加载所需要的类库,也就是打破了我们下文所说的双亲委派模型.这有什么好处呢?利用线程上下文加载器,我们能够实现所有的代码热替换,热部署,Android中的热更新原理也是借鉴如此的.</p><p>至于自定义加载器就更简单了,JVM运行我们通过自定义的ClassLoader加载相关的类库.</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>当一个类加载器收到一个类加载的请求，它首先会将该请求委派给父类加载器去加载，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该被传入到顶层的启动类加载器(Bootstrap ClassLoader)中，只有当父类加载器反馈无法完成这个列的加载请求时（它的搜索范围内不存在这个类），子类加载器才尝试加载。其层次结构示意图如下：</p><p><img src="https://i.imgur.com/uAEqUUe.png" srcset="/img/loading.gif" alt="image-20180721131241091"></p><p>不难发现,该种加载流程的好处在于：</p><ol><li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li><li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。</li></ol><p>接下来,我们看看双亲委派模型是如何实现的：</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)       <span class="hljs-keyword">throws</span> ClassNotFoundException   &#123;       <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;           <span class="hljs-comment">// 首先先检查该类已经被加载过了</span>           Class c = findLoadedClass(name);           <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//该类没有加载过，交给父类加载</span>               <span class="hljs-keyword">long</span> t0 = System.nanoTime();               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//交给父类加载</span>                       c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                   &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父类不存在，则交给启动类加载器加载</span>                       c = findBootstrapClassOrNull(name);                   &#125;               &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                  <span class="hljs-comment">//父类加载器抛出异常，无法完成类加载请求</span>               &#125;               <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//</span>                   <span class="hljs-keyword">long</span> t1 = System.nanoTime();                   <span class="hljs-comment">//父类加载器无法完成类加载请求时，调用自身的findClass方法来完成类加载</span>                   c = findClass(name);                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                   sun.misc.PerfCounter.getFindClasses().increment();               &#125;           &#125;           <span class="hljs-keyword">if</span> (resolve) &#123;               resolveClass(c);           &#125;           <span class="hljs-keyword">return</span> c;       &#125;   &#125;</code></pre><p>这里有些童鞋会问,JVM怎么知道一个某个类加载器的父加载器呢?如果你有此疑问,请重新再看一遍.</p><h2 id="类加载器的特点"><a href="#类加载器的特点" class="headerlink" title="类加载器的特点"></a>类加载器的特点</h2><ol><li>运行任何一个程序时，总是由Application Loader开始加载指定的类。</li><li>一个类在收到加载类请求时，总是先交给其父类尝试加载。</li><li>Bootstrap Loader是最顶级的类加载器，其父加载器为null。</li></ol><h2 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h2><ol><li>通过命令行启动应用时由JVM初始化加载含有main()方法的主类。</li><li>通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</li><li>通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</li></ol><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>1、遵守双亲委派模型：继承ClassLoader，重写findClass()方法。<br>2、破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。<br>通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。<br>自定义类加载的目的是想要手动控制类的加载,那除了通过自定义的类加载器来手动加载类这种方式,还有其他的方式么?<br>利用现成的类加载器进行加载:</p><pre><code class="hljs java"><span class="hljs-number">1</span>. 利用当前类加载器Class.forName();<span class="hljs-number">2</span>. 通过系统类加载器Classloader.getSystemClassLoader().loadClass();<span class="hljs-number">3</span>. 通过上下文类加载器Thread.currentThread().getContextClassLoader().loadClass();</code></pre><p>利用URLClassLoader进行加载:</p><pre><code class="hljs java">URLClassLoader loader=<span class="hljs-keyword">new</span> URLClassLoader();loader.loadClass();</code></pre><p><strong>类加载实例演示：</strong><br>命令行下执行HelloWorld.java</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(<span class="hljs-string">"Hello world"</span>);    &#125;&#125;</code></pre><p>该段代码大体经过了一下步骤:</p><ol><li>寻找jre目录，寻找jvm.dll，并初始化JVM.</li><li>产生一个Bootstrap ClassLoader；</li><li>Bootstrap ClassLoader加载器会加载他指定路径下的java核心api，并且生成Extended ClassLoader加载器的实例，然后Extended ClassLoader会加载指定路径下的扩展java api，并将其父设置为Bootstrap ClassLoader。</li><li>Bootstrap ClassLoader生成Application ClassLoader，并将其父Loader设置为Extended ClassLoader。</li><li>最后由AppClass ClassLoader加载classpath目录下定义的类——HelloWorld类。</li></ol><p>我们上面谈到 Extended ClassLoader和Application ClassLoader是通过Launcher来创建,现在我们再看看源代码:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;       Launcher.ExtClassLoader var1;       <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//实例化ExtClassLoader</span>           var1 = Launcher.ExtClassLoader.getExtClassLoader();       &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">"Could not create extension class loader"</span>, var10);       &#125;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//实例化AppClassLoader</span>           <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);       &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">"Could not create application class loader"</span>, var9);       &#125;<span class="hljs-comment">//主线程设置默认的Context ClassLoader为AppClassLoader.</span><span class="hljs-comment">//因此在主线程中创建的子线程的Context ClassLoader 也是AppClassLoader</span>       Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);       String var2 = System.getProperty(<span class="hljs-string">"java.security.manager"</span>);       <span class="hljs-keyword">if</span>(var2 != <span class="hljs-keyword">null</span>) &#123;           SecurityManager var3 = <span class="hljs-keyword">null</span>;           <span class="hljs-keyword">if</span>(!<span class="hljs-string">""</span>.equals(var2) &amp;&amp; !<span class="hljs-string">"default"</span>.equals(var2)) &#123;               <span class="hljs-keyword">try</span> &#123;                   var3 = (SecurityManager)<span class="hljs-keyword">this</span>.loader.loadClass(var2).newInstance();               &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException var5) &#123;                   ;               &#125; <span class="hljs-keyword">catch</span> (InstantiationException var6) &#123;                   ;               &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var7) &#123;                   ;               &#125; <span class="hljs-keyword">catch</span> (ClassCastException var8) &#123;                   ;               &#125;           &#125; <span class="hljs-keyword">else</span> &#123;               var3 = <span class="hljs-keyword">new</span> SecurityManager();           &#125;           <span class="hljs-keyword">if</span>(var3 == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">"Could not create SecurityManager: "</span> + var2);           &#125;           System.setSecurityManager(var3);       &#125;   &#125;</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在明确上述内容之后，来思考几个问题:</p><ol><li>我们知道ClassLoader通过一个类的全限定名来获取二进制流,那么如果我们需要通过自定义类加载其来加载一个Jar包的时候,难道要自己遍历jar中的类,然后依次通过ClassLoader进行加载吗?或者说我们怎么来加载一个jar包呢?</li><li>如果一个类引用的其他的类,那么这个其他的类由谁来加载?</li><li>既然类可以由不同的加载器加载,那么如何确定两个类如何是同一个类?</li></ol><p>我们来依次解答这两个问题:<br>对于动态加载jar而言,JVM默认会使用第一次加载该jar中指定类的类加载器作为默认的ClassLoader.假设我们现在存在名为sbbic的jar包,该包中存在ClassA和ClassB这两个类(ClassA中没有引用ClassB).现在我们通过自定义的ClassLoaderA来加载在ClassA这个类,那么此时此时ClassLoaderA就成为sbbic.jar中其他类的默认类加载器.也就是,ClassB也默认会通过ClassLoaderA去加载.</p><p>那么如果ClassA中引用了ClassB呢?当类加载器在加载ClassA的时候,发现引用了ClassB,此时类加载如果检测到ClassB还没有被加载,则先回去加载.当ClassB加载完成后,继续回来加载ClassA.换句话说,类会通过自身对应的来加载其加载其他引用的类.</p><p>JVM规定,对于任何一个类,都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性,通俗点就是说,在jvm中判断两个类是否是同一个类取决于类加载和类本身,也就是同一个类加载器加载的同一份Class文件生成的Class对象才是相同的,类加载器不同,那么这两个类一定不相同.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Classloader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈JVM内存区域</title>
    <link href="/2015/11/01/%E6%B7%B1%E5%85%A5JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2015/11/01/%E6%B7%B1%E5%85%A5JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>首先，先大体的了解一下JAVA虚拟机运行时的内存结构：</p><p><img src="https://i.imgur.com/e5ApSVW.png" srcset="/img/loading.gif" alt="image-20181018102356172"></p><p>从线程的角度来看，总体分为私有和共享的两部分。共享的数据区为方法区，堆，本地库接口，以及每个JVM虚拟机中的JVM执行引擎，而线程私有的数据区则为虚拟机栈，本地方法栈，程序计数器。</p><h2 id="线程共享数据区"><a href="#线程共享数据区" class="headerlink" title="线程共享数据区"></a>线程共享数据区</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>在Java中我们最熟悉的就是对象，在内存中用来存放内存对象实例的区域称之为堆(Heap)，此区域由线程内存共享，在进行垃圾回收时，此区域是垃圾回收器重点关注的地方，因此我们也称之“GC堆”。早起的Java虚拟机严格按照JVM虚拟规范来涉及：任何的对象实例及数组都要在堆上分配，但随着JIT编译器的发展，许多新生的优化技术（比如对象逃逸分析技术）可允许对象根据实际情况在栈中分配，也就是说现在的虚拟机中的对象并不一定是分配在Heap当中。<br>要注意堆并不一定是连续的内存空间，只要保证是逻辑上的连续就行。（那么对象在连续的物理内存空间上分配和在不连续的物理内存空间分配的区别是什么？）</p><p>可能会抛出OutOfMemoryError：当没有足够的区域实现对象实例的分配,并且该堆也没法实现扩展。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>和堆相对的是方法区，用来存储已经被虚拟机加载的类信息、常量、静态变量以及经过JIT优化过后的代码等，和堆一样的是此区域也是线程共享的内存区域。<br>在虚拟机规范中，方法区虽然被划分为堆的一个逻辑部分，本质上并不属于堆，因此也称为非堆（Non-Heap）。<br>对于方法区的实现，虚拟机规范限制较少，因为不同的JVM团队可以选择不同的实现方案，比如HotSpot会用永生代来实现，而JRockit则采用了另外的方案。除此之外，方法区在物理上的内存空间可连续也可不连续、可实现动态扩展该区域的大小以及可实现或者不实现垃圾回收（对该区域的回收通常是常量池及类的卸载，但是效果往往较差，因此对该区域很少实现垃圾回收）。</p><p>可能会抛出OutOfMemoryError：当方法区无法满足内存分配需求时</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分，用于存放编译期间生成符号引用和各种字面量，其中符号引用会在连接中的解析阶段直接被替换为直接引用。需要注意的是，常量也可以在运行期间动态的被添加到常量池，以便提高效率，比如常见String中的intern()方法。</p><p>可能会抛出OutOfMemeoryError：因常量池也属于方法区，因此在申请不到内存的时候也会抛出异常。</p><h2 id="线程私有数据区"><a href="#线程私有数据区" class="headerlink" title="线程私有数据区"></a>线程私有数据区</h2><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>当一个线程被创建时，虚拟机栈也随之被创建，该区域为线程私有，无法被其他线程使用，因此不存在线程安全问题（从一个线程的角度来看，其中的方法执行顺序都是串行；当线程销毁时，该虚拟机栈也随之被销毁，JVM会自动释放该内存区域。虚拟机栈本身是一个先进后出的数据结构。在该线程中，每执行一个方法，就会生成一个栈（Stack Frame），并被压入虚拟机栈，当该方法执行完毕之后，该栈帧会被弹出，也就是说方法调用和方法返回的过程对应着栈帧入站和出栈的操作。更深的了解参看<a href="http://blog.csdn.net/dd864140130/article/details/49515403" target="_blank" rel="noopener">深入字节码执行引擎</a></p><p>可能抛出的异常：<br>StackOverflowError：如果线程内请求的栈深度超过虚拟机允许的深度，会抛出该异常。<br>OutOfMemoryError：如果虚拟机允许动态扩展栈的大小，但是在扩展时无法申请到足够的内存空间，会抛出该异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>虚拟机栈中栈帧对应的是java方法，执行的是字节码，而本地方法栈则对应的是Native方法。另外需要本地方法的实现方式并没有严格的规定，其使用的语言、数据结构没有统一的规定，对于该部分的实现，不同的团队也会有不同的实现。</p><p>可能抛出的异常：<br>和虚拟机栈类似，也会抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>每个线程内都有一块内存区域用来记录要执行的指令的地址，也就是所说的程序计数器。它用来描述需要执行哪一条字节码指令，该区域同样为线程私有。在一个线程内，从宏观的角度去看，所有要执行的指令可视为一个指令表（如下图所示），而程序计数器可视为当前正在执行的指令的行号。在执行过程中，字节码解释器，通过修改该区域的值来选择下一条要执行的指令的地址，而执行引擎则根据该区域的值来执行相应的指令，进而实现跳转、循环、线程恢复等操作。如果执行的native方法，则该计数器的值为Undefined。</p><p><img src="https://i.imgur.com/28wtn8t.png" srcset="/img/loading.gif" alt="image-20181018102453342"></p><p><img src="https://i.imgur.com/5AkRoKk.png" srcset="/img/loading.gif" alt="image-20181018102511284"><br>（上面两图我表示一个函数的指令集合，因为在线程内，函数的执行时串行的，同样可视为一个大的指令表）</p><p>现在我们简单的谈谈程序技术器为什么会被设计成线程私有的？如果JVM是单线程，那么程序计数器被设计成全局性的，是没有问题，因为同一时刻只能有一条指令被执行。而JVM是多线程，并且其多线程是则主要是通过处理器切换时间片来实现的。在支持多核多线程的处理器中，在同一时刻会有多个线程同时执行，而每个线程执行的指令或许都是不同的，如果此时在将程序计数器设计成全局唯一的，那显然是有问题的（程序计数器在某一个时刻，只能指向一条正在执行的指令），因此为了在线程切换能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，且不能被外部随意修改和访问。</p><p>该区域占用空间极小，虚拟机规范中没有规定该区域会抛出OutOfMemoryError异常，换言之，根本不会抛出异常。</p><h1 id="对象的内存结构"><a href="#对象的内存结构" class="headerlink" title="对象的内存结构"></a>对象的内存结构</h1><p>上面简单谈了JAVA的内存结构，下面简单的说说我们常见的“对象”的内存结构。我们以Hotspot虚拟机为例，其对象的内存结构大体分为三块区域：1、对象头；2、实例数据；3、对齐填充。结构如下图所示：</p><p><img src="https://i.imgur.com/Yz63X7S.png" srcset="/img/loading.gif" alt="image-20181018102546630"></p><p>1、实例数据是JAVA开发者最熟悉的部分，存储了我们在程序代码中所定义的各种类型的字段内容，是我们在开发过程中终点关注也是频繁操作的地方。<br>2、对齐填充区根据JVM的设计，可有可无，没有具体的功能实现，更多是为了让整个对象整齐（以倍数的形式存在），能被以统一的形式被处理。<br>3、对象头主要是对内服务，普通JAVA无需关心，其目的是为该对象设置附加数据，用于内容的识别和查找。该区域被划分为两部分，一部分用于存储对象自身的运行时数据，比如hashcode，锁标志，时间戳等信息，该部分也被称为Mark Word。另一部分则是类型指针<a href="并不是所有的JVM实现都要求对象头一定要有类型指针。">^1</a>，通过该指针，JVM能够确定该对象是那个类的实例。（为了更方便认知，我将第一部分称之为状态区，第二部分成为定位区）</p><p>那么对象头的存在解决了什么问题呢？通俗的说就是帮助JVM虚拟机了解这个对象：解决了它是谁的实例，它的独特性质是什么？现在再来细化一下上面的结构图</p><p><img src="https://i.imgur.com/AFLCfLf.png" srcset="/img/loading.gif" alt="image-20181018102625175"></p><h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>在JAVA开发中，常用的几种创建对象的方式有以下几种：</p><ol><li>通过new创建对象</li><li>通过使用反射机制，java.lang.reflect.Constructor类的newInstance()</li><li>通过调用对象的clone（）方法</li><li>同对象反序列化技术，调用java.io.ObjectInputStream对象的readObject（）方法。<br>第一种方式是我们最常使用，我们就来简单的解释一下该过程中，对象是如何被创建起来的，首先我们简单的参考该流程图：<br><img src="https://i.imgur.com/SYh3rUZ.png" srcset="/img/loading.gif" alt="image-20181018102724578"></li></ol><blockquote><p>1、虚拟机碰到new指令时，首先检查该指令的参数是否在常量池中能定位到一个类的引用，并检查符合引用代表的类是否已经被加载、解析和初始化过，如果没有则需要首先执行类加载过程。<br>2、类加载检查通过后，则为该对象分配内存空间。<br>3、内存分配完成后，该内存区域会被重置，业绩空间会被初始化为零值（对象头例外）<br>4、设置对象头信息<br>5、前四部完成之后，代表已经生成了一个未被初始化的对象，但是<code>init（）</code>方法还未执行，对象的字段还是零。因此一旦<code>init()</code>执行完毕之后，一个完整的对象才正式生成。</p></blockquote><h1 id="对象的查找"><a href="#对象的查找" class="headerlink" title="对象的查找"></a>对象的查找</h1><p>在栈中，对象的引用（reference）并不代表堆中真正的对象，那如何通过栈中对象的引用（reference）来操作堆中的具体对象呢？这个从对象引用来定位到真实对象的过程有两种实现的方式：</p><ul><li>句柄定位</li><li>直接定位</li></ul><h2 id="句柄定位"><a href="#句柄定位" class="headerlink" title="句柄定位"></a>句柄定位</h2><p>该种方式会在堆中实现划分出一块区域做句柄池，reference中存储的是对象的句柄地址，而句柄中包含对象的实例数据和类型数据的具体内存地址。<br>其结构如下:<img src="https://i.imgur.com/8sznEsP.png" srcset="/img/loading.gif" alt="image-20181018102756229"></p><h2 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h2><p>在该种方式中，reference中存储的是堆中真实对象的地址。<br><img src="https://i.imgur.com/HGQ16bp.png" srcset="/img/loading.gif" alt="image-20181018102824287"></p><p><strong>两者比较：</strong><br>句柄定位中reference存储的是句柄地址，相对稳定，对象改变时不会影响只需修改对象实例数据，而无须修改reference。<br>和句柄定位相比，直接定位的reference存储的是就是对象的地址，少了一层定位的过程，因此效率更高。除此之外,采用句柄定位更有利于GC机制的实现.</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈JVM字节码执行引擎</title>
    <link href="/2015/10/30/%E4%BA%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2015/10/30/%E4%BA%86%E8%A7%A3JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<p>就目前而言，所有的执行引擎的基本一致：</p><ol><li>输入：字节码文件</li><li>处理：字节码解析</li><li>输出：执行结果。</li></ol><p>物理机的执行引擎是由硬件实现的，和物理机的执行过程不同的是虚拟机的执行引擎由于自己实现的。</p><h1 id="运行时候的栈结构"><a href="#运行时候的栈结构" class="headerlink" title="运行时候的栈结构"></a>运行时候的栈结构</h1><p>每一个线程都有一个栈,也就是前文中提到的虚拟机栈，栈中的基本元素我们称之为栈帧。栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。每个栈帧都包括了一下几部分：局部变量表、操作数栈、动态连接、方法的返回地址 和一些额外的附加信息。</p><p>栈帧中需要多大的局部变量表和多深的操作数栈在编译代码的过程中已经完全确定，并写入到方法表的Code属性中。在活动的线程中，位于当前栈顶的栈帧才是有效的，称之为当前帧，与这个栈帧相关联的方法称为当前方法。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。需要注意的是一个栈中能容纳的栈帧是受限，过深的方法调用可能会导致StackOverFlowError，当然，我们可以认为设置栈的大小。其模型示意图大体如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxekc64aj8j30mo0h0mxz.jpg" srcset="/img/loading.gif" alt="image-20180815144510852"></p><p>针对上面的栈结构，我们重点解释一下局部变量表，操作栈，指令计数器几个概念：</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>是变量值的存储空间，由方法参数和方法内部定义的局部变量组成，其容量用Slot作为最小单位。在编译期间，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p><p>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。如果是实例方法，那局部变量表第0位索引的Slot存储的是方法所属对象实例的引用，因此在方法内可以通过关键字this来访问到这个隐含的参数。其余的参数按照参数表顺序排列，参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。举例说明：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    call(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);    ...    call2(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;    <span class="hljs-keyword">int</span> b=<span class="hljs-number">2</span>;      ...&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;    <span class="hljs-keyword">int</span> b=<span class="hljs-number">2</span>;    ...&#125;</code></pre><p>为了方便起见，假设以上两段代码在同一个类中。这时call()所对应的栈帧中的局部变量表大体如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekc71hsdj306203ht8k.jpg" srcset="/img/loading.gif" alt="image-20180815144627847"></p><p>而call2()所对应的栈帧的局部变量表大体如下：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekkcrwaej3068034glg.jpg" srcset="/img/loading.gif" alt="image-20180815144659903"></p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>后入先出栈，由字节码指令往栈中存数据和取数据，栈中的任何一个元素都是可以任意的Java数据类型。和局部变量类似，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。</p><p>当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数中写入和提取内容，也就是出栈/入栈操作。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。另外我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有该引用是为了支持方法调用过程中的动态连接。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>存放调用调用该方法的pc计数器的值。当一个方法开始之后，只有两种方式可以退出这个方法：</p><ul><li>1、执行引擎遇到任意一个方法返回的字节码指令，也就是所谓的正常完成出口。</li><li>2、在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种方式成为异常完成出口。正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，调用者的pc计数器的值作为返回地址，而通过异常退出的，返回地址是要通过异常处理器表来确定，栈帧中一般不会保存这部分信息。本质上，方法的退出就是当前栈帧出栈的过程。</p><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用的主要任务就是确定被调用方法的版本（即调用哪一个方法），该过程不涉及方法具体的运行过程。按照调用方式共分为两类：</p><ol><li>解析调用是静态的过程，在编译期间就完全确定目标方法。</li><li>分派调用即可能是静态，也可能是动态的，根据分派标准可以分为单分派和多分派。两两组合有形成了静态单分派、静态多分派、动态单分派、动态多分派</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>在Class文件中，所有方法调用中的目标方法都是常量池中的符号引用，在类加载的解析阶段，会将一部分符号引用转为直接引用，也就是在编译阶段就能够确定唯一的目标方法，这类方法的调用成为解析调用。此类方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，因此决定了他们都不可能通过继承或者别的方式重写该方法，符合这两类的方法主要有以下几种：静态方法、私有方法、实例构造器、父类方法。虚拟机中提供了以下几条方法调用指令：</p><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol><p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>分派调用更多的体现在多态上。  </p><ol><li>静态分派：所有依赖静态类型来定位方法执行版本的分派成为静态分派，发生在编译阶段，典型应用是方法<strong>重载</strong>。</li><li>动态分派：在运行期间根据实际类型来确定方法执行版本的分派成为动态分派，发生在程序运行期间，典型的应用是方法的<strong>重写</strong>。</li><li>单分派：根据一个宗量 对目标方法进行选择。</li><li>多分派：根据多于一个宗量对目标方法进行选择。</li></ol><h3 id="JVM实现动态分派"><a href="#JVM实现动态分派" class="headerlink" title="JVM实现动态分派"></a>JVM实现动态分派</h3><p>动态分派在Java中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此JVM在类的方法区中建立虚方法表（virtual method table）来提高性能。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址。<br>那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><h1 id="方法的执行"><a href="#方法的执行" class="headerlink" title="方法的执行"></a>方法的执行</h1><h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>在jdk 1.0时代，Java虚拟机完全是解释执行的，随着技术的发展，现在主流的虚拟机中大都包含了即时编译器(JIT)。因此，虚拟机在执行代码过程中，到底是解释执行还是编译执行，只有它自己才能准确判断了，但是无论什么虚拟机，其原理基本符合现代经典的编译原理，如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxekc80iwwj30d10ie3z3.jpg" srcset="/img/loading.gif" alt="image-20180815144728322"></p><p>在Java中，javac编译器完成了词法分析、语法分析以及抽象语法树的过程，最终遍历语法树生成线性字节码指令流的过程，此过程发生在虚拟机外部。</p><h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈</strong>的指令集架构，指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。另外一种指令集架构则是基于<strong>寄存器</strong>的指令集架构，典型的应用是x86的二进制指令集，比如传统的PC以及Android的Davlik虚拟机。</p><p>两者之间最直接的区别是，基于栈的指令集架构不需要硬件的支持，而基于寄存器的指令集架构则完全依赖硬件，这意味基于寄存器的指令集架构执行效率更高，单可移植性差，而基于栈的指令集架构的移植性更高，但执行效率相对较慢，c除此之外，相同的操作，基于栈的指令集往往需要更多的指令，比如同样执行2+3这种逻辑操作，其指令分别如下：<br>基于栈的计算流程（以Java虚拟机为例）：</p><pre><code class="hljs java">iconst_2  <span class="hljs-comment">//常量2入栈</span>istore_1  iconst_3  <span class="hljs-comment">//常量3入栈</span>istore_2iload_1iload_2iadd      <span class="hljs-comment">//常量2、3出栈，执行相加</span>istore_0  <span class="hljs-comment">//结果5入栈</span></code></pre><p>而基于寄存器的计算流程：</p><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span>  <span class="hljs-comment">//将eax寄存器的值设为1</span>add eax,<span class="hljs-number">3</span>  <span class="hljs-comment">//使eax寄存器的值加3</span></code></pre><h2 id="基于栈的代码执行示例"><a href="#基于栈的代码执行示例" class="headerlink" title="基于栈的代码执行示例"></a>基于栈的代码执行示例</h2><p>下面我们用简单的案例来解释一下JVM代码执行的过程，代码实例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> c=<span class="hljs-number">5</span>;<span class="hljs-keyword">return</span> result =(i+j)*c;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;MainTest.add();&#125;&#125;</code></pre><p>使用javap指令查看字节码：</p><pre><code class="hljs java">&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainTest</span><span class="hljs-params">()</span></span>;    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">2</span>: <span class="hljs-number">0</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">0</span>     <span class="hljs-comment">//栈深度2，局部变量4个，参数0个</span>         <span class="hljs-number">0</span>: iconst_0  <span class="hljs-comment">//对应result=0,0入栈</span>         <span class="hljs-number">1</span>: istore_0  <span class="hljs-comment">//取出栈顶元素0，将其存放在第0个局部变量solt中</span>         <span class="hljs-number">2</span>: iconst_2  <span class="hljs-comment">//对应i=2,2入栈</span>         <span class="hljs-number">3</span>: istore_1  <span class="hljs-comment">//取出栈顶元素2，将其存放在第1个局部变量solt中</span>         <span class="hljs-number">4</span>: iconst_3  <span class="hljs-comment">//对应 j=3，3入栈</span>         <span class="hljs-number">5</span>: istore_2  <span class="hljs-comment">//取出栈顶元素3，将其存放在第2个局部变量solt中</span>         <span class="hljs-number">6</span>: iconst_5  <span class="hljs-comment">//对应c=5，5入栈</span>         <span class="hljs-number">7</span>: istore_3  <span class="hljs-comment">//取出栈顶元素，将其存放在第3个局部变量solt中</span>         <span class="hljs-number">8</span>: iload_1   <span class="hljs-comment">//将局部变量表的第一个slot中的数值2复制到栈顶</span>         <span class="hljs-number">9</span>: iload_2   <span class="hljs-comment">//将局部变量表中的第二个slot中的数值3复制到栈顶</span>        <span class="hljs-number">10</span>: iadd      <span class="hljs-comment">//两个栈顶元素2,3出栈，执行相加，将结果5重新入栈</span>        <span class="hljs-number">11</span>: iload_3   <span class="hljs-comment">//将局部变量表中的第三个slot中的数字5复制到栈顶</span>        <span class="hljs-number">12</span>: imul      <span class="hljs-comment">//两个栈顶元素出栈5,5出栈，执行相乘，然后入栈</span>        <span class="hljs-number">13</span>: dup       <span class="hljs-comment">//复制栈顶元素25，并将复制值压入栈顶.</span>        <span class="hljs-number">14</span>: istore_0  <span class="hljs-comment">//取出栈顶元素25，将其存放在第0个局部变量solt中</span>        <span class="hljs-number">15</span>: ireturn   <span class="hljs-comment">//将栈顶元素25返回给它的调用者</span>      LineNumberTable:        line <span class="hljs-number">4</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">5</span>: <span class="hljs-number">2</span>        line <span class="hljs-number">6</span>: <span class="hljs-number">4</span>        line <span class="hljs-number">7</span>: <span class="hljs-number">6</span>        line <span class="hljs-number">8</span>: <span class="hljs-number">8</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         0: invokestatic  #2                  // Method add:()I         <span class="hljs-number">3</span>: pop         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">13</span>: <span class="hljs-number">4</span>&#125;</code></pre><p>执行过程中代码、操作数栈和局部变量表的变化情况如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxekc8y6rsj30ir0b6gm9.jpg" srcset="/img/loading.gif" alt="image-20180815144855571"></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxekc9z7vdj30im0a7750.jpg" srcset="/img/loading.gif" alt="image-20180815144922377"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekcavgr9j30im0a90te.jpg" srcset="/img/loading.gif" alt="image-20180815144947715"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekcbu7uoj30im0afaat.jpg" srcset="/img/loading.gif" alt="image-20180815145016645"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekccoh1lj30im09kt9e.jpg" srcset="/img/loading.gif" alt="image-20180815145054788"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxekce4h9qj30im0abt9h.jpg" srcset="/img/loading.gif" alt="image-20180815145116824"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxekcfgfqcj30in0a8gmb.jpg" srcset="/img/loading.gif" alt="image-20180815145148167"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxekcg3vhkj30il09twf9.jpg" srcset="/img/loading.gif" alt="image-20180815145234272"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxekche4wzj30im09zjs3.jpg" srcset="/img/loading.gif" alt="image-20180815145309935"></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxekciec41j30im09vwf9.jpg" srcset="/img/loading.gif" alt="image-20180815145332856"></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxekcjego7j30ij09igmd.jpg" srcset="/img/loading.gif" alt="image-20180815145355355"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxekgtoz9hj30im09h0tg.jpg" srcset="/img/loading.gif" alt="image-20180815145420538"></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxekguoejvj30im09nq3p.jpg" srcset="/img/loading.gif" alt="image-20180815145546202"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekcn04nkj30in09w0tg.jpg" srcset="/img/loading.gif" alt="image-20180815145610281"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxekcnzf9cj30im09tjs5.jpg" srcset="/img/loading.gif" alt="image-20180815145645730"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxekcqpt2cj30il09ndgk.jpg" srcset="/img/loading.gif" alt="image-20180815145711517"></p><h1 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h1><ul><li><p>Solt宗量：方法的接受者与方法的参数称为方法的宗量。举个例子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatcher</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">int</span> result=<span class="hljs-keyword">this</span>.execute(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pointX,pointY)</span></span>&#123;       <span class="hljs-comment">//TODO</span>   &#125;</code></pre><p>在dispatcher()方法中调用了execute(8,9)，那此时的方法接受者为当前this指向的对象，8、9为方法的参数，this对象和参数就是我们所说的宗量。  </p></li><li><p>容量槽，虚拟规范中并没有规定一个Slot应该占据多大的内存空间。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配本质就是:要求字节码操作的栈中的实际元素类型必须要字节码规定的元素类型一致。比如iadd指令规定操作两个整形数据，那么在操作栈中的实际元素的时候，栈中的两个元素也必须是整形。  </p></li><li><p>静态类型与动态类型:Animal dog=new Dog();其中的Animal我们称之为静态类型，而Dog称之为动态类型。两者都可以发生变化，区别在于静态类型只在使用时发生变化，变量本身的静态类型不会被改变，最终的静态类型是在编译期间可知的，而实际类型则是在运行期才可确定。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈JVM关闭与关闭钩子</title>
    <link href="/2015/10/15/%E8%B0%88JVM%E5%85%B3%E9%97%AD%E4%B8%8E%E5%85%B3%E9%97%AD%E9%92%A9%E5%AD%90/"/>
    <url>/2015/10/15/%E8%B0%88JVM%E5%85%B3%E9%97%AD%E4%B8%8E%E5%85%B3%E9%97%AD%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h1><p>通常而言，对于JVM的关闭我们很少去关注，但是了解JVM的关闭能帮我们在JVM关闭时做一些合理的事情。首先JVM的关闭方式可以分为三种：</p><ul><li>正常关闭：当最后一个非守护线程结束或者调用了System.exit或者通过其他特定平台的方法关闭（发送SIGINT，SIGTERM信号等）</li><li>强制关闭：通过调用Runtime.halt方法或者是在操作系统中直接kill(发送SIGKILL信号)掉JVM进程</li><li>异常关闭：运行中遇到RuntimeException异常等。</li></ul><p>在某些情况下，我们需要在JVM关闭时做些扫尾的工作，比如删除临时文件、停止日志服务以及内存数据写到磁盘等，为此JVM提供了关闭钩子（shutdown hooks）来做这些事情。另外特别注意的是：如果JVM因<strong>异常</strong>关闭，那么子线程（Hook本质上也是子线程）将不会停止。但在JVM被强行关闭时，这些线程都会被强行结束。</p><p>在了解关闭钩子之前我们首先认识<strong>Runtime</strong>。Runtime封装Java应用运行时的环境。通过Runtime实例，使得应用程序和其运行环境相连接。Runtime是在应用启动期间自动建立，应用程序不能够创建Runtime，但是我们可以通过<code>Runtime.getRuntime()</code>来获得当前应用的Runtime对象引用，通过该引用我们可以获得当前运行环境的相关信息，比如空闲内存、最大内存以及为当前虚拟机添加关闭钩子（<code>addShutdownHook（）</code>），执行指定命令（<code>exec（）</code>）等等。</p><h1 id="关闭钩子（shutdown-hook）"><a href="#关闭钩子（shutdown-hook）" class="headerlink" title="关闭钩子（shutdown hook）"></a>关闭钩子（shutdown hook）</h1><p>关闭钩子本质上是一个线程（也称为Hook线程），用来监听JVM的关闭。通过使用Runtime的addShutdownHook(Thread hook)可以向JVM注册一个关闭钩子。Hook线程在JVM <strong>正常关闭</strong>才会执行，在强制关闭时不会执行。</p><p>对于一个JVM中注册的多个关闭钩子它们将会并发执行，所以JVM并不能保证它的执行顺行。当所有的Hook线程执行完毕后，如果此时runFinalizersOnExit为true，那么JVM将先运行终结器，然后停止。Hook线程会延迟JVM的关闭时间，这就要求在编写钩子过程中必须要尽可能的减少Hook线程的执行时间。另外由于多个钩子是并发执行的，那么很可能因为代码不当导致出现竞态条件或死锁等问题，为了避免该问题，强烈建议在一个钩子中执行一系列操作。</p><p>另外在使用关闭钩子还要注意以下几点:</p><ol><li>不能在钩子调用<code>System.exit()</code>，否则卡住JVM的关闭过程，但是可以调用<code>Runtime.halt()</code>。</li><li>不能再钩子中再进行钩子的添加和删掉操作，否则将会抛出IllegalStateException。</li><li>在<code>System.exit()</code>之后添加的钩子无效。</li><li>当JVM收到SIGTERM命令（比如操作系统在关闭时）后，如果钩子线程在一定时间没有完成，那么Hook线程可能在执行过程中被终止。</li><li>Hool线程中同样会抛出异常，如果抛出异常又不处理，那么钩子的执行序列就会被停止。</li></ol><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>现在我们来通过源码来简单的分析一下shutdown hook的实现原理。简单的说，Shutdown类充当触发器，负责触发关闭钩子，而ApplicationShutdownHooks负责管理所有注册到JVM的关闭钩子。</p><h3 id="Shutdown源码分析"><a href="#Shutdown源码分析" class="headerlink" title="Shutdown源码分析"></a>Shutdown源码分析</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shutdown</span> </span>&#123;    <span class="hljs-comment">/* 定义了三个状态码，用来表示关闭状态，也是System.exit(state)中的state的取值范围 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HOOKS = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FINALIZERS = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> state = RUNNING;<span class="hljs-comment">//初始化为运行状态</span>    <span class="hljs-comment">//在JVM退出前是否要运行终结器？</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> runFinalizersOnExit = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 三种预定义的钩子类型，如下：</span>    <span class="hljs-comment">// (0) Console restore hook</span>    <span class="hljs-comment">// (1) Application hooks  （ApplicationShutdownHooks中添加的就是该类型）</span>    <span class="hljs-comment">// (2) DeleteOnExit hook</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SYSTEM_HOOKS = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Runnable[] hooks = <span class="hljs-keyword">new</span> Runnable[MAX_SYSTEM_HOOKS];    <span class="hljs-comment">// the index of the currently running shutdown hook to the hooks array</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> currentRunningHook = <span class="hljs-number">0</span>;    <span class="hljs-comment">/* The preceding static fields are protected by this lock */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123; &#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Lock();    <span class="hljs-comment">/* Lock object for the native halt method */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object haltLock = <span class="hljs-keyword">new</span> Lock();    <span class="hljs-comment">/* Invoked by Runtime.runFinalizersOnExit */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRunFinalizersOnExit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> run)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            runFinalizersOnExit = run;        &#125;    &#125;    <span class="hljs-comment">//添加钩子，每种类型的钩子只能添加一次。ApplicationShutdownHooks类用于管理应用程序添加的钩子，通过static&#123;&#125;在初始化阶段添加。</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot, <span class="hljs-keyword">boolean</span> registerShutdownInProgress, Runnable hook)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-keyword">if</span> (hooks[slot] != <span class="hljs-keyword">null</span>)<span class="hljs-comment">//每个钩子只能被添加一次</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">"Shutdown hook at slot "</span> + slot + <span class="hljs-string">" already registered"</span>);            <span class="hljs-keyword">if</span> (!registerShutdownInProgress) &#123;                <span class="hljs-keyword">if</span> (state &gt; RUNNING)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Shutdown in progress"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook))                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Shutdown in progress"</span>);            &#125;            hooks[slot] = hook;        &#125;    &#125;    <span class="hljs-comment">//遍历所有已注册到JVM的钩子，并执行</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runHooks</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX_SYSTEM_HOOKS; i++) &#123;            <span class="hljs-keyword">try</span> &#123;                Runnable hook;                <span class="hljs-keyword">synchronized</span> (lock) &#123;                    <span class="hljs-comment">// acquire the lock to make sure the hook registered during</span>                    <span class="hljs-comment">// shutdown is visible here.</span>                    currentRunningHook = i;                    hook = hooks[i];                &#125;                <span class="hljs-keyword">if</span> (hook != <span class="hljs-keyword">null</span>) hook.run();            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;                <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ThreadDeath) &#123;                    ThreadDeath td = (ThreadDeath)t;                    <span class="hljs-keyword">throw</span> td;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">halt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (haltLock) &#123;            halt0(status);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">halt0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runAllFinalizers</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//关闭钩子的序列，调用Shutdown.exit()或者Shutdown.shutdown()最终会调用该方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sequence</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-comment">/* Guard against the possibility of a daemon thread invoking exit</span><span class="hljs-comment">             * after DestroyJavaVM initiates the shutdown sequence</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (state != HOOKS) <span class="hljs-keyword">return</span>;        &#125;        runHooks();        <span class="hljs-keyword">boolean</span> rfoe;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            state = FINALIZERS;            rfoe = runFinalizersOnExit;        &#125;        <span class="hljs-keyword">if</span> (rfoe) runAllFinalizers();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> runMoreFinalizers = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) runFinalizersOnExit = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">switch</span> (state) &#123;            <span class="hljs-keyword">case</span> RUNNING:       <span class="hljs-comment">/* Initiate shutdown */</span>                state = HOOKS;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> HOOKS:         <span class="hljs-comment">/* Stall and halt */</span>                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> FINALIZERS:                <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">/* Halt immediately on nonzero status */</span>                    halt(status);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">/* Compatibility with old behavior:</span><span class="hljs-comment">                     * Run more finalizers and then halt</span><span class="hljs-comment">                     */</span>                    runMoreFinalizers = runFinalizersOnExit;                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (runMoreFinalizers) &#123;            runAllFinalizers();            halt(status);        &#125;        <span class="hljs-keyword">synchronized</span> (Shutdown<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-comment">/* Synchronize on the class object, causing any other thread</span><span class="hljs-comment">             * that attempts to initiate shutdown to stall indefinitely</span><span class="hljs-comment">             */</span>            sequence();            halt(status);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            <span class="hljs-keyword">switch</span> (state) &#123;            <span class="hljs-keyword">case</span> RUNNING:       <span class="hljs-comment">/* Initiate shutdown */</span>                state = HOOKS;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> HOOKS:         <span class="hljs-comment">/* Stall and then return */</span>            <span class="hljs-keyword">case</span> FINALIZERS:                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">synchronized</span> (Shutdown<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            sequence();        &#125;    &#125;&#125;</code></pre><h2 id="ApplicationShutdownHooks源码分析"><a href="#ApplicationShutdownHooks源码分析" class="headerlink" title="ApplicationShutdownHooks源码分析"></a>ApplicationShutdownHooks源码分析</h2><p>接着再来看一下ApplicationShutdownHooks类,该类用来管理和维护用户等级的钩子，也就是Shutdown提到的Application hooks。该类中通过使用一个Map性质的IdentityHashMap来保持用户的关闭钩子。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationShutdownHooks</span> </span>&#123;    <span class="hljs-comment">/* 存放用户级的管理钩子 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//初始化阶段，首先向Shutdown中添加一个用户级别的线程，该线程中将会执行`runHooks()`方法.后续在Shutdown中通过该线程的引用来执行该线程run()方法。</span>            Shutdown.add(<span class="hljs-number">1</span> <span class="hljs-comment">/* shutdown hook invocation order */</span>,                <span class="hljs-keyword">false</span> <span class="hljs-comment">/* not registered if shutdown in progress */</span>,                <span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        runHooks();                    &#125;                &#125;            );            hooks = <span class="hljs-keyword">new</span> IdentityHashMap&lt;&gt;();        &#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;            <span class="hljs-comment">// application shutdown hooks cannot be added if</span>            <span class="hljs-comment">// shutdown is in progress.</span>            hooks = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Thread hook)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Shutdown in progress"</span>);        <span class="hljs-keyword">if</span> (hook.isAlive())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Hook already running"</span>);        <span class="hljs-keyword">if</span> (hooks.containsKey(hook))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Hook previously registered"</span>);        hooks.put(hook, hook);    &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Thread hook)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Shutdown in progress"</span>);        <span class="hljs-keyword">if</span> (hook == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">return</span> hooks.remove(hook) != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//该方法将提供给钩子类型的线程调用。</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runHooks</span><span class="hljs-params">()</span> </span>&#123;        Collection&lt;Thread&gt; threads;        <span class="hljs-keyword">synchronized</span>(ApplicationShutdownHooks<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            threads = hooks.keySet();            hooks = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;            hook.start();        &#125;        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;            <span class="hljs-keyword">try</span> &#123;                hook.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123; &#125;        &#125;    &#125;&#125;</code></pre><p>这里需要注意几点：</p><ol><li>在初始化阶段，当static{}执行时，<code>runHooks()</code>并未执行。</li><li>在<code>runHooks()</code>中通过定义局部的threads来转移hooks，转移成功后，hooks将被清空，这样就保证了，关闭钩子的逻辑只能执行一次。例如你在代码中多处调用System.exit()方法，但关闭钩子的执行逻辑只能运行一次。随后启动所有用户Hook线程，再通过调用每个join()的来使主线程等待子线程执行完毕，这也就保证了在正常情况下关闭钩子会在应用最终关闭前完成。</li><li>任何一个应用都会默认存在一个Appliction Hook，该Hook被Shutdown触发后将会引起所有已注册到JVM的ShutdownHook的执行。</li></ol><p>用一张简单的图来描述该过程，如下：</p><pre><code class="hljs sequence">System-&gt;Runtime: exit()Runtime-&gt;Shutdown: exit()Shutdown-&gt;Shutdown:exit()Note right of Shutdown: 执行sequence()，进而执行该类\nrunHooks(),runHooks()中通过执行\nif (hook !&#x3D; null) hook.run()最终引起\nApplicationShutdownHooks.runHooks();Note Left of ApplicationShutdownHooks:runHooks()</code></pre><hr><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1><p>   明白了Runtime和Shutdown Hook原理之后，也需要知道其使用场景,一般有以下三种使用:1.内存管理;2.执行命令;3.临时文件清理</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p> 在某些情况下，我们需要根据当前内存的使用情况，人为的调用<code>System.gc()</code>来尝试回收堆内存中失效的对象。此时就可以用到Runtime中的<code>totalMemory()</code>、<code>freeMemory()</code>等方法。示例如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">autoClean</span><span class="hljs-params">()</span></span>&#123;    Runtime rt=Runtime.getRumtime();    <span class="hljs-keyword">if</span>((rt.totalMemory()-rt.freeMemory())/(<span class="hljs-keyword">double</span>)rt.maxMemory()&gt;<span class="hljs-number">0.90</span>)&#123;        <span class="hljs-comment">//内存利用率到90%以上时，执行相关清理工作</span>    &#125;&#125;</code></pre><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>在某些情况下,需要执行JVM外部的命令,比如打开Window平台中的记事本应用:</p><pre><code class="hljs java">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;                 Runtime r = Runtime.getRuntime();                 Process p = <span class="hljs-keyword">null</span>;                 <span class="hljs-keyword">try</span>&#123;                         p = r.exec(<span class="hljs-string">"notepad"</span>);                 &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                                         &#125;         &#125; &#125;</code></pre><p>注意：通过<code>exec（）</code>方式执行命令时，该命令在单独的进程（Process）中。</p><h2 id="临时文件清理"><a href="#临时文件清理" class="headerlink" title="临时文件清理"></a>临时文件清理</h2><p>在应用运行期间,我们往往会创建很多临时文件.一个比较好的时机就是在虚拟机关闭的时候删除这些临时文件:</p><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">20000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"auto clean temporary file"</span>);&#125;&#125;));&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常体系</title>
    <link href="/2015/01/17/%E8%B0%88Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <url>/2015/01/17/%E8%B0%88Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h1><p>异常是指由于各种不期而至的情况,导致程序中断运行的一种指令流,如:文件找不到,非法参数,网络超时等.为了保证正序正常运行,在设计程序时必须考虑到各种异常情况,并正确的对异常进行处理.异常也是一种对象,java当中定义了许多异常类,并且定义了java.lang.Throwable作为所有异常类的基类.</p><p>Java语言设计者将异常划分为两类:Error和Exception,其体系结构大致如下图所示：</p><p><img src="https://i.imgur.com/HHbCeed.png" srcset="/img/loading.gif" alt="image-20181023103106457"></p><p>Throwable有两个重要的子类:Exception和Error.Error是程序中无法处理的错误,表示运行应用程序中出现了严重的错误.此类错误一般表示代码运行时JVM出现问题.通常有Virtual MachineError,NoClassDefFoundError,OutOfMemoryError等,这些错误是不可查的,通常是非代码性错误.Exception则是程序本身可以捕获并且可以处理的异常.我们重点来看下Throwable类中常用的方法:</p><ul><li><p>e.getCause():返回抛出异常的原因</p></li><li><p>e.getMessage():返回异常信息</p></li><li><p>e.printStackTrace():发生异常时，跟踪堆栈信息并输出</p></li></ul><h2 id="运行时异常与编译异常"><a href="#运行时异常与编译异常" class="headerlink" title="运行时异常与编译异常"></a>运行时异常与编译异常</h2><p>Exception这种异常又分为两类: 运行时异常和编译异常。</p><ul><li>运行时异常: 程序运行期间抛出的异常.RuntimeException类及其子类表示JVM在运行期间可能出现的错误.比如<code>NullPointerException</code>等.此类异常属于不可查异常,一般是由程序逻辑错误引起的,在程序中可以选择捕获处理.</li><li>编译异常: 在编译阶段抛出的异常.Exception中除RuntimeException及其子类之外的异常.如果程序中出现此类异常,如说IOException,必须对该异常进行处理,否则编译不通过.在程序中,通常不会自定义该类异常,而是直接使用系统提供的异常类.</li></ul><h2 id="可查异常与不可查异常"><a href="#可查异常与不可查异常" class="headerlink" title="可查异常与不可查异常"></a>可查异常与不可查异常</h2><p>java中的异常其中一共就分为两类:checked execption和unchecked exception.</p><ul><li><p>checked exception: 编译器要求必须处理的异常,除RuntimeException及其子类外.其他的Exception异常都属于可查异常.编译器会检查此类异常,也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常:要么使用try-catch捕获,要么使用throws语句抛出,否则编译不通过.</p></li><li><p>unchecked exception: 编译器不会进行检查并且不要求必须处理的异常,也就说当程序中出现此类异常时,即使我们没有try-catch捕获它,也没有使用throws抛出该异常,编译也会正常通过.该类异常包括RuntimeException及其子类和Error.</p></li></ul><h1 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h1><p> 在java应用中，当一个方法出现错误而引发异常时，虚拟机会将该异常类型以及异常出现时的程序状态信息封装为异常对象对象,JVM采用不同的处理方式:</p><ul><li>运行异常将由系统自动抛出,应用本身可以捕获该异常或者继续往外层抛出</li><li>对于方法中产生的Error,一旦发生JVM会自行处理</li><li>对于所有的可查异常,必须进行捕获或者往外抛出交给上层处理.</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;......     <span class="hljs-comment">//可能产生的异常的代码区，也称为监控区</span>......    &#125;<span class="hljs-keyword">catch</span> (ExceptionType1 e) &#123;     <span class="hljs-comment">//捕获并处理try抛出异常类型为ExceptionType1的异常</span>    &#125;<span class="hljs-keyword">catch</span>(ExceptionType2 e) &#123;     <span class="hljs-comment">//捕获并处理try抛出异常类型为ExceptionType2的异常</span>    &#125;</code></pre><p>监控区一旦发生异常,虚拟机根据当前运行时的信息创建异常对象，并将该异常对象抛出监控区，同时虚拟机根据该异常对象依次匹配catch子句.若匹配成功(抛出的异常对象的类型和catch子句的异常类的类型或者是该异常类的子类的类型一致),则运行其中catch代码块中的异常处理代码.一旦处理结束那就意味着整个try-catch结束.对于含有多个catch子句的情况,一旦其中一个catch子句与抛出的异常对象类型一致时,其他catch子句将不再有匹配异常对象的机会.</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    .......     <span class="hljs-comment">//可能产生的异常的代码区</span> ....... &#125;<span class="hljs-keyword">catch</span> (ExceptionType1 e) &#123;     <span class="hljs-comment">//捕获并处理try抛出异常类型为ExceptionType1的异常</span> &#125;<span class="hljs-keyword">catch</span> (ExceptionType2 e)&#123;     <span class="hljs-comment">//捕获并处理try抛出异常类型为ExceptionType2的异常</span> &#125;<span class="hljs-keyword">finally</span>&#123;     <span class="hljs-comment">//无论是出现异常，finally块中的代码都将被执行</span> &#125;</code></pre><p>try-catch-finally代码块的执行顺序按照以下方式进行:</p><ol><li><p>try没有捕获异常时,try代码块中的语句依次被执行,跳过catch.如果存在finally则执行finally代码块,否则执行后续代码.</p></li><li><p>try捕获到异常时,如果没有与之匹配的catch子句,则该异常交给JVM处理.如果存在finally,则其中的代码仍然被执行,但是finally之后的代码不会被执行.</p></li><li><p>try捕获到异常时,如果存在与之匹配的catch,则跳到该catch代码块执行处理.如果存在finally则执行finally代码块.执行完finally代码块之后继续执行后续代码;否则直接执行后续代码.需要注意,try代码块出现异常之后的代码不会被执行,如下图所示:</p><p><img src="https://i.imgur.com/SfVcmte.png" srcset="/img/loading.gif" alt="image-20181023105901877"></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>try代码块:用于捕获异常.其后可以接零个或者多个catch块.如果没有catch块,后必须跟finally块来完成资源释放等操作.另外建议不要在finally中使用return.不用尝试通过catch来控制代码流程.</li><li>catch代码块:用于捕获异常,并在其中处理异常.</li><li>finally代码块:无论是否捕获异常,finally代码总会被执行.如果try代码块或者catch代码块中有return语句时,finally代码块将在方法返回前被执行.注意以下几种情况，finally代码块不会被执行<ol><li>在前边的代码中使用</li><li>程序所在的线程死亡或者(系统突然关机)</li><li>如果在finally代码块中的操作又产生异常,则该finally代码块不能完全执行结束,同时该异常会覆盖之前抛出的异常</li></ol></li></ul><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>如果一个方法可能抛出异常,但是没有能力处理该异常或者需要通过该异常向上层汇报处理结果,可以在方法声明时使用throws来抛出异常,这就相当于计算机硬件发生损坏,但是计算机本身无法处理,就将该异常交给维修人员来处理,</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">methodName</span><span class="hljs-params">(params)</span> <span class="hljs-keyword">throws</span> Exception1,Exception2......</span>&#123; &#125;</code></pre><p>其中Exception1,Exception2…代表该方法可能抛出的异常.该方法的调用者需要对其进行处理,当然也可以继续往外抛出.</p><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>在方法内,可以用throw来抛出一个Throwable类型的异常.JVM一旦执行到throw语句，将退出该方法栈,也就是throw后面的代码将不会被执行了.需要注意我们只能抛出Throwable和其子类类型的对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">methodName</span> <span class="hljs-params">(params)</span> </span>&#123;    ......        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExceptionType;    ......&#125;</code></pre><h1 id="异常转译"><a href="#异常转译" class="headerlink" title="异常转译"></a>异常转译</h1><p>异常转义就是将一种类型的异常转成另一种类型的异常.之所以要进行转译,是为了更准确的描述异常.就我个人而言,我更喜欢称之为异常类型转换.在实际应用中,为了构建自己的日志系统,经常需要把系统的一些异常信息描述成我们统一的异常信息,此时就可以使用异常转译.异常转译针对所有Throwable类的子类而言,其子类型都可以相互转换.</p><p>在下面的代码中,我们自定义了MyException异常类,然后我们在遇到IOException类型的异常将其转为MyException类型的异常:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String msg, Throwable e)</span> </span>&#123;      <span class="hljs-keyword">super</span>(msg, e);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> MyException </span>&#123;      Filefile =<span class="hljs-keyword">new</span> File(<span class="hljs-string">"H:/test.txt"</span>);      <span class="hljs-keyword">if</span> (file.exists())          <span class="hljs-keyword">try</span> &#123;             file.createNewFile();          &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">"文件创建失败！"</span>, e);          &#125;   &#125;&#125;</code></pre><h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>在异常转译的过程中,我们希望在新类型的异常对象中保存原始类型异常对象的信息,即当程序捕获了一个底层的异常,而在catch处理异常的时候选择将该异常封装在一个新类型异常对象中,并将新异常对象继续抛给上层,此时最原始的异常就会逐层传递,形成一个由低到高的异常链.由于异常链每次都需要就将原始的异常对象封装为新的异常对象,消耗大量资源,因此在实际应用中需要特别谨慎.现在（jdk 1.4之后）所有的Throwable的子类构造中都可以接受一个cause对象,这个cause也就是原始的异常对象.下面是一个不错的例子：</p><pre><code class="hljs java"><span class="hljs-comment">// 高层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HighLevelExceptionextends</span> <span class="hljs-title">Exception</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HighLevelException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;      <span class="hljs-keyword">super</span>(cause);   &#125;&#125;<span class="hljs-comment">// 中层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiddleLevelExceptionextends</span> <span class="hljs-title">Exception</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MiddleLevelException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;      <span class="hljs-keyword">super</span>(cause);   &#125;&#125;<span class="hljs-comment">// 底层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowLevelExceptionextends</span> <span class="hljs-title">Exception</span></span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestException</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">highLevelAccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> HighLevelException</span>&#123;      <span class="hljs-keyword">try</span> &#123;          middleLevelAccess();      &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HighLevelException(e);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">middleLevelAccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MiddleLevelException</span>&#123;      <span class="hljs-keyword">try</span> &#123;          lowLevelAccess();      &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MiddleLevelException(e);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowLevelAccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LowLevelException </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LowLevelException();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">/*</span><span class="hljs-comment">       * lowlevelAccess()将异常对象抛给middleLevelAccess()，而</span><span class="hljs-comment">       * middleLevelAccess()又将异常对象抛给highLevelAccess(),</span><span class="hljs-comment">       *也就是底层的异常对象一层层传递给高层。最终在在高层可以获得底层的异常对象。</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">new</span> TestException().highLevelAccess();      &#125;<span class="hljs-keyword">catch</span> (HighLevelException e) &#123;          e.printStackTrace();          System.out.println(e.getCause());      &#125;   &#125;&#125;</code></pre><h1 id="异常汇总"><a href="#异常汇总" class="headerlink" title="异常汇总"></a>异常汇总</h1><p>此部分可以api文档中进行查阅,这里仅做参考.</p><table><thead><tr><th>异常类型</th><th>含义</th></tr></thead><tbody><tr><td>IllegalAccessError</td><td>违法访问错误.当一个应用试图访问,修改某个类的域或者调用其方法,但是又违反域或方法的可见性声明,则抛出该异常</td></tr><tr><td>InstantiationError</td><td>实例化错误.当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</td></tr><tr><td>OutOfMemoryError</td><td>内存不足错误.当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误.</td></tr><tr><td>StackOverflowError</td><td>堆栈溢出错误.当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误.</td></tr><tr><td>ClassCastException</td><td>强制类型转换异常.假设有类A和B(A不是B的父类或子类),O是A的实例,那么当强制将O构造为类B的实例时抛出该异常.</td></tr><tr><td>ClassNotFoundException</td><td>找不到类异常.当应用试图根据字符串形式的类名构造类,而在遍历CLASSPAH之后找不到对应名称的class文件时.抛出该异常.</td></tr><tr><td>ArithmeticException</td><td>算术条件异常.譬如:整数除零等</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组索引越界异常,当对数组的索引值为负数或大于等于数组大小时抛出</td></tr><tr><td>IndexOutOfBoundsException</td><td>索引越界异常.当访问某个序列的索引值小于0或大于等于序列大小时,抛出该异常.</td></tr><tr><td>NoSuchFieldException</td><td>属性不存在异常,当访问某个类的不存在的属性时抛出该异常</td></tr><tr><td>NoSuchMethodException</td><td>方法不存在异常.当访问某个类的不存在的方法时抛出该异常</td></tr><tr><td>NullPointerException</td><td>空指针异常,当应用试图在要求使用对象的地方使用了null时抛出该异常.</td></tr><tr><td>NumberFormatException</td><td>数字格式异常.当试图将一个String转换为指定的数字类型.而该字符串确不满足数字类型要求的格式时,抛出该异常.</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>字符串索引越界异常.当使用索引值访问某个字符串中的字符,而该索引值小于0或大于等于序列大小时,抛出该异常.</td></tr><tr><td>llegalAccessException</td><td>违法的访问异常.当应用试图通过反射方式创建某个类的实例,访问该类属性,调用该类方法,而当时又无法访问类</td></tr><tr><td>InterruptedException</td><td>线程被中断异常.当某个线程处于长时间的等待,休眠或其他暂停状态,而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常</td></tr><tr><td>IllegalStateException</td><td>违法的状态异常.当在Java环境和应用尚未处于某个方法的合法调用状态,而调用了该方法时,抛出该异常.</td></tr><tr><td>UnsatisfiedLinkError</td><td>链接库链接错误.当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出.</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>Exception</tag>
      
      <tag>Error</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
